<Type Name="ReentrantReadWriteLock" FullName="Java.Util.Concurrent.Locks.ReentrantReadWriteLock">
  <TypeSignature Language="C#" Value="public class ReentrantReadWriteLock : Java.Lang.Object, IDisposable, Java.Interop.IJavaPeerable, Java.IO.ISerializable, Java.Util.Concurrent.Locks.IReadWriteLock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReentrantReadWriteLock extends Java.Lang.Object implements class Android.Runtime.IJavaObject, class Java.Interop.IJavaPeerable, class Java.IO.ISerializable, class Java.Util.Concurrent.Locks.IReadWriteLock, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:Java.Util.Concurrent.Locks.ReentrantReadWriteLock" />
  <TypeSignature Language="F#" Value="type ReentrantReadWriteLock = class&#xA;    inherit Object&#xA;    interface ISerializable&#xA;    interface IJavaObject&#xA;    interface IDisposable&#xA;    interface IJavaPeerable&#xA;    interface IReadWriteLock" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Android.Runtime.IJavaObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.Interop.IJavaPeerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.IO.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.Util.Concurrent.Locks.IReadWriteLock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Android.Runtime.Register("java/util/concurrent/locks/ReentrantReadWriteLock", DoNotGenerateAcw=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;Android.Runtime.Register("java/util/concurrent/locks/ReentrantReadWriteLock", DoNotGenerateAcw=true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="1">
    <summary>An implementation of <c>ReadWriteLock</c> supporting similar
            semantics to <c>ReentrantLock</c>.</summary>
    <remarks>
      <para>An implementation of <c>ReadWriteLock</c> supporting similar
            semantics to <c>ReentrantLock</c>.</para>
      <para>This class has the following properties:
            
            &lt;ul&gt;
            &lt;li&gt;&lt;b&gt;Acquisition order&lt;/b&gt;</para>
      <para>This class does not impose a reader or writer preference
            ordering for lock access.  However, it does support an optional
            &lt;em&gt;fairness&lt;/em&gt; policy.
            
            &lt;dl&gt;
            &lt;dt&gt;&lt;b&gt;<i>Non-fair mode (default)</i>&lt;/b&gt;
            &lt;dd&gt;When constructed as non-fair (the default), the order of entry
            to the read and write lock is unspecified, subject to reentrancy
            constraints.  A nonfair lock that is continuously contended may
            indefinitely postpone one or more reader or writer threads, but
            will normally have higher throughput than a fair lock.
            
            &lt;dt&gt;&lt;b&gt;<i>Fair mode</i>&lt;/b&gt;
            &lt;dd&gt;When constructed as fair, threads contend for entry using an
            approximately arrival-order policy. When the currently held lock
            is released, either the longest-waiting single writer thread will
            be assigned the write lock, or if there is a group of reader threads
            waiting longer than all waiting writer threads, that group will be
            assigned the read lock.</para>
      <para>A thread that tries to acquire a fair read lock (non-reentrantly)
            will block if either the write lock is held, or there is a waiting
            writer thread. The thread will not acquire the read lock until
            after the oldest currently waiting writer thread has acquired and
            released the write lock. Of course, if a waiting writer abandons
            its wait, leaving one or more reader threads as the longest waiters
            in the queue with the write lock free, then those readers will be
            assigned the read lock.</para>
      <para>A thread that tries to acquire a fair write lock (non-reentrantly)
            will block unless both the read lock and write lock are free (which
            implies there are no waiting threads).  (Note that the non-blocking
            <c>ReadLock#tryLock()</c> and <c>WriteLock#tryLock()</c> methods
            do not honor this fair setting and will immediately acquire the lock
            if it is possible, regardless of waiting threads.)
            &lt;/dl&gt;
            
            &lt;li&gt;&lt;b&gt;Reentrancy&lt;/b&gt;</para>
      <para>This lock allows both readers and writers to reacquire read or
            write locks in the style of a <c>ReentrantLock</c>. Non-reentrant
            readers are not allowed until all write locks held by the writing
            thread have been released.</para>
      <para>Additionally, a writer can acquire the read lock, but not
            vice-versa.  Among other applications, reentrancy can be useful
            when write locks are held during calls or callbacks to methods that
            perform reads under read locks.  If a reader tries to acquire the
            write lock it will never succeed.
            
            &lt;li&gt;&lt;b&gt;Lock downgrading&lt;/b&gt;</para>
      <para>Reentrancy also allows downgrading from the write lock to a read lock,
            by acquiring the write lock, then the read lock and then releasing the
            write lock. However, upgrading from a read lock to the write lock is
            &lt;b&gt;not&lt;/b&gt; possible.
            
            &lt;li&gt;&lt;b&gt;Interruption of lock acquisition&lt;/b&gt;</para>
      <para>The read lock and write lock both support interruption during lock
            acquisition.
            
            &lt;li&gt;&lt;b&gt;<c>Condition</c> support&lt;/b&gt;</para>
      <para>The write lock provides a <c>Condition</c> implementation that
            behaves in the same way, with respect to the write lock, as the
            <c>Condition</c> implementation provided by
            <c>ReentrantLock#newCondition</c> does for <c>ReentrantLock</c>.
            This <c>Condition</c> can, of course, only be used with the write lock.</para>
      <para>The read lock does not support a <c>Condition</c> and
            <c>readLock().newCondition()</c> throws
            <c>UnsupportedOperationException</c>.
            
            &lt;li&gt;&lt;b&gt;Instrumentation&lt;/b&gt;</para>
      <para>This class supports methods to determine whether locks
            are held or contended. These methods are designed for monitoring
            system state, not for synchronization control.
            &lt;/ul&gt;</para>
      <para>Serialization of this class behaves in the same way as built-in
            locks: a deserialized lock is in the unlocked state, regardless of
            its state when serialized.</para>
      <para>&lt;b&gt;Sample usages.&lt;/b&gt; Here is a code sketch showing how to perform
            lock downgrading after updating a cache (exception handling is
            particularly tricky when handling multiple locks in a non-nested
            fashion):</para>
      <code lang="text/java">{@code
            class CachedData {
              Object data;
              boolean cacheValid;
              final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
            
              void processCachedData() {
                rwl.readLock().lock();
                if (!cacheValid) {
                  // Must release read lock before acquiring write lock
                  rwl.readLock().unlock();
                  rwl.writeLock().lock();
                  try {
                    // Recheck state because another thread might have
                    // acquired write lock and changed state before we did.
                    if (!cacheValid) {
                      data = ...;
                      cacheValid = true;
                    }
                    // Downgrade by acquiring read lock before releasing write lock
                    rwl.readLock().lock();
                  } finally {
                    rwl.writeLock().unlock(); // Unlock write, still hold read
                  }
                }
            
                try {
                  use(data);
                } finally {
                  rwl.readLock().unlock();
                }
              }
            }}</code>
      <para>ReentrantReadWriteLocks can be used to improve concurrency in some
            uses of some kinds of Collections. This is typically worthwhile
            only when the collections are expected to be large, accessed by
            more reader threads than writer threads, and entail operations with
            overhead that outweighs synchronization overhead. For example, here
            is a class using a TreeMap that is expected to be large and
            concurrently accessed.</para>
      <code lang="text/java">{@code
            class RWDictionary {
              private final Map&lt;String, Data&gt; m = new TreeMap&lt;&gt;();
              private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
              private final Lock r = rwl.readLock();
              private final Lock w = rwl.writeLock();
            
              public Data get(String key) {
                r.lock();
                try { return m.get(key); }
                finally { r.unlock(); }
              }
              public List&lt;String&gt; allKeys() {
                r.lock();
                try { return new ArrayList&lt;&gt;(m.keySet()); }
                finally { r.unlock(); }
              }
              public Data put(String key, Data value) {
                w.lock();
                try { return m.put(key, value); }
                finally { w.unlock(); }
              }
              public void clear() {
                w.lock();
                try { m.clear(); }
                finally { w.unlock(); }
              }
            }}</code>
      <para>&lt;h2&gt;Implementation Notes&lt;/h2&gt;</para>
      <para>This lock supports a maximum of 65535 recursive write locks
            and 65535 read locks. Attempts to exceed these limits result in
            <c>Error</c> throws from locking methods.</para>
      <para>Added in 1.5.</para>
      <para>
        <format type="text/html">
          <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock</code>.</a>
        </format>
      </para>
      <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
    </remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReentrantReadWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register(".ctor", "()V", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register(".ctor", "()V", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Creates a new <c>ReentrantReadWriteLock</c> with
            default (nonfair) ordering properties.</summary>
        <remarks>
          <para>Creates a new <c>ReentrantReadWriteLock</c> with
            default (nonfair) ordering properties.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#ReentrantReadWriteLock()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.ReentrantReadWriteLock()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReentrantReadWriteLock (bool fair);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool fair) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.#ctor(System.Boolean)" />
      <MemberSignature Language="F#" Value="new Java.Util.Concurrent.Locks.ReentrantReadWriteLock : bool -&gt; Java.Util.Concurrent.Locks.ReentrantReadWriteLock" Usage="new Java.Util.Concurrent.Locks.ReentrantReadWriteLock fair" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register(".ctor", "(Z)V", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register(".ctor", "(Z)V", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fair" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fair">
          <c>true</c> if this lock should use a fair ordering policy</param>
        <summary>Creates a new <c>ReentrantReadWriteLock</c> with
            the given fairness policy.</summary>
        <remarks>
          <para>Creates a new <c>ReentrantReadWriteLock</c> with
            the given fairness policy.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#ReentrantReadWriteLock(boolean)" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.ReentrantReadWriteLock(boolean)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReentrantReadWriteLock (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.#ctor(System.IntPtr,Android.Runtime.JniHandleOwnership)" />
      <MemberSignature Language="F#" Value="new Java.Util.Concurrent.Locks.ReentrantReadWriteLock : nativeint * Android.Runtime.JniHandleOwnership -&gt; Java.Util.Concurrent.Locks.ReentrantReadWriteLock" Usage="new Java.Util.Concurrent.Locks.ReentrantReadWriteLock (javaReference, transfer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWaitingThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;? GetWaitingThreads (Java.Util.Concurrent.Locks.ICondition? condition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; GetWaitingThreads(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.GetWaitingThreads(Java.Util.Concurrent.Locks.ICondition)" />
      <MemberSignature Language="F#" Value="abstract member GetWaitingThreads : Java.Util.Concurrent.Locks.ICondition -&gt; System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;&#xA;override this.GetWaitingThreads : Java.Util.Concurrent.Locks.ICondition -&gt; System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;" Usage="reentrantReadWriteLock.GetWaitingThreads condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("getWaitingThreads", "(Ljava/util/concurrent/locks/Condition;)Ljava/util/Collection;", "GetGetWaitingThreads_Ljava_util_concurrent_locks_Condition_Handler")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("getWaitingThreads", "(Ljava/util/concurrent/locks/Condition;)Ljava/util/Collection;", "GetGetWaitingThreads_Ljava_util_concurrent_locks_Condition_Handler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Returns a collection containing those threads that may be
            waiting on the given condition associated with the write lock.</summary>
        <returns>the collection of threads</returns>
        <remarks>
          <para>Returns a collection containing those threads that may be
            waiting on the given condition associated with the write lock.
            Because the actual set of threads may change dynamically while
            constructing this result, the returned collection is only a
            best-effort estimate. The elements of the returned collection
            are in no particular order.  This method is designed to
            facilitate construction of subclasses that provide more
            extensive condition monitoring facilities.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getWaitingThreads(java.util.concurrent.locks.Condition)" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getWaitingThreads(java.util.concurrent.locks.Condition)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWaitQueueLength">
      <MemberSignature Language="C#" Value="public virtual int GetWaitQueueLength (Java.Util.Concurrent.Locks.ICondition? condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetWaitQueueLength(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.GetWaitQueueLength(Java.Util.Concurrent.Locks.ICondition)" />
      <MemberSignature Language="F#" Value="abstract member GetWaitQueueLength : Java.Util.Concurrent.Locks.ICondition -&gt; int&#xA;override this.GetWaitQueueLength : Java.Util.Concurrent.Locks.ICondition -&gt; int" Usage="reentrantReadWriteLock.GetWaitQueueLength condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("getWaitQueueLength", "(Ljava/util/concurrent/locks/Condition;)I", "GetGetWaitQueueLength_Ljava_util_concurrent_locks_Condition_Handler")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("getWaitQueueLength", "(Ljava/util/concurrent/locks/Condition;)I", "GetGetWaitQueueLength_Ljava_util_concurrent_locks_Condition_Handler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Returns an estimate of the number of threads waiting on the
            given condition associated with the write lock.</summary>
        <returns>the estimated number of waiting threads</returns>
        <remarks>
          <para>Returns an estimate of the number of threads waiting on the
            given condition associated with the write lock. Note that because
            timeouts and interrupts may occur at any time, the estimate
            serves only as an upper bound on the actual number of waiters.
            This method is designed for use in monitoring of the system
            state, not for synchronization control.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getWaitQueueLength(java.util.concurrent.locks.Condition)" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getWaitQueueLength(java.util.concurrent.locks.Condition)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HasQueuedThread">
      <MemberSignature Language="C#" Value="public bool HasQueuedThread (Java.Lang.Thread? thread);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasQueuedThread(class Java.Lang.Thread thread) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.HasQueuedThread(Java.Lang.Thread)" />
      <MemberSignature Language="F#" Value="member this.HasQueuedThread : Java.Lang.Thread -&gt; bool" Usage="reentrantReadWriteLock.HasQueuedThread thread" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("hasQueuedThread", "(Ljava/lang/Thread;)Z", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("hasQueuedThread", "(Ljava/lang/Thread;)Z", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Java.Lang.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">the thread</param>
        <summary>Queries whether the given thread is waiting to acquire either
            the read or write lock.</summary>
        <returns>
          <c>true</c> if the given thread is queued waiting for this lock</returns>
        <remarks>
          <para>Queries whether the given thread is waiting to acquire either
            the read or write lock. Note that because cancellations may
            occur at any time, a <c>true</c> return does not guarantee
            that this thread will ever acquire a lock.  This method is
            designed primarily for use in monitoring of the system state.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#hasQueuedThread(java.lang.Thread)" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.hasQueuedThread(java.lang.Thread)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.NullPointerException">if the thread is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HasQueuedThreads">
      <MemberSignature Language="C#" Value="public bool HasQueuedThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasQueuedThreads" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.HasQueuedThreads" />
      <MemberSignature Language="F#" Value="member this.HasQueuedThreads : bool" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.HasQueuedThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("hasQueuedThreads", "()Z", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("hasQueuedThreads", "()Z", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries whether any threads are waiting to acquire the read or
            write lock.</summary>
        <value>
          <c>true</c> if there may be other threads waiting to
                    acquire the lock</value>
        <remarks>
          <para>Queries whether any threads are waiting to acquire the read or
            write lock. Note that because cancellations may occur at any
            time, a <c>true</c> return does not guarantee that any other
            thread will ever acquire a lock.  This method is designed
            primarily for use in monitoring of the system state.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#hasQueuedThreads()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.hasQueuedThreads()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="HasWaiters">
      <MemberSignature Language="C#" Value="public virtual bool HasWaiters (Java.Util.Concurrent.Locks.ICondition? condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasWaiters(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.HasWaiters(Java.Util.Concurrent.Locks.ICondition)" />
      <MemberSignature Language="F#" Value="abstract member HasWaiters : Java.Util.Concurrent.Locks.ICondition -&gt; bool&#xA;override this.HasWaiters : Java.Util.Concurrent.Locks.ICondition -&gt; bool" Usage="reentrantReadWriteLock.HasWaiters condition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("hasWaiters", "(Ljava/util/concurrent/locks/Condition;)Z", "GetHasWaiters_Ljava_util_concurrent_locks_Condition_Handler")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("hasWaiters", "(Ljava/util/concurrent/locks/Condition;)Z", "GetHasWaiters_Ljava_util_concurrent_locks_Condition_Handler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Queries whether any threads are waiting on the given condition
            associated with the write lock.</summary>
        <returns>
          <c>true</c> if there are any waiting threads</returns>
        <remarks>
          <para>Queries whether any threads are waiting on the given condition
            associated with the write lock. Note that because timeouts and
            interrupts may occur at any time, a <c>true</c> return does
            not guarantee that a future <c>signal</c> will awaken any
            threads.  This method is designed primarily for use in
            monitoring of the system state.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#hasWaiters(java.util.concurrent.locks.Condition)" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.hasWaiters(java.util.concurrent.locks.Condition)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="IsFair">
      <MemberSignature Language="C#" Value="public bool IsFair { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFair" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.IsFair" />
      <MemberSignature Language="F#" Value="member this.IsFair : bool" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.IsFair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("isFair", "()Z", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("isFair", "()Z", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <c>true</c> if this lock has fairness set true.</summary>
        <value>
          <c>true</c> if this lock has fairness set true</value>
        <remarks>
          <para>Returns <c>true</c> if this lock has fairness set true.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#isFair()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.isFair()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsWriteLocked">
      <MemberSignature Language="C#" Value="public virtual bool IsWriteLocked { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLocked" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.IsWriteLocked" />
      <MemberSignature Language="F#" Value="member this.IsWriteLocked : bool" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.IsWriteLocked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("isWriteLocked", "()Z", "GetIsWriteLockedHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("isWriteLocked", "()Z", "GetIsWriteLockedHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries if the write lock is held by any thread.</summary>
        <value>
          <c>true</c> if any thread holds the write lock and
                    <c>false</c> otherwise</value>
        <remarks>
          <para>Queries if the write lock is held by any thread. This method is
            designed for use in monitoring system state, not for
            synchronization control.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#isWriteLocked()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLocked()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockedByCurrentThread">
      <MemberSignature Language="C#" Value="public virtual bool IsWriteLockedByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockedByCurrentThread" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.IsWriteLockedByCurrentThread" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockedByCurrentThread : bool" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.IsWriteLockedByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("isWriteLockedByCurrentThread", "()Z", "GetIsWriteLockedByCurrentThreadHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("isWriteLockedByCurrentThread", "()Z", "GetIsWriteLockedByCurrentThreadHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries if the write lock is held by the current thread.</summary>
        <value>
          <c>true</c> if the current thread holds the write lock and
                    <c>false</c> otherwise</value>
        <remarks>
          <para>Queries if the write lock is held by the current thread.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#isWriteLockedByCurrentThread()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLockedByCurrentThread()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="JniPeerMembers">
      <MemberSignature Language="C#" Value="public override Java.Interop.JniPeerMembers JniPeerMembers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Interop.JniPeerMembers JniPeerMembers" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.JniPeerMembers" />
      <MemberSignature Language="F#" Value="member this.JniPeerMembers : Java.Interop.JniPeerMembers" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.JniPeerMembers" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:Java.Interop.IJavaPeerable.JniPeerMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Interop.JniPeerMembers</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="protected virtual Java.Lang.Thread? Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Lang.Thread Owner" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.Owner" />
      <MemberSignature Language="F#" Value="member this.Owner : Java.Lang.Thread" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getOwner", "()Ljava/lang/Thread;", "GetGetOwnerHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getOwner", "()Ljava/lang/Thread;", "GetGetOwnerHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the thread that currently owns the write lock, or
            <c>null</c> if not owned.</summary>
        <value>the owner, or <c>null</c> if not owned</value>
        <remarks>
          <para>Returns the thread that currently owns the write lock, or
            <c>null</c> if not owned. When this method is called by a
            thread that is not the owner, the return value reflects a
            best-effort approximation of current lock status. For example,
            the owner may be momentarily <c>null</c> even if there are
            threads trying to acquire the lock but have not yet done so.
            This method is designed to facilitate construction of
            subclasses that provide more extensive lock monitoring
            facilities.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getOwner()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getOwner()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedReaderThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;? QueuedReaderThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedReaderThreads" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueuedReaderThreads" />
      <MemberSignature Language="F#" Value="member this.QueuedReaderThreads : System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueuedReaderThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getQueuedReaderThreads", "()Ljava/util/Collection;", "GetGetQueuedReaderThreadsHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getQueuedReaderThreads", "()Ljava/util/Collection;", "GetGetQueuedReaderThreadsHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
            acquire the read lock.</summary>
        <value>the collection of threads</value>
        <remarks>
          <para>Returns a collection containing threads that may be waiting to
            acquire the read lock.  Because the actual set of threads may
            change dynamically while constructing this result, the returned
            collection is only a best-effort estimate.  The elements of the
            returned collection are in no particular order.  This method is
            designed to facilitate construction of subclasses that provide
            more extensive lock monitoring facilities.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getQueuedReaderThreads()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedReaderThreads()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;? QueuedThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedThreads" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueuedThreads" />
      <MemberSignature Language="F#" Value="member this.QueuedThreads : System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueuedThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getQueuedThreads", "()Ljava/util/Collection;", "GetGetQueuedThreadsHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getQueuedThreads", "()Ljava/util/Collection;", "GetGetQueuedThreadsHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
            acquire either the read or write lock.</summary>
        <value>the collection of threads</value>
        <remarks>
          <para>Returns a collection containing threads that may be waiting to
            acquire either the read or write lock.  Because the actual set
            of threads may change dynamically while constructing this
            result, the returned collection is only a best-effort estimate.
            The elements of the returned collection are in no particular
            order.  This method is designed to facilitate construction of
            subclasses that provide more extensive monitoring facilities.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getQueuedThreads()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedThreads()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedWriterThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;? QueuedWriterThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedWriterThreads" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueuedWriterThreads" />
      <MemberSignature Language="F#" Value="member this.QueuedWriterThreads : System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueuedWriterThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getQueuedWriterThreads", "()Ljava/util/Collection;", "GetGetQueuedWriterThreadsHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getQueuedWriterThreads", "()Ljava/util/Collection;", "GetGetQueuedWriterThreadsHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
            acquire the write lock.</summary>
        <value>the collection of threads</value>
        <remarks>
          <para>Returns a collection containing threads that may be waiting to
            acquire the write lock.  Because the actual set of threads may
            change dynamically while constructing this result, the returned
            collection is only a best-effort estimate.  The elements of the
            returned collection are in no particular order.  This method is
            designed to facilitate construction of subclasses that provide
            more extensive lock monitoring facilities.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getQueuedWriterThreads()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedWriterThreads()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueueLength">
      <MemberSignature Language="C#" Value="public int QueueLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 QueueLength" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueueLength" />
      <MemberSignature Language="F#" Value="member this.QueueLength : int" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.QueueLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getQueueLength", "()I", "")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getQueueLength", "()I", "")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an estimate of the number of threads waiting to acquire
            either the read or write lock.</summary>
        <value>the estimated number of threads waiting for this lock</value>
        <remarks>
          <para>Returns an estimate of the number of threads waiting to acquire
            either the read or write lock.  The value is only an estimate
            because the number of threads may change dynamically while this
            method traverses internal data structures.  This method is
            designed for use in monitoring system state, not for
            synchronization control.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getQueueLength()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getQueueLength()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ReadHoldCount">
      <MemberSignature Language="C#" Value="public virtual int ReadHoldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadHoldCount" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ReadHoldCount" />
      <MemberSignature Language="F#" Value="member this.ReadHoldCount : int" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ReadHoldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getReadHoldCount", "()I", "GetGetReadHoldCountHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getReadHoldCount", "()I", "GetGetReadHoldCountHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of reentrant read holds on this lock by the
            current thread.</summary>
        <value>the number of holds on the read lock by the current thread,
                    or zero if the read lock is not held by the current thread</value>
        <remarks>
          <para>Queries the number of reentrant read holds on this lock by the
            current thread.  A reader thread has a hold on a lock for
            each lock action that is not matched by an unlock action.</para>
          <para>Added in 1.6.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getReadHoldCount()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getReadHoldCount()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 9" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.Locks.ILock? ReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Java.Util.Concurrent.Locks.ILock ReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ReadLock" />
      <MemberSignature Language="F#" Value="abstract member ReadLock : unit -&gt; Java.Util.Concurrent.Locks.ILock&#xA;override this.ReadLock : unit -&gt; Java.Util.Concurrent.Locks.ILock" Usage="reentrantReadWriteLock.ReadLock " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Java.Util.Concurrent.Locks.IReadWriteLock.ReadLock</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("readLock", "()Ljava/util/concurrent/locks/Lock;", "GetReadLockHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("readLock", "()Ljava/util/concurrent/locks/Lock;", "GetReadLockHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.Locks.ILock</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the lock used for reading.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ReadLockCount">
      <MemberSignature Language="C#" Value="public virtual int ReadLockCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadLockCount" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ReadLockCount" />
      <MemberSignature Language="F#" Value="member this.ReadLockCount : int" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ReadLockCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getReadLockCount", "()I", "GetGetReadLockCountHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getReadLockCount", "()I", "GetGetReadLockCountHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of read locks held for this lock.</summary>
        <value>the number of read locks held</value>
        <remarks>
          <para>Queries the number of read locks held for this lock. This
            method is designed for use in monitoring system state, not for
            synchronization control.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getReadLockCount()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getReadLockCount()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ThresholdClass" />
      <MemberSignature Language="F#" Value="member this.ThresholdClass : nativeint" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ThresholdType" />
      <MemberSignature Language="F#" Value="member this.ThresholdType : Type" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteHoldCount">
      <MemberSignature Language="C#" Value="public virtual int WriteHoldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteHoldCount" />
      <MemberSignature Language="DocId" Value="P:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.WriteHoldCount" />
      <MemberSignature Language="F#" Value="member this.WriteHoldCount : int" Usage="Java.Util.Concurrent.Locks.ReentrantReadWriteLock.WriteHoldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: Android.Runtime.Register("getWriteHoldCount", "()I", "GetGetWriteHoldCountHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: Android.Runtime.Register("getWriteHoldCount", "()I", "GetGetWriteHoldCountHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of reentrant write holds on this lock by the
            current thread.</summary>
        <value>the number of holds on the write lock by the current thread,
                    or zero if the write lock is not held by the current thread</value>
        <remarks>
          <para>Queries the number of reentrant write holds on this lock by the
            current thread.  A writer thread has a hold on a lock for
            each lock action that is not matched by an unlock action.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock#getWriteHoldCount()" title="Reference documentation">Java documentation for <code>java.util.concurrent.locks.ReentrantReadWriteLock.getWriteHoldCount()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.Locks.ILock? WriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Java.Util.Concurrent.Locks.ILock WriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Util.Concurrent.Locks.ReentrantReadWriteLock.WriteLock" />
      <MemberSignature Language="F#" Value="abstract member WriteLock : unit -&gt; Java.Util.Concurrent.Locks.ILock&#xA;override this.WriteLock : unit -&gt; Java.Util.Concurrent.Locks.ILock" Usage="reentrantReadWriteLock.WriteLock " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:Java.Util.Concurrent.Locks.IReadWriteLock.WriteLock</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("writeLock", "()Ljava/util/concurrent/locks/Lock;", "GetWriteLockHandler")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("writeLock", "()Ljava/util/concurrent/locks/Lock;", "GetWriteLockHandler")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.Locks.ILock</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the lock used for writing.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
  </Members>
</Type>
