<Type Name="ReentrantLock" FullName="Java.Util.Concurrent.Locks.ReentrantLock">
  <TypeSignature Language="C#" Value="public class ReentrantLock : Java.Lang.Object, IDisposable, Java.IO.ISerializable, Java.Util.Concurrent.Locks.ILock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReentrantLock extends Java.Lang.Object implements class Android.Runtime.IJavaObject, class Java.IO.ISerializable, class Java.Util.Concurrent.Locks.ILock, class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Java.IO.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.Util.Concurrent.Locks.ILock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("java/util/concurrent/locks/ReentrantLock", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A reentrant mutual exclusion <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> with the same basic
 behavior and semantics as the implicit monitor lock accessed using
 <c>synchronized</c> methods and statements, but with extended
 capabilities.</summary>
    <remarks><para tool="javadoc-to-mdoc">A reentrant mutual exclusion <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> with the same basic
 behavior and semantics as the implicit monitor lock accessed using
 <c>synchronized</c> methods and statements, but with extended
 capabilities.

 </para><para tool="javadoc-to-mdoc">A <c>ReentrantLock</c> is <i>owned</i> by the thread last
 successfully locking, but not yet unlocking it. A thread invoking
 <c>lock</c> will return, successfully acquiring the lock, when
 the lock is not owned by another thread. The method will return
 immediately if the current thread already owns the lock. This can
 be checked using methods <c><see cref="P:Java.Util.Concurrent.Locks.ReentrantLock.IsHeldByCurrentThread" /></c>, and <c><see cref="P:Java.Util.Concurrent.Locks.ReentrantLock.HoldCount" /></c>.

 </para><para tool="javadoc-to-mdoc">The constructor for this class accepts an optional
 <i>fairness</i> parameter.  When set <c>true</c>, under
 contention, locks favor granting access to the longest-waiting
 thread.  Otherwise this lock does not guarantee any particular
 access order.  Programs using fair locks accessed by many threads
 may display lower overall throughput (i.e., are slower; often much
 slower) than those using the default setting, but have smaller
 variances in times to obtain locks and guarantee lack of
 starvation. Note however, that fairness of locks does not guarantee
 fairness of thread scheduling. Thus, one of many threads using a
 fair lock may obtain it multiple times in succession while other
 active threads are not progressing and not currently holding the
 lock.
 Also note that the untimed <c><see cref="M:Java.Util.Concurrent.Locks.ReentrantLock.TryLock" /></c> method does not
 honor the fairness setting. It will succeed if the lock
 is available even if other threads are waiting.

 </para><para tool="javadoc-to-mdoc">It is recommended practice to <i>always</i> immediately
 follow a call to <c>lock</c> with a <c>try</c> block, most
 typically in a before/after construction such as:

  <sample external-id="73768F146440307EC7F03F85388EF40B" /></para><para tool="javadoc-to-mdoc">In addition to implementing the <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> interface, this
 class defines a number of <c>public</c> and <c>protected</c>
 methods for inspecting the state of the lock.  Some of these
 methods are only useful for instrumentation and monitoring.

 </para><para tool="javadoc-to-mdoc">Serialization of this class behaves in the same way as built-in
 locks: a deserialized lock is in the unlocked state, regardless of
 its state when serialized.

 </para><para tool="javadoc-to-mdoc">This lock supports a maximum of 2147483647 recursive locks by
 the same thread. Attempts to exceed this limit result in
 <c><see cref="T:Java.Lang.Error" /></c> throws from locking methods.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html" target="_blank">[Android Documentation]</a></format></para></remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReentrantLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Creates an instance of <c>ReentrantLock</c>.</summary>
        <remarks><para tool="javadoc-to-mdoc">Creates an instance of <c>ReentrantLock</c>.
 This is equivalent to using <c>ReentrantLock(false)</c>.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#ReentrantLock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReentrantLock (bool fair);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool fair) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(Z)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fair" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fair">To be added.</param>
        <summary>Creates an instance of <c>ReentrantLock</c> with the
 given fairness policy.</summary>
        <remarks><para tool="javadoc-to-mdoc">Creates an instance of <c>ReentrantLock</c> with the
 given fairness policy.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#ReentrantLock(boolean)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReentrantLock (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject``1(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWaitingThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt; GetWaitingThreads (Java.Util.Concurrent.Locks.ICondition condition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; GetWaitingThreads(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getWaitingThreads", "(Ljava/util/concurrent/locks/Condition;)Ljava/util/Collection;", "GetGetWaitingThreads_Ljava_util_concurrent_locks_Condition_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Returns a collection containing those threads that may be
 waiting on the given condition associated with this lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns a collection containing those threads that may be
 waiting on the given condition associated with this lock.
 Because the actual set of threads may change dynamically while
 constructing this result, the returned collection is only a
 best-effort estimate. The elements of the returned collection
 are in no particular order.  This method is designed to
 facilitate construction of subclasses that provide more
 extensive condition monitoring facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#getWaitingThreads(java.util.concurrent.locks.Condition)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWaitQueueLength">
      <MemberSignature Language="C#" Value="public virtual int GetWaitQueueLength (Java.Util.Concurrent.Locks.ICondition condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetWaitQueueLength(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getWaitQueueLength", "(Ljava/util/concurrent/locks/Condition;)I", "GetGetWaitQueueLength_Ljava_util_concurrent_locks_Condition_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Returns an estimate of the number of threads waiting on the
 given condition associated with this lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns an estimate of the number of threads waiting on the
 given condition associated with this lock. Note that because
 timeouts and interrupts may occur at any time, the estimate
 serves only as an upper bound on the actual number of waiters.
 This method is designed for use in monitoring of the system
 state, not for synchronization control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#getWaitQueueLength(java.util.concurrent.locks.Condition)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HasQueuedThread">
      <MemberSignature Language="C#" Value="public bool HasQueuedThread (Java.Lang.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasQueuedThread(class Java.Lang.Thread thread) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("hasQueuedThread", "(Ljava/lang/Thread;)Z", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Java.Lang.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">the thread</param>
        <summary>Queries whether the given thread is waiting to acquire this
 lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Queries whether the given thread is waiting to acquire this
 lock. Note that because cancellations may occur at any time, a
 <c>true</c> return does not guarantee that this thread
 will ever acquire this lock.  This method is designed primarily for use
 in monitoring of the system state.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#hasQueuedThread(java.lang.Thread)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.NullPointerException">if the thread is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HasQueuedThreads">
      <MemberSignature Language="C#" Value="public bool HasQueuedThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasQueuedThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("hasQueuedThreads", "()Z", "GetHasQueuedThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries whether any threads are waiting to acquire this lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries whether any threads are waiting to acquire this lock. Note that
 because cancellations may occur at any time, a <c>true</c>
 return does not guarantee that any other thread will ever
 acquire this lock.  This method is designed primarily for use in
 monitoring of the system state.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#hasQueuedThreads()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="HasWaiters">
      <MemberSignature Language="C#" Value="public virtual bool HasWaiters (Java.Util.Concurrent.Locks.ICondition condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasWaiters(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("hasWaiters", "(Ljava/util/concurrent/locks/Condition;)Z", "GetHasWaiters_Ljava_util_concurrent_locks_Condition_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Queries whether any threads are waiting on the given condition
 associated with this lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Queries whether any threads are waiting on the given condition
 associated with this lock. Note that because timeouts and
 interrupts may occur at any time, a <c>true</c> return does
 not guarantee that a future <c>signal</c> will awaken any
 threads.  This method is designed primarily for use in
 monitoring of the system state.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#hasWaiters(java.util.concurrent.locks.Condition)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HoldCount">
      <MemberSignature Language="C#" Value="public virtual int HoldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HoldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getHoldCount", "()I", "GetGetHoldCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of holds on this lock by the current thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries the number of holds on this lock by the current thread.

 </para><para tool="javadoc-to-mdoc">A thread has a hold on a lock for each lock action that is not
 matched by an unlock action.

 </para><para tool="javadoc-to-mdoc">The hold count information is typically only used for testing and
 debugging purposes. For example, if a certain section of code should
 not be entered with the lock already held then we can assert that
 fact:

  <sample external-id="5C9E4896C391FDD530C1CD2BF103EA2A" /></para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#getHoldCount()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsFair">
      <MemberSignature Language="C#" Value="public bool IsFair { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isFair", "()Z", "GetIsFairHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <c>true</c> if this lock has fairness set true.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns <c>true</c> if this lock has fairness set true.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#isFair()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsHeldByCurrentThread">
      <MemberSignature Language="C#" Value="public virtual bool IsHeldByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHeldByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isHeldByCurrentThread", "()Z", "GetIsHeldByCurrentThreadHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries if this lock is held by the current thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries if this lock is held by the current thread.

 </para><para tool="javadoc-to-mdoc">Analogous to the <c><see cref="M:Java.Lang.Thread.HoldsLock(Java.Lang.Object)" /></c> method for built-in
 monitor locks, this method is typically used for debugging and
 testing. For example, a method that should only be called while
 a lock is held can assert that this is the case:

  <sample external-id="D9712A693DF0EB892BBBEF9B5238804E" /></para><para tool="javadoc-to-mdoc">It can also be used to ensure that a reentrant lock is used
 in a non-reentrant manner, for example:

  <sample external-id="038D5E05073A09C133B5B6661B219AC8" /></para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#isHeldByCurrentThread()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsLocked">
      <MemberSignature Language="C#" Value="public virtual bool IsLocked { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isLocked", "()Z", "GetIsLockedHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries if this lock is held by any thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries if this lock is held by any thread. This method is
 designed for use in monitoring of the system state,
 not for synchronization control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#isLocked()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("lock", "()V", "GetLockHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acquires the lock.</summary>
        <remarks><para tool="javadoc-to-mdoc">Acquires the lock.

 </para><para tool="javadoc-to-mdoc">Acquires the lock if it is not held by another thread and returns
 immediately, setting the lock hold count to one.

 </para><para tool="javadoc-to-mdoc">If the current thread already holds the lock then the hold
 count is incremented by one and the method returns immediately.

 </para><para tool="javadoc-to-mdoc">If the lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until the lock has been acquired,
 at which time the lock hold count is set to one.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#lock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="LockInterruptibly">
      <MemberSignature Language="C#" Value="public virtual void LockInterruptibly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LockInterruptibly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("lockInterruptibly", "()V", "GetLockInterruptiblyHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acquires the lock unless the current thread is
 <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.</summary>
        <remarks><para tool="javadoc-to-mdoc">Acquires the lock unless the current thread is
 <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.

 </para><para tool="javadoc-to-mdoc">Acquires the lock if it is not held by another thread and returns
 immediately, setting the lock hold count to one.

 </para><para tool="javadoc-to-mdoc">If the current thread already holds this lock then the hold count
 is incremented by one and the method returns immediately.

 </para><para tool="javadoc-to-mdoc">If the lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of two things happens:

 <list type="bullet"><item><term>The lock is acquired by the current thread; or

 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> the
 current thread.

 </term></item></list></para><para tool="javadoc-to-mdoc">If the lock is acquired by the current thread then the lock hold
 count is set to one.

 </para><para tool="javadoc-to-mdoc">If the current thread:

 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or

 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while acquiring
 the lock,

 </term></item></list>

 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared.

 </para><para tool="javadoc-to-mdoc">In this implementation, as this method is an explicit
 interruption point, preference is given to responding to the
 interrupt over normal or reentrant acquisition of the lock.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#lockInterruptibly()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
</exception>
      </Docs>
    </Member>
    <Member MemberName="NewCondition">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.Locks.ICondition NewCondition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Java.Util.Concurrent.Locks.ICondition NewCondition() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("newCondition", "()Ljava/util/concurrent/locks/Condition;", "GetNewConditionHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.Locks.ICondition</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> instance for use with this
 <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> instance.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns a <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> instance for use with this
 <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> instance.

 </para><para tool="javadoc-to-mdoc">The returned <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> instance supports the same
 usages as do the <c><see cref="T:Java.Lang.Object" /></c> monitor methods (<c><see cref="M:Java.Lang.Object.Wait" /></c>, <c><see cref="M:Java.Lang.Object.Notify" /></c>, and <c><see cref="M:Java.Lang.Object.NotifyAll" /></c>) when used with the built-in
 monitor lock.

 <list type="bullet"><item><term>If this lock is not held when any of the <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c><c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Await" /></c> or <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Signal" /></c> methods are called, then an <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c> is thrown.

 </term></item><item><term>When the condition <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Await" /></c>
 methods are called the lock is released and, before they
 return, the lock is reacquired and the lock hold count restored
 to what it was when the method was called.

 </term></item><item><term>If a thread is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>
 while waiting then the wait will terminate, an <c><see cref="T:Java.Lang.InterruptedException" /></c> will be thrown, and the thread's
 interrupted status will be cleared.

 </term></item><item><term> Waiting threads are signalled in FIFO order.

 </term></item><item><term>The ordering of lock reacquisition for threads returning
 from waiting methods is the same as for threads initially
 acquiring the lock, which is in the default case not specified,
 but for <i>fair</i> locks favors those threads that have been
 waiting the longest.

 </term></item></list></para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#newCondition()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="protected virtual Java.Lang.Thread Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Lang.Thread Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getOwner", "()Ljava/lang/Thread;", "GetGetOwnerHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the thread that currently owns this lock, or
 <c>null</c> if not owned.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns the thread that currently owns this lock, or
 <c>null</c> if not owned. When this method is called by a
 thread that is not the owner, the return value reflects a
 best-effort approximation of current lock status. For example,
 the owner may be momentarily <c>null</c> even if there are
 threads trying to acquire the lock but have not yet done so.
 This method is designed to facilitate construction of
 subclasses that provide more extensive lock monitoring
 facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#getOwner()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt; QueuedThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueuedThreads", "()Ljava/util/Collection;", "GetGetQueuedThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
 acquire this lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns a collection containing threads that may be waiting to
 acquire this lock.  Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive monitoring facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#getQueuedThreads()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueueLength">
      <MemberSignature Language="C#" Value="public int QueueLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 QueueLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueueLength", "()I", "GetGetQueueLengthHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an estimate of the number of threads waiting to
 acquire this lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns an estimate of the number of threads waiting to
 acquire this lock.  The value is only an estimate because the number of
 threads may change dynamically while this method traverses
 internal data structures.  This method is designed for use in
 monitoring of the system state, not for synchronization
 control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#getQueueLength()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonVirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public virtual bool TryLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryLock() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("tryLock", "()Z", "GetTryLockHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acquires the lock only if it is not held by another thread at the time
 of invocation.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Acquires the lock only if it is not held by another thread at the time
 of invocation.

 </para><para tool="javadoc-to-mdoc">Acquires the lock if it is not held by another thread and
 returns immediately with the value <c>true</c>, setting the
 lock hold count to one. Even when this lock has been set to use a
 fair ordering policy, a call to <c>tryLock()</c><i>will</i>
 immediately acquire the lock if it is available, whether or not
 other threads are currently waiting for the lock.
 This "barging" behavior can be useful in certain
 circumstances, even though it breaks fairness. If you want to honor
 the fairness setting for this lock, then use
 <c><see cref="M:Java.Util.Concurrent.Locks.ReentrantLock.TryLock(System.Int64, Java.Util.Concurrent.TimeUnit)" /></c>
 which is almost equivalent (it also detects interruption).

 </para><para tool="javadoc-to-mdoc">If the current thread already holds this lock then the hold
 count is incremented by one and the method returns <c>true</c>.

 </para><para tool="javadoc-to-mdoc">If the lock is held by another thread then this method will return
 immediately with the value <c>false</c>.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#tryLock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="TryLock">
      <MemberSignature Language="C#" Value="public virtual bool TryLock (long timeout, Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryLock(int64 timeout, class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("tryLock", "(JLjava/util/concurrent/TimeUnit;)Z", "GetTryLock_JLjava_util_concurrent_TimeUnit_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="timeout">the time to wait for the lock</param>
        <param name="unit">the time unit of the timeout argument</param>
        <summary>Acquires the lock if it is not held by another thread within the given
 waiting time and the current thread has not been
 <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Acquires the lock if it is not held by another thread within the given
 waiting time and the current thread has not been
 <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.

 </para><para tool="javadoc-to-mdoc">Acquires the lock if it is not held by another thread and returns
 immediately with the value <c>true</c>, setting the lock hold count
 to one. If this lock has been set to use a fair ordering policy then
 an available lock <i>will not</i> be acquired if any other threads
 are waiting for the lock. This is in contrast to the <c><see cref="M:Java.Util.Concurrent.Locks.ReentrantLock.TryLock" /></c>
 method. If you want a timed <c>tryLock</c> that does permit barging on
 a fair lock then combine the timed and un-timed forms together:

  <sample external-id="98509297D5FE1D5A16F7747126DD92F4" /></para><para tool="javadoc-to-mdoc">If the current thread
 already holds this lock then the hold count is incremented by one and
 the method returns <c>true</c>.

 </para><para tool="javadoc-to-mdoc">If the lock is held by another thread then the
 current thread becomes disabled for thread scheduling
 purposes and lies dormant until one of three things happens:

 <list type="bullet"><item><term>The lock is acquired by the current thread; or

 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>
 the current thread; or

 </term></item><item><term>The specified waiting time elapses

 </term></item></list></para><para tool="javadoc-to-mdoc">If the lock is acquired then the value <c>true</c> is returned and
 the lock hold count is set to one.

 </para><para tool="javadoc-to-mdoc">If the current thread:

 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or

 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while
 acquiring the lock,

 </term></item></list>
 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared.

 </para><para tool="javadoc-to-mdoc">If the specified waiting time elapses then the value <c>false</c>
 is returned.  If the time is less than or equal to zero, the method
 will not wait at all.

 </para><para tool="javadoc-to-mdoc">In this implementation, as this method is an explicit
 interruption point, preference is given to responding to the
 interrupt over normal or reentrant acquisition of the lock, and
 over reporting the elapse of the waiting time.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#tryLock(long, java.util.concurrent.TimeUnit)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the time unit is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("unlock", "()V", "GetUnlockHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to release this lock.</summary>
        <remarks><para tool="javadoc-to-mdoc">Attempts to release this lock.

 </para><para tool="javadoc-to-mdoc">If the current thread is the holder of this lock then the hold
 count is decremented.  If the hold count is now zero then the lock
 is released.  If the current thread is not the holder of this
 lock then <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c> is thrown.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantLock.html#unlock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if the current thread does not
         hold this lock
</exception>
      </Docs>
    </Member>
  </Members>
</Type>
