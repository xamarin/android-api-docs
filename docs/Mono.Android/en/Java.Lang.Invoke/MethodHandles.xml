<Type Name="MethodHandles" FullName="Java.Lang.Invoke.MethodHandles">
  <TypeSignature Language="C#" Value="public class MethodHandles : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MethodHandles extends Java.Lang.Object" />
  <TypeSignature Language="DocId" Value="T:Java.Lang.Invoke.MethodHandles" />
  <TypeSignature Language="F#" Value="type MethodHandles = class&#xA;    inherit Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Android.Runtime.Register("java/lang/invoke/MethodHandles", ApiSince=26, DoNotGenerateAcw=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;Android.Runtime.Register("java/lang/invoke/MethodHandles", ApiSince=26, DoNotGenerateAcw=true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>This class consists exclusively of static methods that operate on or return
            method handles.</summary>
    <remarks>
      <para>This class consists exclusively of static methods that operate on or return
            method handles. They fall into several categories:
            &lt;ul&gt;
            &lt;li&gt;Lookup methods which help create method handles for methods and fields.
            &lt;li&gt;Combinator methods, which combine or transform pre-existing method handles into new ones.
            &lt;li&gt;Other factory methods to create method handles that emulate other common JVM operations or control flow patterns.
            &lt;/ul&gt;</para>
      <para />
      <para>Added in 1.7.</para>
      <para>
        <format type="text/html">
          <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles</code>.</a>
        </format>
      </para>
      <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodHandles (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.#ctor(System.IntPtr,Android.Runtime.JniHandleOwnership)" />
      <MemberSignature Language="F#" Value="new Java.Lang.Invoke.MethodHandles : nativeint * Android.Runtime.JniHandleOwnership -&gt; Java.Lang.Invoke.MethodHandles" Usage="new Java.Lang.Invoke.MethodHandles (javaReference, transfer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">To be added.</param>
        <param name="transfer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayConstructor">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ArrayConstructor (Java.Lang.Class? arrayClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ArrayConstructor(class Java.Lang.Class arrayClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ArrayConstructor(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member ArrayConstructor : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ArrayConstructor arrayClass" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("arrayConstructor", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("arrayConstructor", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="arrayClass">an array type</param>
        <summary>Produces a method handle constructing arrays of a desired type,
            as if by the <c>anewarray</c> bytecode.</summary>
        <returns>a method handle which can create arrays of the given type</returns>
        <remarks>
          <para>Produces a method handle constructing arrays of a desired type,
            as if by the <c>anewarray</c> bytecode.
            The return type of the method handle will be the array type.
            The type of its sole argument will be <c>int</c>, which specifies the size of the array.</para>
          <para>If the returned method handle is invoked with a negative
            array size, a <c>NegativeArraySizeException</c> will be thrown.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#arrayConstructor(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.arrayConstructor(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayElementGetter">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ArrayElementGetter (Java.Lang.Class? arrayClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ArrayElementGetter(class Java.Lang.Class arrayClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ArrayElementGetter(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member ArrayElementGetter : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ArrayElementGetter arrayClass" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("arrayElementGetter", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("arrayElementGetter", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="arrayClass">an array type</param>
        <summary>Produces a method handle giving read access to elements of an array.</summary>
        <returns>a method handle which can load values from the given array type</returns>
        <remarks>
          <para>Produces a method handle giving read access to elements of an array.
            The type of the method handle will have a return type of the array's
            element type.  Its first argument will be the array type,
            and the second will be <c>int</c>.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#arrayElementGetter(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.arrayElementGetter(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayElementSetter">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ArrayElementSetter (Java.Lang.Class? arrayClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ArrayElementSetter(class Java.Lang.Class arrayClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ArrayElementSetter(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member ArrayElementSetter : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ArrayElementSetter arrayClass" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("arrayElementSetter", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("arrayElementSetter", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="arrayClass">the class of an array</param>
        <summary>Produces a method handle giving write access to elements of an array.</summary>
        <returns>a method handle which can store values into the array type</returns>
        <remarks>
          <para>Produces a method handle giving write access to elements of an array.
            The type of the method handle will have a void return type.
            Its last argument will be the array's element type.
            The first and second arguments will be the array type and int.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#arrayElementSetter(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.arrayElementSetter(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayElementVarHandle">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.VarHandle? ArrayElementVarHandle (Java.Lang.Class? arrayClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.VarHandle ArrayElementVarHandle(class Java.Lang.Class arrayClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ArrayElementVarHandle(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member ArrayElementVarHandle : Java.Lang.Class -&gt; Java.Lang.Invoke.VarHandle" Usage="Java.Lang.Invoke.MethodHandles.ArrayElementVarHandle arrayClass" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("arrayElementVarHandle", "(Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("arrayElementVarHandle", "(Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.VarHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="arrayClass">the class of an array, of type <c>T[]</c></param>
        <summary>Produces a VarHandle giving access to elements of an array of type
            <c>arrayClass</c>.</summary>
        <returns>a VarHandle giving access to elements of an array</returns>
        <remarks>
          <para>Produces a VarHandle giving access to elements of an array of type
            <c>arrayClass</c>.  The VarHandle's variable type is the component type
            of <c>arrayClass</c> and the list of coordinate types is
            <c>(arrayClass, int)</c>, where the <c>int</c> coordinate type
            corresponds to an argument that is an index into an array.</para>
          <para>Certain access modes of the returned VarHandle are unsupported under
            the following conditions:
            &lt;ul&gt;
            &lt;li&gt;if the component type is anything other than <c>byte</c>,
                <c>short</c>, <c>char</c>, <c>int</c>, <c>long</c>,
                <c>float</c>, or <c>double</c> then numeric atomic update access
                modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>boolean</c>,
                <c>byte</c>, <c>short</c>, <c>char</c>, <c>int</c> or
                <c>long</c> then bitwise atomic update access modes are
                unsupported.
            &lt;/ul&gt;</para>
          <para>If the component type is <c>float</c> or <c>double</c> then numeric
            and atomic update access modes compare values using their bitwise
            representation (see <c>Float#floatToRawIntBits</c> and
            <c>Double#doubleToRawLongBits</c>, respectively).</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#arrayElementVarHandle(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.arrayElementVarHandle(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrayLength">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ArrayLength (Java.Lang.Class? arrayClass);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ArrayLength(class Java.Lang.Class arrayClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ArrayLength(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member ArrayLength : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ArrayLength arrayClass" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("arrayLength", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("arrayLength", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="arrayClass">an array type</param>
        <summary>Produces a method handle returning the length of an array,
            as if by the <c>arraylength</c> bytecode.</summary>
        <returns>a method handle which can retrieve the length of an array of the given array type</returns>
        <remarks>
          <para>Produces a method handle returning the length of an array,
            as if by the <c>arraylength</c> bytecode.
            The type of the method handle will have <c>int</c> as return type,
            and its sole argument will be the array type.</para>
          <para>If the returned method handle is invoked with a <c>null</c>
            array reference, a <c>NullPointerException</c> will be thrown.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#arrayLength(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.arrayLength(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ByteArrayViewVarHandle">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.VarHandle? ByteArrayViewVarHandle (Java.Lang.Class? viewArrayClass, Java.Nio.ByteOrder? byteOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.VarHandle ByteArrayViewVarHandle(class Java.Lang.Class viewArrayClass, class Java.Nio.ByteOrder byteOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ByteArrayViewVarHandle(Java.Lang.Class,Java.Nio.ByteOrder)" />
      <MemberSignature Language="F#" Value="static member ByteArrayViewVarHandle : Java.Lang.Class * Java.Nio.ByteOrder -&gt; Java.Lang.Invoke.VarHandle" Usage="Java.Lang.Invoke.MethodHandles.ByteArrayViewVarHandle (viewArrayClass, byteOrder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("byteArrayViewVarHandle", "(Ljava/lang/Class;Ljava/nio/ByteOrder;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("byteArrayViewVarHandle", "(Ljava/lang/Class;Ljava/nio/ByteOrder;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.VarHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewArrayClass" Type="Java.Lang.Class" />
        <Parameter Name="byteOrder" Type="Java.Nio.ByteOrder" />
      </Parameters>
      <Docs>
        <param name="viewArrayClass">the view array class, with a component type of
            type <c>T</c></param>
        <param name="byteOrder">the endianness of the view array elements, as
            stored in the underlying <c>byte</c> array</param>
        <summary>Produces a VarHandle giving access to elements of a <c>byte[]</c> array
            viewed as if it were a different primitive array type, such as
            <c>int[]</c> or <c>long[]</c>.</summary>
        <returns>a VarHandle giving access to elements of a <c>byte[]</c> array
            viewed as if elements corresponding to the components type of the view
            array class</returns>
        <remarks>
          <para>Produces a VarHandle giving access to elements of a <c>byte[]</c> array
            viewed as if it were a different primitive array type, such as
            <c>int[]</c> or <c>long[]</c>.
            The VarHandle's variable type is the component type of
            <c>viewArrayClass</c> and the list of coordinate types is
            <c>(byte[], int)</c>, where the <c>int</c> coordinate type
            corresponds to an argument that is an index into a <c>byte[]</c> array.
            The returned VarHandle accesses bytes at an index in a <c>byte[]</c>
            array, composing bytes to or from a value of the component type of
            <c>viewArrayClass</c> according to the given endianness.</para>
          <para>The supported component types (variables types) are <c>short</c>,
            <c>char</c>, <c>int</c>, <c>long</c>, <c>float</c> and
            <c>double</c>.</para>
          <para>Access of bytes at a given index will result in an
            <c>IndexOutOfBoundsException</c> if the index is less than <c>0</c>
            or greater than the <c>byte[]</c> array length minus the size (in bytes)
            of <c>T</c>.</para>
          <para>Access of bytes at an index may be aligned or misaligned for <c>T</c>,
            with respect to the underlying memory address, <c>A</c> say, associated
            with the array and index.
            If access is misaligned then access for anything other than the
            <c>get</c> and <c>set</c> access modes will result in an
            <c>IllegalStateException</c>.  In such cases atomic access is only
            guaranteed with respect to the largest power of two that divides the GCD
            of <c>A</c> and the size (in bytes) of <c>T</c>.
            If access is aligned then following access modes are supported and are
            guaranteed to support atomic access:
            &lt;ul&gt;
            &lt;li&gt;read write access modes for all <c>T</c>, with the exception of
                access modes <c>get</c> and <c>set</c> for <c>long</c> and
                <c>double</c> on 32-bit platforms.
            &lt;li&gt;atomic update access modes for <c>int</c>, <c>long</c>,
                <c>float</c> or <c>double</c>.
                (Future major platform releases of the JDK may support additional
                types for certain currently unsupported access modes.)
            &lt;li&gt;numeric atomic update access modes for <c>int</c> and <c>long</c>.
                (Future major platform releases of the JDK may support additional
                numeric types for certain currently unsupported access modes.)
            &lt;li&gt;bitwise atomic update access modes for <c>int</c> and <c>long</c>.
                (Future major platform releases of the JDK may support additional
                numeric types for certain currently unsupported access modes.)
            &lt;/ul&gt;</para>
          <para>Misaligned access, and therefore atomicity guarantees, may be determined
            for <c>byte[]</c> arrays without operating on a specific array.  Given
            an <c>index</c>, <c>T</c> and it's corresponding boxed type,
            <c>T_BOX</c>, misalignment may be determined as follows:</para>
          <code lang="text/java">{@code
            int sizeOfT = T_BOX.BYTES;  // size in bytes of T
            int misalignedAtZeroIndex = ByteBuffer.wrap(new byte[0]).
                alignmentOffset(0, sizeOfT);
            int misalignedAtIndex = (misalignedAtZeroIndex + index) % sizeOfT;
            boolean isMisaligned = misalignedAtIndex != 0;
            }</code>
          <para>If the variable type is <c>float</c> or <c>double</c> then atomic
            update access modes compare values using their bitwise representation
            (see <c>Float#floatToRawIntBits</c> and
            <c>Double#doubleToRawLongBits</c>, respectively).</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#byteArrayViewVarHandle(java.lang.Class%3C?%3E,%20java.nio.ByteOrder)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.byteArrayViewVarHandle(java.lang.Class&lt;?&gt;, java.nio.ByteOrder)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ByteBufferViewVarHandle">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.VarHandle? ByteBufferViewVarHandle (Java.Lang.Class? viewArrayClass, Java.Nio.ByteOrder? byteOrder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.VarHandle ByteBufferViewVarHandle(class Java.Lang.Class viewArrayClass, class Java.Nio.ByteOrder byteOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ByteBufferViewVarHandle(Java.Lang.Class,Java.Nio.ByteOrder)" />
      <MemberSignature Language="F#" Value="static member ByteBufferViewVarHandle : Java.Lang.Class * Java.Nio.ByteOrder -&gt; Java.Lang.Invoke.VarHandle" Usage="Java.Lang.Invoke.MethodHandles.ByteBufferViewVarHandle (viewArrayClass, byteOrder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("byteBufferViewVarHandle", "(Ljava/lang/Class;Ljava/nio/ByteOrder;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("byteBufferViewVarHandle", "(Ljava/lang/Class;Ljava/nio/ByteOrder;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.VarHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="viewArrayClass" Type="Java.Lang.Class" />
        <Parameter Name="byteOrder" Type="Java.Nio.ByteOrder" />
      </Parameters>
      <Docs>
        <param name="viewArrayClass">the view array class, with a component type of
            type <c>T</c></param>
        <param name="byteOrder">the endianness of the view array elements, as
            stored in the underlying <c>ByteBuffer</c> (Note this overrides the
            endianness of a <c>ByteBuffer</c>)</param>
        <summary>Produces a VarHandle giving access to elements of a <c>ByteBuffer</c>
            viewed as if it were an array of elements of a different primitive
            component type to that of <c>byte</c>, such as <c>int[]</c> or
            <c>long[]</c>.</summary>
        <returns>a VarHandle giving access to elements of a <c>ByteBuffer</c>
            viewed as if elements corresponding to the components type of the view
            array class</returns>
        <remarks>
          <para>Produces a VarHandle giving access to elements of a <c>ByteBuffer</c>
            viewed as if it were an array of elements of a different primitive
            component type to that of <c>byte</c>, such as <c>int[]</c> or
            <c>long[]</c>.
            The VarHandle's variable type is the component type of
            <c>viewArrayClass</c> and the list of coordinate types is
            <c>(ByteBuffer, int)</c>, where the <c>int</c> coordinate type
            corresponds to an argument that is an index into a <c>byte[]</c> array.
            The returned VarHandle accesses bytes at an index in a
            <c>ByteBuffer</c>, composing bytes to or from a value of the component
            type of <c>viewArrayClass</c> according to the given endianness.</para>
          <para>The supported component types (variables types) are <c>short</c>,
            <c>char</c>, <c>int</c>, <c>long</c>, <c>float</c> and
            <c>double</c>.</para>
          <para>Access will result in a <c>ReadOnlyBufferException</c> for anything
            other than the read access modes if the <c>ByteBuffer</c> is read-only.</para>
          <para>Access of bytes at a given index will result in an
            <c>IndexOutOfBoundsException</c> if the index is less than <c>0</c>
            or greater than the <c>ByteBuffer</c> limit minus the size (in bytes) of
            <c>T</c>.</para>
          <para>Access of bytes at an index may be aligned or misaligned for <c>T</c>,
            with respect to the underlying memory address, <c>A</c> say, associated
            with the <c>ByteBuffer</c> and index.
            If access is misaligned then access for anything other than the
            <c>get</c> and <c>set</c> access modes will result in an
            <c>IllegalStateException</c>.  In such cases atomic access is only
            guaranteed with respect to the largest power of two that divides the GCD
            of <c>A</c> and the size (in bytes) of <c>T</c>.
            If access is aligned then following access modes are supported and are
            guaranteed to support atomic access:
            &lt;ul&gt;
            &lt;li&gt;read write access modes for all <c>T</c>, with the exception of
                access modes <c>get</c> and <c>set</c> for <c>long</c> and
                <c>double</c> on 32-bit platforms.
            &lt;li&gt;atomic update access modes for <c>int</c>, <c>long</c>,
                <c>float</c> or <c>double</c>.
                (Future major platform releases of the JDK may support additional
                types for certain currently unsupported access modes.)
            &lt;li&gt;numeric atomic update access modes for <c>int</c> and <c>long</c>.
                (Future major platform releases of the JDK may support additional
                numeric types for certain currently unsupported access modes.)
            &lt;li&gt;bitwise atomic update access modes for <c>int</c> and <c>long</c>.
                (Future major platform releases of the JDK may support additional
                numeric types for certain currently unsupported access modes.)
            &lt;/ul&gt;</para>
          <para>Misaligned access, and therefore atomicity guarantees, may be determined
            for a <c>ByteBuffer</c>, <c>bb</c> (direct or otherwise), an
            <c>index</c>, <c>T</c> and it's corresponding boxed type,
            <c>T_BOX</c>, as follows:</para>
          <code lang="text/java">{@code
            int sizeOfT = T_BOX.BYTES;  // size in bytes of T
            ByteBuffer bb = ...
            int misalignedAtIndex = bb.alignmentOffset(index, sizeOfT);
            boolean isMisaligned = misalignedAtIndex != 0;
            }</code>
          <para>If the variable type is <c>float</c> or <c>double</c> then atomic
            update access modes compare values using their bitwise representation
            (see <c>Float#floatToRawIntBits</c> and
            <c>Double#doubleToRawLongBits</c>, respectively).</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#byteBufferViewVarHandle(java.lang.Class%3C?%3E,%20java.nio.ByteOrder)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.byteBufferViewVarHandle(java.lang.Class&lt;?&gt;, java.nio.ByteOrder)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatchException">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? CatchException (Java.Lang.Invoke.MethodHandle? target, Java.Lang.Class? exType, Java.Lang.Invoke.MethodHandle? handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle CatchException(class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Class exType, class Java.Lang.Invoke.MethodHandle handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.CatchException(Java.Lang.Invoke.MethodHandle,Java.Lang.Class,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member CatchException : Java.Lang.Invoke.MethodHandle * Java.Lang.Class * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.CatchException (target, exType, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("catchException", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/Class;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("catchException", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/Class;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="exType" Type="Java.Lang.Class" />
        <Parameter Name="handler" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">method handle to call</param>
        <param name="exType">the type of exception which the handler will catch</param>
        <param name="handler">method handle to call if a matching exception is thrown</param>
        <summary>Makes a method handle which adapts a target method handle,
            by running it inside an exception handler.</summary>
        <returns>method handle which incorporates the specified try/catch logic</returns>
        <remarks>
          <para>Makes a method handle which adapts a target method handle,
            by running it inside an exception handler.
            If the target returns normally, the adapter returns that value.
            If an exception matching the specified type is thrown, the fallback
            handle is called instead on the exception, plus the original arguments.</para>
          <para>The target and handler must have the same corresponding
            argument and return types, except that handler may omit trailing arguments
            (similarly to the predicate in <c>#guardWithTest guardWithTest</c>).
            Also, the handler must have an extra leading parameter of <c>exType</c> or a supertype.</para>
          <para>Here is pseudocode for the resulting adapter. In the code, <c>T</c>
            represents the return type of the <c>target</c> and <c>handler</c>,
            and correspondingly that of the resulting adapter; <c>A</c>/<c>a</c>,
            the types and values of arguments to the resulting handle consumed by
            <c>handler</c>; and <c>B</c>/<c>b</c>, those of arguments to the
            resulting handle discarded by <c>handler</c>.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            T target(A..., B...);
            T handler(ExType, A...);
            T adapter(A... a, B... b) {
              try {
                return target(a..., b...);
              } catch (ExType ex) {
                return handler(ex, a...);
              }
            }
            }</code>
          <para>&lt;/blockquote&gt;
            Note that the saved arguments (<c>a...</c> in the pseudocode) cannot
            be modified by execution of the target, and so are passed unchanged
            from the caller to the handler, if the handler is invoked.</para>
          <para>The target and handler must return the same type, even if the handler
            always throws.  (This might happen, for instance, because the handler
            is simulating a <c>finally</c> clause).
            To create such a throwing handler, compose the handler creation logic
            with <c>#throwException throwException</c>,
            in order to create a method handle of the correct return type.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#catchException(java.lang.invoke.MethodHandle,%20java.lang.Class%3C?%20extends%20java.lang.Throwable%3E,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.catchException(java.lang.invoke.MethodHandle, java.lang.Class&lt;? extends java.lang.Throwable&gt;, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? CollectArguments (Java.Lang.Invoke.MethodHandle? target, int pos, Java.Lang.Invoke.MethodHandle? filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle CollectArguments(class Java.Lang.Invoke.MethodHandle target, int32 pos, class Java.Lang.Invoke.MethodHandle filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.CollectArguments(Java.Lang.Invoke.MethodHandle,System.Int32,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member CollectArguments : Java.Lang.Invoke.MethodHandle * int * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.CollectArguments (target, pos, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("collectArguments", "(Ljava/lang/invoke/MethodHandle;ILjava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("collectArguments", "(Ljava/lang/invoke/MethodHandle;ILjava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pos" Type="System.Int32" />
        <Parameter Name="filter" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after filtering the subsequence of arguments</param>
        <param name="pos">the position of the first adapter argument to pass to the filter,
                       and/or the target argument which receives the result of the filter</param>
        <param name="filter">method handle to call on the subsequence of arguments</param>
        <summary>Adapts a target method handle by pre-processing
            a sub-sequence of its arguments with a filter (another method handle).</summary>
        <returns>method handle which incorporates the specified argument subsequence filtering logic</returns>
        <remarks>
          <para>Adapts a target method handle by pre-processing
            a sub-sequence of its arguments with a filter (another method handle).
            The pre-processed arguments are replaced by the result (if any) of the
            filter function.
            The target is then called on the modified (usually shortened) argument list.</para>
          <para>If the filter returns a value, the target must accept that value as
            its argument in position <c>pos</c>, preceded and/or followed by
            any arguments not passed to the filter.
            If the filter returns void, the target must accept all arguments
            not passed to the filter.
            No arguments are reordered, and a result returned from the filter
            replaces (in order) the whole subsequence of arguments originally
            passed to the adapter.</para>
          <para>The argument types (if any) of the filter
            replace zero or one argument types of the target, at position <c>pos</c>,
            in the resulting adapted method handle.
            The return type of the filter (if any) must be identical to the
            argument type of the target at position <c>pos</c>, and that target argument
            is supplied by the return value of the filter.</para>
          <para>In all cases, <c>pos</c> must be greater than or equal to zero, and
            <c>pos</c> must also be less than or equal to the target's arity.</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle deepToString = publicLookup()
              .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
            
            MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
            assertEquals("[strange]", (String) ts1.invokeExact("strange"));
            
            MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
            assertEquals("[up, down]", (String) ts2.invokeExact("up", "down"));
            
            MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
            MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
            assertEquals("[top, [up, down], strange]",
                         (String) ts3_ts2.invokeExact("top", "up", "down", "strange"));
            
            MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
            assertEquals("[top, [up, down], [strange]]",
                         (String) ts3_ts2_ts1.invokeExact("top", "up", "down", "strange"));
            
            MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
            assertEquals("[top, [[up, down, strange], charm], bottom]",
                         (String) ts3_ts2_ts3.invokeExact("top", "up", "down", "strange", "charm", "bottom"));
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Here is pseudocode for the resulting adapter:
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            T target(A...,V,C...);
            V filter(B...);
            T adapter(A... a,B... b,C... c) {
              V v = filter(b...);
              return target(a...,v,c...);
            }
            // and if the filter has no arguments:
            T target2(A...,V,C...);
            V filter2();
            T adapter2(A... a,C... c) {
              V v = filter2();
              return target2(a...,v,c...);
            }
            // and if the filter has a void return:
            T target3(A...,C...);
            void filter3(B...);
            void adapter3(A... a,B... b,C... c) {
              filter3(b...);
              return target3(a...,c...);
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>A collection adapter <c>collectArguments(mh, 0, coll)</c> is equivalent to
            one which first "folds" the affected arguments, and then drops them, in separate
            steps as follows:
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
            mh = MethodHandles.foldArguments(mh, coll); //step 1
            }</code>
          <para>&lt;/blockquote&gt;
            If the target method handle consumes no arguments besides than the result
            (if any) of the filter <c>coll</c>, then <c>collectArguments(mh, 0, coll)</c>
            is equivalent to <c>filterReturnValue(coll, mh)</c>.
            If the filter method handle <c>coll</c> consumes one argument and produces
            a non-void result, then <c>collectArguments(mh, N, coll)</c>
            is equivalent to <c>filterArguments(mh, N, coll)</c>.
            Other equivalences are possible but would require argument permutation.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#collectArguments(java.lang.invoke.MethodHandle,%20int,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.collectArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constant">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? Constant (Java.Lang.Class? type, Java.Lang.Object? value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle Constant(class Java.Lang.Class type, class Java.Lang.Object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Constant(Java.Lang.Class,Java.Lang.Object)" />
      <MemberSignature Language="F#" Value="static member Constant : Java.Lang.Class * Java.Lang.Object -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.Constant (type, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("constant", "(Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("constant", "(Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Class" />
        <Parameter Name="value" Type="Java.Lang.Object" />
      </Parameters>
      <Docs>
        <param name="type">the return type of the desired method handle</param>
        <param name="value">the value to return</param>
        <summary>Produces a method handle of the requested return type which returns the given
            constant value every time it is invoked.</summary>
        <returns>a method handle of the given return type and no arguments, which always returns the given value</returns>
        <remarks>
          <para>Produces a method handle of the requested return type which returns the given
            constant value every time it is invoked.</para>
          <para>Before the method handle is returned, the passed-in value is converted to the requested type.
            If the requested type is primitive, widening primitive conversions are attempted,
            else reference conversions are attempted.</para>
          <para>The returned method handle is equivalent to <c>identity(type).bindTo(value)</c>.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#constant(java.lang.Class%3C?%3E,%20java.lang.Object)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.constant(java.lang.Class&lt;?&gt;, java.lang.Object)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CountedLoop">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? CountedLoop (Java.Lang.Invoke.MethodHandle? iterations, Java.Lang.Invoke.MethodHandle? init, Java.Lang.Invoke.MethodHandle? body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle CountedLoop(class Java.Lang.Invoke.MethodHandle iterations, class Java.Lang.Invoke.MethodHandle init, class Java.Lang.Invoke.MethodHandle body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.CountedLoop(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member CountedLoop : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.CountedLoop (iterations, init, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("countedLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("countedLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="init" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="body" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="iterations">a non-<c>null</c> handle to return the number of iterations this loop should run. The handle's
                              result type must be <c>int</c>. See above for other constraints.</param>
        <param name="init">optional initializer, providing the initial value of the loop variable.
                        May be <c>null</c>, implying a default initial value.  See above for other constraints.</param>
        <param name="body">body of the loop, which may not be <c>null</c>.
                        It controls the loop parameters and result type in the standard case (see above for details).
                        It must accept its own return type (if non-void) plus an <c>int</c> parameter (for the counter),
                        and may accept any number of additional types.
                        See above for other constraints.</param>
        <summary>Constructs a loop that runs a given number of iterations.</summary>
        <returns>a method handle representing the loop.</returns>
        <remarks>
          <para>Constructs a loop that runs a given number of iterations.
            This is a convenience wrapper for the #loop(MethodHandle[][]) generic loop combinator.</para>
          <para>The number of iterations is determined by the <c>iterations</c> handle evaluation result.
            The loop counter <c>i</c> is an extra loop iteration variable of type <c>int</c>.
            It will be initialized to 0 and incremented by 1 in each iteration.</para>
          <para>If the <c>body</c> handle returns a non-<c>void</c> type <c>V</c>, a leading loop iteration variable
            of that type is also present.  This variable is initialized using the optional <c>init</c> handle,
            or to the #empty default value of type <c>V</c> if that handle is <c>null</c>.</para>
          <para>In each iteration, the iteration variables are passed to an invocation of the <c>body</c> handle.
            A non-<c>void</c> value returned from the body (of type <c>V</c>) updates the leading
            iteration variable.
            The result of the loop handle execution will be the final <c>V</c> value of that variable
            (or <c>void</c> if there is no <c>V</c> variable).</para>
          <para>The following rules hold for the argument handles:&lt;ul&gt;
            &lt;li&gt;The <c>iterations</c> handle must not be <c>null</c>, and must return
            the type <c>int</c>, referred to here as <c>I</c> in parameter type lists.
            &lt;li&gt;The <c>body</c> handle must not be <c>null</c>; its type must be of the form
            <c>(V I A...)V</c>, where <c>V</c> is non-<c>void</c>, or else <c>(I A...)void</c>.
            (In the <c>void</c> case, we assign the type <c>void</c> to the name <c>V</c>,
            and we will write <c>(V I A...)V</c> with the understanding that a <c>void</c> type <c>V</c>
            is quietly dropped from the parameter list, leaving <c>(I A...)V</c>.)
            &lt;li&gt;The parameter list <c>(V I A...)</c> of the body contributes to a list
            of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
            It will constrain the parameter lists of the other loop parts.
            &lt;li&gt;As a special case, if the body contributes only <c>V</c> and <c>I</c> types,
            with no additional <c>A</c> types, then the internal parameter list is extended by
            the argument types <c>A...</c> of the <c>iterations</c> handle.
            &lt;li&gt;If the iteration variable types <c>(V I)</c> are dropped from the internal parameter list, the resulting shorter
            list <c>(A...)</c> is called the &lt;em&gt;external parameter list&lt;/em&gt;.
            &lt;li&gt;The body return type <c>V</c>, if non-<c>void</c>, determines the type of an
            additional state variable of the loop.
            The body must both accept a leading parameter and return a value of this type <c>V</c>.
            &lt;li&gt;If <c>init</c> is non-<c>null</c>, it must have return type <c>V</c>.
            Its parameter list (of some form &lt;c&gt;(A*)&lt;/c&gt;) must be
            effectively identical
            to the external parameter list <c>(A...)</c>.
            &lt;li&gt;If <c>init</c> is <c>null</c>, the loop variable will be initialized to its
            #empty default value.
            &lt;li&gt;The parameter list of <c>iterations</c> (of some form <c>(A*)</c>) must be
            effectively identical to the external parameter list <c>(A...)</c>.
            &lt;/ul&gt;</para>
          <para>The resulting loop handle's result type and parameter signature are determined as follows:&lt;ul&gt;
            &lt;li&gt;The loop handle's result type is the result type <c>V</c> of the body.
            &lt;li&gt;The loop handle's parameter types are the types <c>(A...)</c>,
            from the external parameter list.
            &lt;/ul&gt;</para>
          <para>Here is pseudocode for the resulting loop handle. In the code, <c>V</c>/<c>v</c> represent the type / value of
            the second loop variable as well as the result type of the loop; and <c>A...</c>/<c>a...</c> represent
            arguments passed to the loop.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            int iterations(A...);
            V init(A...);
            V body(V, int, A...);
            V countedLoop(A... a...) {
              int end = iterations(a...);
              V v = init(a...);
              for (int i = 0; i &lt; end; ++i) {
                v = body(v, i, a...);
              }
              return v;
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#countedLoop(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.countedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CountedLoop">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? CountedLoop (Java.Lang.Invoke.MethodHandle? start, Java.Lang.Invoke.MethodHandle? end, Java.Lang.Invoke.MethodHandle? init, Java.Lang.Invoke.MethodHandle? body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle CountedLoop(class Java.Lang.Invoke.MethodHandle start, class Java.Lang.Invoke.MethodHandle end, class Java.Lang.Invoke.MethodHandle init, class Java.Lang.Invoke.MethodHandle body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.CountedLoop(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member CountedLoop : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.CountedLoop (start, end, init, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("countedLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("countedLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="end" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="init" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="body" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="start">a non-<c>null</c> handle to return the start value of the loop counter, which must be <c>int</c>.
                         See above for other constraints.</param>
        <param name="end">a non-<c>null</c> handle to return the end value of the loop counter (the loop will run to
                       <c>end-1</c>). The result type must be <c>int</c>. See above for other constraints.</param>
        <param name="init">optional initializer, providing the initial value of the loop variable.
                        May be <c>null</c>, implying a default initial value.  See above for other constraints.</param>
        <param name="body">body of the loop, which may not be <c>null</c>.
                        It controls the loop parameters and result type in the standard case (see above for details).
                        It must accept its own return type (if non-void) plus an <c>int</c> parameter (for the counter),
                        and may accept any number of additional types.
                        See above for other constraints.</param>
        <summary>Constructs a loop that counts over a range of numbers.</summary>
        <returns>a method handle representing the loop.</returns>
        <remarks>
          <para>Constructs a loop that counts over a range of numbers.
            This is a convenience wrapper for the #loop(MethodHandle[][]) generic loop combinator.</para>
          <para>The loop counter <c>i</c> is a loop iteration variable of type <c>int</c>.
            The <c>start</c> and <c>end</c> handles determine the start (inclusive) and end (exclusive)
            values of the loop counter.
            The loop counter will be initialized to the <c>int</c> value returned from the evaluation of the
            <c>start</c> handle and run to the value returned from <c>end</c> (exclusively) with a step width of 1.</para>
          <para>If the <c>body</c> handle returns a non-<c>void</c> type <c>V</c>, a leading loop iteration variable
            of that type is also present.  This variable is initialized using the optional <c>init</c> handle,
            or to the #empty default value of type <c>V</c> if that handle is <c>null</c>.</para>
          <para>In each iteration, the iteration variables are passed to an invocation of the <c>body</c> handle.
            A non-<c>void</c> value returned from the body (of type <c>V</c>) updates the leading
            iteration variable.
            The result of the loop handle execution will be the final <c>V</c> value of that variable
            (or <c>void</c> if there is no <c>V</c> variable).</para>
          <para>The following rules hold for the argument handles:&lt;ul&gt;
            &lt;li&gt;The <c>start</c> and <c>end</c> handles must not be <c>null</c>, and must both return
            the common type <c>int</c>, referred to here as <c>I</c> in parameter type lists.
            &lt;li&gt;The <c>body</c> handle must not be <c>null</c>; its type must be of the form
            <c>(V I A...)V</c>, where <c>V</c> is non-<c>void</c>, or else <c>(I A...)void</c>.
            (In the <c>void</c> case, we assign the type <c>void</c> to the name <c>V</c>,
            and we will write <c>(V I A...)V</c> with the understanding that a <c>void</c> type <c>V</c>
            is quietly dropped from the parameter list, leaving <c>(I A...)V</c>.)
            &lt;li&gt;The parameter list <c>(V I A...)</c> of the body contributes to a list
            of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
            It will constrain the parameter lists of the other loop parts.
            &lt;li&gt;As a special case, if the body contributes only <c>V</c> and <c>I</c> types,
            with no additional <c>A</c> types, then the internal parameter list is extended by
            the argument types <c>A...</c> of the <c>end</c> handle.
            &lt;li&gt;If the iteration variable types <c>(V I)</c> are dropped from the internal parameter list, the resulting shorter
            list <c>(A...)</c> is called the &lt;em&gt;external parameter list&lt;/em&gt;.
            &lt;li&gt;The body return type <c>V</c>, if non-<c>void</c>, determines the type of an
            additional state variable of the loop.
            The body must both accept a leading parameter and return a value of this type <c>V</c>.
            &lt;li&gt;If <c>init</c> is non-<c>null</c>, it must have return type <c>V</c>.
            Its parameter list (of some form &lt;c&gt;(A*)&lt;/c&gt;) must be
            effectively identical
            to the external parameter list <c>(A...)</c>.
            &lt;li&gt;If <c>init</c> is <c>null</c>, the loop variable will be initialized to its
            #empty default value.
            &lt;li&gt;The parameter list of <c>start</c> (of some form <c>(A*)</c>) must be
            effectively identical to the external parameter list <c>(A...)</c>.
            &lt;li&gt;Likewise, the parameter list of <c>end</c> must be effectively identical
            to the external parameter list.
            &lt;/ul&gt;</para>
          <para>The resulting loop handle's result type and parameter signature are determined as follows:&lt;ul&gt;
            &lt;li&gt;The loop handle's result type is the result type <c>V</c> of the body.
            &lt;li&gt;The loop handle's parameter types are the types <c>(A...)</c>,
            from the external parameter list.
            &lt;/ul&gt;</para>
          <para>Here is pseudocode for the resulting loop handle. In the code, <c>V</c>/<c>v</c> represent the type / value of
            the second loop variable as well as the result type of the loop; and <c>A...</c>/<c>a...</c> represent
            arguments passed to the loop.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            int start(A...);
            int end(A...);
            V init(A...);
            V body(V, int, A...);
            V countedLoop(A... a...) {
              int e = end(a...);
              int s = start(a...);
              V v = init(a...);
              for (int i = s; i &lt; e; ++i) {
                v = body(v, i, a...);
              }
              return v;
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#countedLoop(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.countedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWhileLoop">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? DoWhileLoop (Java.Lang.Invoke.MethodHandle? init, Java.Lang.Invoke.MethodHandle? body, Java.Lang.Invoke.MethodHandle? pred);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle DoWhileLoop(class Java.Lang.Invoke.MethodHandle init, class Java.Lang.Invoke.MethodHandle body, class Java.Lang.Invoke.MethodHandle pred) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.DoWhileLoop(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member DoWhileLoop : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.DoWhileLoop (init, body, pred)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("doWhileLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("doWhileLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="init" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="body" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pred" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="init">optional initializer, providing the initial value of the loop variable.
                        May be <c>null</c>, implying a default initial value.  See above for other constraints.</param>
        <param name="body">body of the loop, which may not be <c>null</c>. It controls the loop parameters and result type.
                        See above for other constraints.</param>
        <param name="pred">condition for the loop, which may not be <c>null</c>. Its result type must be <c>boolean</c>. See
                        above for other constraints.</param>
        <summary>Constructs a <c>do-while</c> loop from an initializer, a body, and a predicate.</summary>
        <returns>a method handle implementing the <c>while</c> loop as described by the arguments.</returns>
        <remarks>
          <para>Constructs a <c>do-while</c> loop from an initializer, a body, and a predicate.
            This is a convenience wrapper for the #loop(MethodHandle[][]) generic loop combinator.</para>
          <para>The <c>pred</c> handle describes the loop condition; and <c>body</c>, its body. The loop resulting from this
            method will, in each iteration, first execute its body and then evaluate the predicate.
            The loop will terminate once the predicate evaluates to <c>false</c> after an execution of the body.</para>
          <para>The <c>init</c> handle describes the initial value of an additional optional loop-local variable.
            In each iteration, this loop-local variable, if present, will be passed to the <c>body</c>
            and updated with the value returned from its invocation. The result of loop execution will be
            the final value of the additional loop-local variable (if present).</para>
          <para>The following rules hold for these argument handles:&lt;ul&gt;
            &lt;li&gt;The <c>body</c> handle must not be <c>null</c>; its type must be of the form
            <c>(V A...)V</c>, where <c>V</c> is non-<c>void</c>, or else <c>(A...)void</c>.
            (In the <c>void</c> case, we assign the type <c>void</c> to the name <c>V</c>,
            and we will write <c>(V A...)V</c> with the understanding that a <c>void</c> type <c>V</c>
            is quietly dropped from the parameter list, leaving <c>(A...)V</c>.)
            &lt;li&gt;The parameter list <c>(V A...)</c> of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
            It will constrain the parameter lists of the other loop parts.
            &lt;li&gt;If the iteration variable type <c>V</c> is dropped from the internal parameter list, the resulting shorter
            list <c>(A...)</c> is called the &lt;em&gt;external parameter list&lt;/em&gt;.
            &lt;li&gt;The body return type <c>V</c>, if non-<c>void</c>, determines the type of an
            additional state variable of the loop.
            The body must both accept and return a value of this type <c>V</c>.
            &lt;li&gt;If <c>init</c> is non-<c>null</c>, it must have return type <c>V</c>.
            Its parameter list (of some form &lt;c&gt;(A*)&lt;/c&gt;) must be
            effectively identical
            to the external parameter list <c>(A...)</c>.
            &lt;li&gt;If <c>init</c> is <c>null</c>, the loop variable will be initialized to its
            #empty default value.
            &lt;li&gt;The <c>pred</c> handle must not be <c>null</c>.  It must have <c>boolean</c> as its return type.
            Its parameter list (either empty or of the form <c>(V A*)</c>) must be
            effectively identical to the internal parameter list.
            &lt;/ul&gt;</para>
          <para>The resulting loop handle's result type and parameter signature are determined as follows:&lt;ul&gt;
            &lt;li&gt;The loop handle's result type is the result type <c>V</c> of the body.
            &lt;li&gt;The loop handle's parameter types are the types <c>(A...)</c>,
            from the external parameter list.
            &lt;/ul&gt;</para>
          <para>Here is pseudocode for the resulting loop handle. In the code, <c>V</c>/<c>v</c> represent the type / value of
            the sole loop variable as well as the result type of the loop; and <c>A</c>/<c>a</c>, that of the argument
            passed to the loop.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            V init(A...);
            boolean pred(V, A...);
            V body(V, A...);
            V doWhileLoop(A... a...) {
              V v = init(a...);
              do {
                v = body(v, a...);
              } while (pred(v, a...));
              return v;
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#doWhileLoop(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.doWhileLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? DropArguments (Java.Lang.Invoke.MethodHandle? target, int pos, params Java.Lang.Class[]? valueTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle DropArguments(class Java.Lang.Invoke.MethodHandle target, int32 pos, class Java.Lang.Class[] valueTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.DropArguments(Java.Lang.Invoke.MethodHandle,System.Int32,Java.Lang.Class[])" />
      <MemberSignature Language="F#" Value="static member DropArguments : Java.Lang.Invoke.MethodHandle * int * Java.Lang.Class[] -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.DropArguments (target, pos, valueTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("dropArguments", "(Ljava/lang/invoke/MethodHandle;I[Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("dropArguments", "(Ljava/lang/invoke/MethodHandle;I[Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pos" Type="System.Int32" />
        <Parameter Name="valueTypes" Type="Java.Lang.Class[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after the arguments are dropped</param>
        <param name="pos">position of first argument to drop (zero for the leftmost)</param>
        <param name="valueTypes">the type(s) of the argument(s) to drop</param>
        <summary>Produces a method handle which will discard some dummy arguments
            before calling some other specified <i>target</i> method handle.</summary>
        <returns>a method handle which drops arguments of the given types,
                    before calling the original method handle</returns>
        <remarks>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#dropArguments(java.lang.invoke.MethodHandle,%20int,%20java.lang.Class)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle, int, java.lang.Class)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? DropArguments (Java.Lang.Invoke.MethodHandle? target, int pos, System.Collections.Generic.IList&lt;Java.Lang.Class&gt;? valueTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle DropArguments(class Java.Lang.Invoke.MethodHandle target, int32 pos, class System.Collections.Generic.IList`1&lt;class Java.Lang.Class&gt; valueTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.DropArguments(Java.Lang.Invoke.MethodHandle,System.Int32,System.Collections.Generic.IList{Java.Lang.Class})" />
      <MemberSignature Language="F#" Value="static member DropArguments : Java.Lang.Invoke.MethodHandle * int * System.Collections.Generic.IList&lt;Java.Lang.Class&gt; -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.DropArguments (target, pos, valueTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("dropArguments", "(Ljava/lang/invoke/MethodHandle;ILjava/util/List;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("dropArguments", "(Ljava/lang/invoke/MethodHandle;ILjava/util/List;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pos" Type="System.Int32" />
        <Parameter Name="valueTypes" Type="System.Collections.Generic.IList&lt;Java.Lang.Class&gt;" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after the arguments are dropped</param>
        <param name="valueTypes">the type(s) of the argument(s) to drop</param>
        <param name="pos">position of first argument to drop (zero for the leftmost)</param>
        <summary>Produces a method handle which will discard some placeholder arguments
            before calling some other specified <i>target</i> method handle.</summary>
        <returns>a method handle which drops arguments of the given types,
                    before calling the original method handle</returns>
        <remarks>
          <para>Produces a method handle which will discard some placeholder arguments
            before calling some other specified <i>target</i> method handle.
            The type of the new method handle will be the same as the target's type,
            except it will also include the placeholder argument types,
            at some given position.</para>
          <para>The <c>pos</c> argument may range between zero and <i>N</i>,
            where <i>N</i> is the arity of the target.
            If <c>pos</c> is zero, the placeholder arguments will precede
            the target's real arguments; if <c>pos</c> is <i>N</i>
            they will come after.</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle cat = lookup().findVirtual(String.class,
              "concat", methodType(String.class, String.class));
            assertEquals("xy", (String) cat.invokeExact("x", "y"));
            MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
            MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
            assertEquals(bigType, d0.type());
            assertEquals("yz", (String) d0.invokeExact(123, "x", "y", "z"));
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>This method is also equivalent to the following code:
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@link #dropArguments(MethodHandle,int,Class...) dropArguments}{@code (target, pos, valueTypes.toArray(new Class[0]))}
            </code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#dropArguments(java.lang.invoke.MethodHandle,%20int,%20java.util.List%3Cjava.lang.Class%3C?%3E%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.dropArguments(java.lang.invoke.MethodHandle, int, java.util.List&lt;java.lang.Class&lt;?&gt;&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropArgumentsToMatch">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? DropArgumentsToMatch (Java.Lang.Invoke.MethodHandle? target, int skip, System.Collections.Generic.IList&lt;Java.Lang.Class&gt;? newTypes, int pos);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle DropArgumentsToMatch(class Java.Lang.Invoke.MethodHandle target, int32 skip, class System.Collections.Generic.IList`1&lt;class Java.Lang.Class&gt; newTypes, int32 pos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.DropArgumentsToMatch(Java.Lang.Invoke.MethodHandle,System.Int32,System.Collections.Generic.IList{Java.Lang.Class},System.Int32)" />
      <MemberSignature Language="F#" Value="static member DropArgumentsToMatch : Java.Lang.Invoke.MethodHandle * int * System.Collections.Generic.IList&lt;Java.Lang.Class&gt; * int -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.DropArgumentsToMatch (target, skip, newTypes, pos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("dropArgumentsToMatch", "(Ljava/lang/invoke/MethodHandle;ILjava/util/List;I)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("dropArgumentsToMatch", "(Ljava/lang/invoke/MethodHandle;ILjava/util/List;I)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="skip" Type="System.Int32" />
        <Parameter Name="newTypes" Type="System.Collections.Generic.IList&lt;Java.Lang.Class&gt;" />
        <Parameter Name="pos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to adapt</param>
        <param name="skip">number of targets parameters to disregard (they will be unchanged)</param>
        <param name="newTypes">the list of types to match <c>target</c>'s parameter type list to</param>
        <param name="pos">place in <c>newTypes</c> where the non-skipped target parameters must occur</param>
        <summary>Adapts a target method handle to match the given parameter type list.</summary>
        <returns>a possibly adapted method handle</returns>
        <remarks>
          <para>Adapts a target method handle to match the given parameter type list. If necessary, adds placeholder arguments. Some
            leading parameters can be skipped before matching begins. The remaining types in the <c>target</c>'s parameter
            type list must be a sub-list of the <c>newTypes</c> type list at the starting position <c>pos</c>. The
            resulting handle will have the target handle's parameter type list, with any non-matching parameter types (before
            or after the matching sub-list) inserted in corresponding positions of the target's original parameters, as if by
            <c>#dropArguments(MethodHandle, int, Class[])</c>.</para>
          <para>The resulting handle will have the same return type as the target handle.</para>
          <para>In more formal terms, assume these two type lists:&lt;ul&gt;
            &lt;li&gt;The target handle has the parameter type list <c>S..., M...</c>, with as many types in <c>S</c> as
            indicated by <c>skip</c>. The <c>M</c> types are those that are supposed to match part of the given type list,
            <c>newTypes</c>.
            &lt;li&gt;The <c>newTypes</c> list contains types <c>P..., M..., A...</c>, with as many types in <c>P</c> as
            indicated by <c>pos</c>. The <c>M</c> types are precisely those that the <c>M</c> types in the target handle's
            parameter type list are supposed to match. The types in <c>A</c> are additional types found after the matching
            sub-list.
            &lt;/ul&gt;
            Given these assumptions, the result of an invocation of <c>dropArgumentsToMatch</c> will have the parameter type
            list <c>S..., P..., M..., A...</c>, with the <c>P</c> and <c>A</c> types inserted as if by
            <c>#dropArguments(MethodHandle, int, Class[])</c>.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#dropArgumentsToMatch(java.lang.invoke.MethodHandle,%20int,%20java.util.List%3Cjava.lang.Class%3C?%3E%3E,%20int)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.dropArgumentsToMatch(java.lang.invoke.MethodHandle, int, java.util.List&lt;java.lang.Class&lt;?&gt;&gt;, int)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DropReturn">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? DropReturn (Java.Lang.Invoke.MethodHandle? target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle DropReturn(class Java.Lang.Invoke.MethodHandle target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.DropReturn(Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member DropReturn : Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.DropReturn target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("dropReturn", "(Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=34)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("dropReturn", "(Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=34)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android34.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android34.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to adapt</param>
        <summary>Drop the return value of the target handle (if any).</summary>
        <returns>a possibly adapted method handle</returns>
        <remarks>
          <para>Drop the return value of the target handle (if any).
            The returned method handle will have a <c>void</c> return type.</para>
          <para>Added in 16.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#dropReturn(java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.dropReturn(java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? Empty (Java.Lang.Invoke.MethodType? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle Empty(class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Empty(Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="static member Empty : Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.Empty type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("empty", "(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("empty", "(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="type">the type of the desired method handle</param>
        <summary>Produces a method handle of the requested type which ignores any arguments, does nothing,
            and returns a suitable default depending on the return type.</summary>
        <returns>a constant method handle of the given type, which returns a default value of the given return type</returns>
        <remarks>
          <para>Produces a method handle of the requested type which ignores any arguments, does nothing,
            and returns a suitable default depending on the return type.
            That is, it returns a zero primitive value, a <c>null</c>, or <c>void</c>.</para>
          <para>The returned method handle is equivalent to
            <c>dropArguments(zero(type.returnType()), 0, type.parameterList())</c>.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#empty(java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.empty(java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactInvoker">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ExactInvoker (Java.Lang.Invoke.MethodType? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ExactInvoker(class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ExactInvoker(Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="static member ExactInvoker : Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ExactInvoker type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("exactInvoker", "(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("exactInvoker", "(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="type">the desired target type</param>
        <summary>Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
            invoke any method handle of the given type, as if by <c>MethodHandle#invokeExact invokeExact</c>.</summary>
        <returns>a method handle suitable for invoking any method handle of the given type</returns>
        <remarks>
          <para>Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
            invoke any method handle of the given type, as if by <c>MethodHandle#invokeExact invokeExact</c>.
            The resulting invoker will have a type which is
            exactly equal to the desired type, except that it will accept
            an additional leading argument of type <c>MethodHandle</c>.</para>
          <para>This method is equivalent to the following code (though it may be more efficient):
            <c>publicLookup().findVirtual(MethodHandle.class, "invokeExact", type)</c>&lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;Discussion:&lt;/em&gt;
            Invoker method handles can be useful when working with variable method handles
            of unknown types.
            For example, to emulate an <c>invokeExact</c> call to a variable method
            handle <c>M</c>, extract its type <c>T</c>,
            look up the invoker method <c>X</c> for <c>T</c>,
            and call the invoker method, as <c>X.invoke(T, A...)</c>.
            (It would not work to call <c>X.invokeExact</c>, since the type <c>T</c>
            is unknown.)
            If spreading, collecting, or other argument transformations are required,
            they can be applied once to the invoker <c>X</c> and reused on many <c>M</c>
            method handle values, as long as they are compatible with the type of <c>X</c>.
            &lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
            An attempt to call java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke
            on the declared <c>invokeExact</c> or <c>invoke</c> method will raise an
            <c>java.lang.UnsupportedOperationException UnsupportedOperationException</c>.)&lt;/em&gt;</para>
          <para>This method throws no reflective or security exceptions.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#exactInvoker(java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.exactInvoker(java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExplicitCastArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ExplicitCastArguments (Java.Lang.Invoke.MethodHandle? target, Java.Lang.Invoke.MethodType? newType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ExplicitCastArguments(class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Invoke.MethodType newType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ExplicitCastArguments(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="static member ExplicitCastArguments : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ExplicitCastArguments (target, newType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("explicitCastArguments", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("explicitCastArguments", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="newType" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after arguments are retyped</param>
        <param name="newType">the expected type of the new method handle</param>
        <summary>Produces a method handle which adapts the type of the
            given method handle to a new type by pairwise argument and return type conversion.</summary>
        <returns>a method handle which delegates to the target after performing
                      any necessary argument conversions, and arranges for any
                      necessary return value conversions</returns>
        <remarks>
          <para>Produces a method handle which adapts the type of the
            given method handle to a new type by pairwise argument and return type conversion.
            The original type and new type must have the same number of arguments.
            The resulting method handle is guaranteed to report a type
            which is equal to the desired new type.</para>
          <para>If the original type and new type are equal, returns target.</para>
          <para>The same conversions are allowed as for <c>MethodHandle#asType MethodHandle.asType</c>,
            and some additional conversions are also applied if those conversions fail.
            Given types &lt;em&gt;T0&lt;/em&gt;, &lt;em&gt;T1&lt;/em&gt;, one of the following conversions is applied
            if possible, before or instead of any conversions done by <c>asType</c>:
            &lt;ul&gt;
            &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are references, and &lt;em&gt;T1&lt;/em&gt; is an interface type,
                then the value of type &lt;em&gt;T0&lt;/em&gt; is passed as a &lt;em&gt;T1&lt;/em&gt; without a cast.
                (This treatment of interfaces follows the usage of the bytecode verifier.)
            &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is boolean and &lt;em&gt;T1&lt;/em&gt; is another primitive,
                the boolean is converted to a byte value, 1 for true, 0 for false.
                (This treatment follows the usage of the bytecode verifier.)
            &lt;li&gt;If &lt;em&gt;T1&lt;/em&gt; is boolean and &lt;em&gt;T0&lt;/em&gt; is another primitive,
                &lt;em&gt;T0&lt;/em&gt; is converted to byte via Java casting conversion (JLS 5.5),
                and the low order bit of the result is tested, as if by <c>(x &amp; 1) != 0</c>.
            &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; and &lt;em&gt;T1&lt;/em&gt; are primitives other than boolean,
                then a Java casting conversion (JLS 5.5) is applied.
                (Specifically, &lt;em&gt;T0&lt;/em&gt; will convert to &lt;em&gt;T1&lt;/em&gt; by
                widening and/or narrowing.)
            &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive, an unboxing
                conversion will be applied at runtime, possibly followed
                by a Java casting conversion (JLS 5.5) on the primitive value,
                possibly followed by a conversion from byte to boolean by testing
                the low-order bit.
            &lt;li&gt;If &lt;em&gt;T0&lt;/em&gt; is a reference and &lt;em&gt;T1&lt;/em&gt; a primitive,
                and if the reference is null at runtime, a zero value is introduced.
            &lt;/ul&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#explicitCastArguments(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? FilterArguments (Java.Lang.Invoke.MethodHandle? target, int pos, params Java.Lang.Invoke.MethodHandle[]? filters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle FilterArguments(class Java.Lang.Invoke.MethodHandle target, int32 pos, class Java.Lang.Invoke.MethodHandle[] filters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.FilterArguments(Java.Lang.Invoke.MethodHandle,System.Int32,Java.Lang.Invoke.MethodHandle[])" />
      <MemberSignature Language="F#" Value="static member FilterArguments : Java.Lang.Invoke.MethodHandle * int * Java.Lang.Invoke.MethodHandle[] -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.FilterArguments (target, pos, filters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("filterArguments", "(Ljava/lang/invoke/MethodHandle;I[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("filterArguments", "(Ljava/lang/invoke/MethodHandle;I[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pos" Type="System.Int32" />
        <Parameter Name="filters" Type="Java.Lang.Invoke.MethodHandle[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after arguments are filtered</param>
        <param name="pos">the position of the first argument to filter</param>
        <param name="filters">method handles to call initially on filtered arguments</param>
        <summary>Adapts a target method handle by pre-processing
            one or more of its arguments, each with its own unary filter function,
            and then calling the target with each pre-processed argument
            replaced by the result of its corresponding filter function.</summary>
        <returns>method handle which incorporates the specified argument filtering logic</returns>
        <remarks>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#filterArguments(java.lang.invoke.MethodHandle,%20int,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterReturnValue">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? FilterReturnValue (Java.Lang.Invoke.MethodHandle? target, Java.Lang.Invoke.MethodHandle? filter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle FilterReturnValue(class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Invoke.MethodHandle filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.FilterReturnValue(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member FilterReturnValue : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.FilterReturnValue (target, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("filterReturnValue", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("filterReturnValue", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="filter" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke before filtering the return value</param>
        <param name="filter">method handle to call on the return value</param>
        <summary>Adapts a target method handle by post-processing
            its return value (if any) with a filter (another method handle).</summary>
        <returns>method handle which incorporates the specified return value filtering logic</returns>
        <remarks>
          <para>Adapts a target method handle by post-processing
            its return value (if any) with a filter (another method handle).
            The result of the filter is returned from the adapter.</para>
          <para>If the target returns a value, the filter must accept that value as
            its only argument.
            If the target returns void, the filter must accept no arguments.</para>
          <para>The return type of the filter
            replaces the return type of the target
            in the resulting adapted method handle.
            The argument type of the filter (if any) must be identical to the
            return type of the target.</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle cat = lookup().findVirtual(String.class,
              "concat", methodType(String.class, String.class));
            MethodHandle length = lookup().findVirtual(String.class,
              "length", methodType(int.class));
            System.out.println((String) cat.invokeExact("x", "y")); // xy
            MethodHandle f0 = filterReturnValue(cat, length);
            System.out.println((int) f0.invokeExact("x", "y")); // 2
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Here is pseudocode for the resulting adapter. In the code,
            <c>T</c>/<c>t</c> represent the result type and value of the
            <c>target</c>; <c>V</c>, the result type of the <c>filter</c>; and
            <c>A</c>/<c>a</c>, the types and values of the parameters and arguments
            of the <c>target</c> as well as the resulting adapter.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            T target(A...);
            V filter(T);
            V adapter(A... a) {
              T t = target(a...);
              return filter(t);
            }
            // and if the target has a void return:
            void target2(A...);
            V filter2();
            V adapter2(A... a) {
              target2(a...);
              return filter2();
            }
            // and if the filter has a void return:
            T target3(A...);
            void filter3(V);
            void adapter3(A... a) {
              T t = target3(a...);
              filter3(t);
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>&lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a MethodHandle#asVarargsCollector
            variable-arity method handle, even if the original target method handle was.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#filterReturnValue(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FoldArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? FoldArguments (Java.Lang.Invoke.MethodHandle? target, Java.Lang.Invoke.MethodHandle? combiner);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle FoldArguments(class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Invoke.MethodHandle combiner) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.FoldArguments(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member FoldArguments : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.FoldArguments (target, combiner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("foldArguments", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("foldArguments", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="combiner" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after arguments are combined</param>
        <param name="combiner">method handle to call initially on the incoming arguments</param>
        <summary>Adapts a target method handle by pre-processing
            some of its arguments, and then calling the target with
            the result of the pre-processing, inserted into the original
            sequence of arguments.</summary>
        <returns>method handle which incorporates the specified argument folding logic</returns>
        <remarks>
          <para>Adapts a target method handle by pre-processing
            some of its arguments, and then calling the target with
            the result of the pre-processing, inserted into the original
            sequence of arguments.</para>
          <para>The pre-processing is performed by <c>combiner</c>, a second method handle.
            Of the arguments passed to the adapter, the first <c>N</c> arguments
            are copied to the combiner, which is then called.
            (Here, <c>N</c> is defined as the parameter count of the combiner.)
            After this, control passes to the target, with any result
            from the combiner inserted before the original <c>N</c> incoming
            arguments.</para>
          <para>If the combiner returns a value, the first parameter type of the target
            must be identical with the return type of the combiner, and the next
            <c>N</c> parameter types of the target must exactly match the parameters
            of the combiner.</para>
          <para>If the combiner has a void return, no result will be inserted,
            and the first <c>N</c> parameter types of the target
            must exactly match the parameters of the combiner.</para>
          <para>The resulting adapter is the same type as the target, except that the
            first parameter type is dropped,
            if it corresponds to the result of the combiner.</para>
          <para>(Note that <c>#dropArguments(MethodHandle,int,List) dropArguments</c> can be used to remove any arguments
            that either the combiner or the target does not wish to receive.
            If some of the incoming arguments are destined only for the combiner,
            consider using <c>MethodHandle#asCollector asCollector</c> instead, since those
            arguments will not need to be live on the stack on entry to the
            target.)</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
              "println", methodType(void.class, String.class))
                .bindTo(System.out);
            MethodHandle cat = lookup().findVirtual(String.class,
              "concat", methodType(String.class, String.class));
            assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
            MethodHandle catTrace = foldArguments(cat, trace);
            // also prints "boo":
            assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Here is pseudocode for the resulting adapter. In the code, <c>T</c>
            represents the result type of the <c>target</c> and resulting adapter.
            <c>V</c>/<c>v</c> represent the type and value of the parameter and argument
            of <c>target</c> that precedes the folding position; <c>V</c> also is
            the result type of the <c>combiner</c>. <c>A</c>/<c>a</c> denote the
            types and values of the <c>N</c> parameters and arguments at the folding
            position. <c>B</c>/<c>b</c> represent the types and values of the
            <c>target</c> parameters and arguments that follow the folded parameters
            and arguments.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            // there are N arguments in A...
            T target(V, A[N]..., B...);
            V combiner(A...);
            T adapter(A... a, B... b) {
              V v = combiner(a...);
              return target(v, a..., b...);
            }
            // and if the combiner has a void return:
            T target2(A[N]..., B...);
            void combiner2(A...);
            T adapter2(A... a, B... b) {
              combiner2(a...);
              return target2(a..., b...);
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>&lt;em&gt;Note:&lt;/em&gt; The resulting adapter is never a MethodHandle#asVarargsCollector
            variable-arity method handle, even if the original target method handle was.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#foldArguments(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FoldArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? FoldArguments (Java.Lang.Invoke.MethodHandle? target, int pos, Java.Lang.Invoke.MethodHandle? combiner);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle FoldArguments(class Java.Lang.Invoke.MethodHandle target, int32 pos, class Java.Lang.Invoke.MethodHandle combiner) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.FoldArguments(Java.Lang.Invoke.MethodHandle,System.Int32,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member FoldArguments : Java.Lang.Invoke.MethodHandle * int * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.FoldArguments (target, pos, combiner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("foldArguments", "(Ljava/lang/invoke/MethodHandle;ILjava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("foldArguments", "(Ljava/lang/invoke/MethodHandle;ILjava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pos" Type="System.Int32" />
        <Parameter Name="combiner" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after arguments are combined</param>
        <param name="pos">the position at which to start folding and at which to insert the folding result; if this is <c>0</c>, the effect is the same as for <c>#foldArguments(MethodHandle, MethodHandle)</c>.</param>
        <param name="combiner">method handle to call initially on the incoming arguments</param>
        <summary>Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
            calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
            before the folded arguments.</summary>
        <returns>method handle which incorporates the specified argument folding logic</returns>
        <remarks>
          <para>Adapts a target method handle by pre-processing some of its arguments, starting at a given position, and then
            calling the target with the result of the pre-processing, inserted into the original sequence of arguments just
            before the folded arguments.</para>
          <para>This method is closely related to <c>#foldArguments(MethodHandle, MethodHandle)</c>, but allows to control the
            position in the parameter list at which folding takes place. The argument controlling this, <c>pos</c>, is a
            zero-based index. The aforementioned method <c>#foldArguments(MethodHandle, MethodHandle)</c> assumes position
            0.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#foldArguments(java.lang.invoke.MethodHandle,%20int,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.foldArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GuardWithTest">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? GuardWithTest (Java.Lang.Invoke.MethodHandle? test, Java.Lang.Invoke.MethodHandle? target, Java.Lang.Invoke.MethodHandle? fallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle GuardWithTest(class Java.Lang.Invoke.MethodHandle test, class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Invoke.MethodHandle fallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.GuardWithTest(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member GuardWithTest : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.GuardWithTest (test, target, fallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("guardWithTest", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("guardWithTest", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="test" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="fallback" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="test">method handle used for test, must return boolean</param>
        <param name="target">method handle to call if test passes</param>
        <param name="fallback">method handle to call if test fails</param>
        <summary>Makes a method handle which adapts a target method handle,
            by guarding it with a test, a boolean-valued method handle.</summary>
        <returns>method handle which incorporates the specified if/then/else logic</returns>
        <remarks>
          <para>Makes a method handle which adapts a target method handle,
            by guarding it with a test, a boolean-valued method handle.
            If the guard fails, a fallback handle is called instead.
            All three method handles must have the same corresponding
            argument and return types, except that the return type
            of the test must be boolean, and the test is allowed
            to have fewer arguments than the other two method handles.</para>
          <para>Here is pseudocode for the resulting adapter:
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            boolean test(A...);
            T target(A...,B...);
            T fallback(A...,B...);
            T adapter(A... a,B... b) {
              if (test(a...))
                return target(a..., b...);
              else
                return fallback(a..., b...);
            }
            }</code>
          <para>&lt;/blockquote&gt;
            Note that the test arguments (<c>a...</c> in the pseudocode) cannot
            be modified by execution of the test, and so are passed unchanged
            from the caller to the target or fallback as appropriate.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#guardWithTest(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.guardWithTest(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? Identity (Java.Lang.Class? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle Identity(class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Identity(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member Identity : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.Identity type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("identity", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("identity", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="type">the type of the sole parameter and return value of the desired method handle</param>
        <summary>Produces a method handle which returns its sole argument when invoked.</summary>
        <returns>a unary method handle which accepts and returns the given type</returns>
        <remarks>
          <para>Produces a method handle which returns its sole argument when invoked.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#identity(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.identity(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? InsertArguments (Java.Lang.Invoke.MethodHandle? target, int pos, params Java.Lang.Object[]? values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle InsertArguments(class Java.Lang.Invoke.MethodHandle target, int32 pos, class Java.Lang.Object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.InsertArguments(Java.Lang.Invoke.MethodHandle,System.Int32,Java.Lang.Object[])" />
      <MemberSignature Language="F#" Value="static member InsertArguments : Java.Lang.Invoke.MethodHandle * int * Java.Lang.Object[] -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.InsertArguments (target, pos, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("insertArguments", "(Ljava/lang/invoke/MethodHandle;I[Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("insertArguments", "(Ljava/lang/invoke/MethodHandle;I[Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pos" Type="System.Int32" />
        <Parameter Name="values" Type="Java.Lang.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after the argument is inserted</param>
        <param name="pos">where to insert the argument (zero for the first)</param>
        <param name="values">the series of arguments to insert</param>
        <summary>Provides a target method handle with one or more &lt;em&gt;bound arguments&lt;/em&gt;
            in advance of the method handle's invocation.</summary>
        <returns>a method handle which inserts an additional argument,
                    before calling the original method handle</returns>
        <remarks>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#insertArguments(java.lang.invoke.MethodHandle,%20int,%20java.lang.Object)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeLookup">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandles.Lookup? InvokeLookup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandles/Lookup InvokeLookup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.InvokeLookup" />
      <MemberSignature Language="F#" Value="static member InvokeLookup : unit -&gt; Java.Lang.Invoke.MethodHandles.Lookup" Usage="Java.Lang.Invoke.MethodHandles.InvokeLookup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("lookup", "()Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("lookup", "()Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandles+Lookup</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <c>Lookup lookup object</c> with
            full capabilities to emulate all supported bytecode behaviors of the caller.</summary>
        <returns>a lookup object for the caller of this method, with private access</returns>
        <remarks>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#lookup()" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.lookup()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? Invoker (Java.Lang.Invoke.MethodType? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle Invoker(class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Invoker(Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="static member Invoker : Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.Invoker type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("invoker", "(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("invoker", "(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="type">the desired target type</param>
        <summary>Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
            invoke any method handle compatible with the given type, as if by <c>MethodHandle#invoke invoke</c>.</summary>
        <returns>a method handle suitable for invoking any method handle convertible to the given type</returns>
        <remarks>
          <para>Produces a special &lt;em&gt;invoker method handle&lt;/em&gt; which can be used to
            invoke any method handle compatible with the given type, as if by <c>MethodHandle#invoke invoke</c>.
            The resulting invoker will have a type which is
            exactly equal to the desired type, except that it will accept
            an additional leading argument of type <c>MethodHandle</c>.</para>
          <para>Before invoking its target, if the target differs from the expected type,
            the invoker will apply reference casts as
            necessary and box, unbox, or widen primitive values, as if by <c>MethodHandle#asType asType</c>.
            Similarly, the return value will be converted as necessary.
            If the target is a MethodHandle#asVarargsCollector variable arity method handle,
            the required arity conversion will be made, again as if by <c>MethodHandle#asType asType</c>.</para>
          <para>This method is equivalent to the following code (though it may be more efficient):
            <c>publicLookup().findVirtual(MethodHandle.class, "invoke", type)</c>&lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;Discussion:&lt;/em&gt;
            A MethodType#genericMethodType general method type is one which
            mentions only <c>Object</c> arguments and return values.
            An invoker for such a type is capable of calling any method handle
            of the same arity as the general type.
            &lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;(Note:  The invoker method is not available via the Core Reflection API.
            An attempt to call java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke
            on the declared <c>invokeExact</c> or <c>invoke</c> method will raise an
            <c>java.lang.UnsupportedOperationException UnsupportedOperationException</c>.)&lt;/em&gt;</para>
          <para>This method throws no reflective or security exceptions.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#invoker(java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.invoker(java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IteratedLoop">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? IteratedLoop (Java.Lang.Invoke.MethodHandle? iterator, Java.Lang.Invoke.MethodHandle? init, Java.Lang.Invoke.MethodHandle? body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle IteratedLoop(class Java.Lang.Invoke.MethodHandle iterator, class Java.Lang.Invoke.MethodHandle init, class Java.Lang.Invoke.MethodHandle body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.IteratedLoop(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member IteratedLoop : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.IteratedLoop (iterator, init, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("iteratedLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("iteratedLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterator" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="init" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="body" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="iterator">an optional handle to return the iterator to start the loop.
                            If non-<c>null</c>, the handle must return <c>java.util.Iterator</c> or a subtype.
                            See above for other constraints.</param>
        <param name="init">optional initializer, providing the initial value of the loop variable.
                        May be <c>null</c>, implying a default initial value.  See above for other constraints.</param>
        <param name="body">body of the loop, which may not be <c>null</c>.
                        It controls the loop parameters and result type in the standard case (see above for details).
                        It must accept its own return type (if non-void) plus a <c>T</c> parameter (for the iterated values),
                        and may accept any number of additional types.
                        See above for other constraints.</param>
        <summary>Constructs a loop that ranges over the values produced by an <c>Iterator&lt;T&gt;</c>.</summary>
        <returns>a method handle embodying the iteration loop functionality.</returns>
        <remarks>
          <para>Constructs a loop that ranges over the values produced by an <c>Iterator&lt;T&gt;</c>.
            This is a convenience wrapper for the #loop(MethodHandle[][]) generic loop combinator.</para>
          <para>The iterator itself will be determined by the evaluation of the <c>iterator</c> handle.
            Each value it produces will be stored in a loop iteration variable of type <c>T</c>.</para>
          <para>If the <c>body</c> handle returns a non-<c>void</c> type <c>V</c>, a leading loop iteration variable
            of that type is also present.  This variable is initialized using the optional <c>init</c> handle,
            or to the #empty default value of type <c>V</c> if that handle is <c>null</c>.</para>
          <para>In each iteration, the iteration variables are passed to an invocation of the <c>body</c> handle.
            A non-<c>void</c> value returned from the body (of type <c>V</c>) updates the leading
            iteration variable.
            The result of the loop handle execution will be the final <c>V</c> value of that variable
            (or <c>void</c> if there is no <c>V</c> variable).</para>
          <para>The following rules hold for the argument handles:&lt;ul&gt;
            &lt;li&gt;The <c>body</c> handle must not be <c>null</c>; its type must be of the form
            <c>(V T A...)V</c>, where <c>V</c> is non-<c>void</c>, or else <c>(T A...)void</c>.
            (In the <c>void</c> case, we assign the type <c>void</c> to the name <c>V</c>,
            and we will write <c>(V T A...)V</c> with the understanding that a <c>void</c> type <c>V</c>
            is quietly dropped from the parameter list, leaving <c>(T A...)V</c>.)
            &lt;li&gt;The parameter list <c>(V T A...)</c> of the body contributes to a list
            of types called the &lt;em&gt;internal parameter list&lt;/em&gt;.
            It will constrain the parameter lists of the other loop parts.
            &lt;li&gt;As a special case, if the body contributes only <c>V</c> and <c>T</c> types,
            with no additional <c>A</c> types, then the internal parameter list is extended by
            the argument types <c>A...</c> of the <c>iterator</c> handle; if it is <c>null</c> the
            single type <c>Iterable</c> is added and constitutes the <c>A...</c> list.
            &lt;li&gt;If the iteration variable types <c>(V T)</c> are dropped from the internal parameter list, the resulting shorter
            list <c>(A...)</c> is called the &lt;em&gt;external parameter list&lt;/em&gt;.
            &lt;li&gt;The body return type <c>V</c>, if non-<c>void</c>, determines the type of an
            additional state variable of the loop.
            The body must both accept a leading parameter and return a value of this type <c>V</c>.
            &lt;li&gt;If <c>init</c> is non-<c>null</c>, it must have return type <c>V</c>.
            Its parameter list (of some form &lt;c&gt;(A*)&lt;/c&gt;) must be
            effectively identical
            to the external parameter list <c>(A...)</c>.
            &lt;li&gt;If <c>init</c> is <c>null</c>, the loop variable will be initialized to its
            #empty default value.
            &lt;li&gt;If the <c>iterator</c> handle is non-<c>null</c>, it must have the return
            type <c>java.util.Iterator</c> or a subtype thereof.
            The iterator it produces when the loop is executed will be assumed
            to yield values which can be converted to type <c>T</c>.
            &lt;li&gt;The parameter list of an <c>iterator</c> that is non-<c>null</c> (of some form <c>(A*)</c>) must be
            effectively identical to the external parameter list <c>(A...)</c>.
            &lt;li&gt;If <c>iterator</c> is <c>null</c> it defaults to a method handle which behaves
            like <c>java.lang.Iterable#iterator()</c>.  In that case, the internal parameter list
            <c>(V T A...)</c> must have at least one <c>A</c> type, and the default iterator
            handle parameter is adjusted to accept the leading <c>A</c> type, as if by
            the <c>MethodHandle#asType asType</c> conversion method.
            The leading <c>A</c> type must be <c>Iterable</c> or a subtype thereof.
            This conversion step, done at loop construction time, must not throw a <c>WrongMethodTypeException</c>.
            &lt;/ul&gt;</para>
          <para>The type <c>T</c> may be either a primitive or reference.
            Since type <c>Iterator&lt;T&gt;</c> is erased in the method handle representation to the raw type <c>Iterator</c>,
            the <c>iteratedLoop</c> combinator adjusts the leading argument type for <c>body</c> to <c>Object</c>
            as if by the <c>MethodHandle#asType asType</c> conversion method.
            Therefore, if an iterator of the wrong type appears as the loop is executed, runtime exceptions may occur
            as the result of dynamic conversions performed by <c>MethodHandle#asType(MethodType)</c>.</para>
          <para>The resulting loop handle's result type and parameter signature are determined as follows:&lt;ul&gt;
            &lt;li&gt;The loop handle's result type is the result type <c>V</c> of the body.
            &lt;li&gt;The loop handle's parameter types are the types <c>(A...)</c>,
            from the external parameter list.
            &lt;/ul&gt;</para>
          <para>Here is pseudocode for the resulting loop handle. In the code, <c>V</c>/<c>v</c> represent the type / value of
            the loop variable as well as the result type of the loop; <c>T</c>/<c>t</c>, that of the elements of the
            structure the loop iterates over, and <c>A...</c>/<c>a...</c> represent arguments passed to the loop.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            Iterator&lt;T&gt; iterator(A...);  // defaults to Iterable::iterator
            V init(A...);
            V body(V,T,A...);
            V iteratedLoop(A... a...) {
              Iterator&lt;T&gt; it = iterator(a...);
              V v = init(a...);
              while (it.hasNext()) {
                T t = it.next();
                v = body(v, t, a...);
              }
              return v;
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#iteratedLoop(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.iteratedLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JniPeerMembers">
      <MemberSignature Language="C#" Value="public override Java.Interop.JniPeerMembers JniPeerMembers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Interop.JniPeerMembers JniPeerMembers" />
      <MemberSignature Language="DocId" Value="P:Java.Lang.Invoke.MethodHandles.JniPeerMembers" />
      <MemberSignature Language="F#" Value="member this.JniPeerMembers : Java.Interop.JniPeerMembers" Usage="Java.Lang.Invoke.MethodHandles.JniPeerMembers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Interop.JniPeerMembers</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Loop">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? Loop (params Java.Lang.Invoke.MethodHandle[][]? clauses);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle Loop(class Java.Lang.Invoke.MethodHandle[][] clauses) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Loop(Java.Lang.Invoke.MethodHandle[][])" />
      <MemberSignature Language="F#" Value="static member Loop : Java.Lang.Invoke.MethodHandle[][] -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.Loop clauses" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("loop", "([[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("loop", "([[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clauses" Type="Java.Lang.Invoke.MethodHandle[][]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="clauses">an array of arrays (4-tuples) of <c>MethodHandle</c>s adhering to the rules described above.</param>
        <summary>Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
            iteration.</summary>
        <returns>a method handle embodying the looping behavior as defined by the arguments.</returns>
        <remarks>
          <para>Constructs a method handle representing a loop with several loop variables that are updated and checked upon each
            iteration. Upon termination of the loop due to one of the predicates, a corresponding finalizer is run and
            delivers the loop's result, which is the return value of the resulting handle.</para>
          <para>Intuitively, every loop is formed by one or more "clauses", each specifying a local &lt;em&gt;iteration variable&lt;/em&gt; and/or a loop
            exit. Each iteration of the loop executes each clause in order. A clause can optionally update its iteration
            variable; it can also optionally perform a test and conditional loop exit. In order to express this logic in
            terms of method handles, each clause will specify up to four independent actions:&lt;ul&gt;
            &lt;li&gt;&lt;em&gt;init:&lt;/em&gt; Before the loop executes, the initialization of an iteration variable <c>v</c> of type <c>V</c>.
            &lt;li&gt;&lt;em&gt;step:&lt;/em&gt; When a clause executes, an update step for the iteration variable <c>v</c>.
            &lt;li&gt;&lt;em&gt;pred:&lt;/em&gt; When a clause executes, a predicate execution to test for loop exit.
            &lt;li&gt;&lt;em&gt;fini:&lt;/em&gt; If a clause causes a loop exit, a finalizer execution to compute the loop's return value.
            &lt;/ul&gt;
            The full sequence of all iteration variable types, in clause order, will be notated as <c>(V...)</c>.
            The values themselves will be <c>(v...)</c>.  When we speak of "parameter lists", we will usually
            be referring to types, but in some contexts (describing execution) the lists will be of actual values.</para>
          <para>Some of these clause parts may be omitted according to certain rules, and useful default behavior is provided in
            this case. See below for a detailed description.</para>
          <para>&lt;em&gt;Parameters optional everywhere:&lt;/em&gt;
            Each clause function is allowed but not required to accept a parameter for each iteration variable <c>v</c>.
            As an exception, the init functions cannot take any <c>v</c> parameters,
            because those values are not yet computed when the init functions are executed.
            Any clause function may neglect to take any trailing subsequence of parameters it is entitled to take.
            In fact, any clause function may take no arguments at all.</para>
          <para>&lt;em&gt;Loop parameters:&lt;/em&gt;
            A clause function may take all the iteration variable values it is entitled to, in which case
            it may also take more trailing parameters. Such extra values are called &lt;em&gt;loop parameters&lt;/em&gt;,
            with their types and values notated as <c>(A...)</c> and <c>(a...)</c>.
            These become the parameters of the resulting loop handle, to be supplied whenever the loop is executed.
            (Since init functions do not accept iteration variables <c>v</c>, any parameter to an
            init function is automatically a loop parameter <c>a</c>.)
            As with iteration variables, clause functions are allowed but not required to accept loop parameters.
            These loop parameters act as loop-invariant values visible across the whole loop.</para>
          <para>&lt;em&gt;Parameters visible everywhere:&lt;/em&gt;
            Each non-init clause function is permitted to observe the entire loop state, because it can be passed the full
            list <c>(v... a...)</c> of current iteration variable values and incoming loop parameters.
            The init functions can observe initial pre-loop state, in the form <c>(a...)</c>.
            Most clause functions will not need all of this information, but they will be formally connected to it
            as if by <c>#dropArguments</c>.
            "astar"&gt;
            More specifically, we shall use the notation <c>(V*)</c> to express an arbitrary prefix of a full
            sequence <c>(V...)</c> (and likewise for <c>(v*)</c>, <c>(A*)</c>, <c>(a*)</c>).
            In that notation, the general form of an init function parameter list
            is <c>(A*)</c>, and the general form of a non-init function parameter list is <c>(V*)</c> or <c>(V... A*)</c>.</para>
          <para>&lt;em&gt;Checking clause structure:&lt;/em&gt;
            Given a set of clauses, there is a number of checks and adjustments performed to connect all the parts of the
            loop. They are spelled out in detail in the steps below. In these steps, every occurrence of the word "must"
            corresponds to a place where <c>IllegalArgumentException</c> will be thrown if the required constraint is not
            met by the inputs to the loop combinator.</para>
          <para>&lt;em&gt;Effectively identical sequences:&lt;/em&gt;
            "effid"&gt;
            A parameter list <c>A</c> is defined to be &lt;em&gt;effectively identical&lt;/em&gt; to another parameter list <c>B</c>
            if <c>A</c> and <c>B</c> are identical, or if <c>A</c> is shorter and is identical with a proper prefix of <c>B</c>.
            When speaking of an unordered set of parameter lists, we say they the set is "effectively identical"
            as a whole if the set contains a longest list, and all members of the set are effectively identical to
            that longest list.
            For example, any set of type sequences of the form <c>(V*)</c> is effectively identical,
            and the same is true if more sequences of the form <c>(V... A*)</c> are added.</para>
          <para>&lt;em&gt;Step 0: Determine clause structure.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;The clause array (of type <c>MethodHandle[][]</c>) must be non-<c>null</c> and contain at least one element.
            &lt;li&gt;The clause array may not contain <c>null</c>s or sub-arrays longer than four elements.
            &lt;li&gt;Clauses shorter than four elements are treated as if they were padded by <c>null</c> elements to length
            four. Padding takes place by appending elements to the array.
            &lt;li&gt;Clauses with all <c>null</c>s are disregarded.
            &lt;li&gt;Each clause is treated as a four-tuple of functions, called "init", "step", "pred", and "fini".
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Step 1A: Determine iteration variable types <c>(V...)</c>.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;The iteration variable type for each clause is determined using the clause's init and step return types.
            &lt;li&gt;If both functions are omitted, there is no iteration variable for the corresponding clause (<c>void</c> is
            used as the type to indicate that). If one of them is omitted, the other's return type defines the clause's
            iteration variable type. If both are given, the common return type (they must be identical) defines the clause's
            iteration variable type.
            &lt;li&gt;Form the list of return types (in clause order), omitting all occurrences of <c>void</c>.
            &lt;li&gt;This list of types is called the "iteration variable types" (<c>(V...)</c>).
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Step 1B: Determine loop parameters <c>(A...)</c>.&lt;/em&gt;&lt;ul&gt;
            &lt;li&gt;Examine and collect init function parameter lists (which are of the form <c>(A*)</c>).
            &lt;li&gt;Examine and collect the suffixes of the step, pred, and fini parameter lists, after removing the iteration variable types.
            (They must have the form <c>(V... A*)</c>; collect the <c>(A*)</c> parts only.)
            &lt;li&gt;Do not collect suffixes from step, pred, and fini parameter lists that do not begin with all the iteration variable types.
            (These types will be checked in step 2, along with all the clause function types.)
            &lt;li&gt;Omitted clause functions are ignored.  (Equivalently, they are deemed to have empty parameter lists.)
            &lt;li&gt;All of the collected parameter lists must be effectively identical.
            &lt;li&gt;The longest parameter list (which is necessarily unique) is called the "external parameter list" (<c>(A...)</c>).
            &lt;li&gt;If there is no such parameter list, the external parameter list is taken to be the empty sequence.
            &lt;li&gt;The combined list consisting of iteration variable types followed by the external parameter types is called
            the "internal parameter list".
            &lt;/ul&gt;</para>
          <para>&lt;em&gt;Step 1C: Determine loop return type.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;Examine fini function return types, disregarding omitted fini functions.
            &lt;li&gt;If there are no fini functions, the loop return type is <c>void</c>.
            &lt;li&gt;Otherwise, the common return type <c>R</c> of the fini functions (their return types must be identical) defines the loop return
            type.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Step 1D: Check other types.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;There must be at least one non-omitted pred function.
            &lt;li&gt;Every non-omitted pred function must have a <c>boolean</c> return type.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Step 2: Determine parameter lists.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;The parameter list for the resulting loop handle will be the external parameter list <c>(A...)</c>.
            &lt;li&gt;The parameter list for init functions will be adjusted to the external parameter list.
            (Note that their parameter lists are already effectively identical to this list.)
            &lt;li&gt;The parameter list for every non-omitted, non-init (step, pred, and fini) function must be
            effectively identical to the internal parameter list <c>(V... A...)</c>.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Step 3: Fill in omitted functions.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;If an init function is omitted, use a #empty default value for the clause's iteration variable
            type.
            &lt;li&gt;If a step function is omitted, use an #identity identity function of the clause's iteration
            variable type; insert dropped argument parameters before the identity function parameter for the non-<c>void</c>
            iteration variables of preceding clauses. (This will turn the loop variable into a local loop invariant.)
            &lt;li&gt;If a pred function is omitted, use a constant <c>true</c> function. (This will keep the loop going, as far
            as this clause is concerned.  Note that in such cases the corresponding fini function is unreachable.)
            &lt;li&gt;If a fini function is omitted, use a #empty default value for the
            loop return type.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Step 4: Fill in missing parameter types.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;At this point, every init function parameter list is effectively identical to the external parameter list <c>(A...)</c>,
            but some lists may be shorter. For every init function with a short parameter list, pad out the end of the list.
            &lt;li&gt;At this point, every non-init function parameter list is effectively identical to the internal parameter
            list <c>(V... A...)</c>, but some lists may be shorter. For every non-init function with a short parameter list,
            pad out the end of the list.
            &lt;li&gt;Argument lists are padded out by #dropArgumentsToMatch(MethodHandle, int, List, int) dropping unused trailing arguments.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Final observations.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;After these steps, all clauses have been adjusted by supplying omitted functions and arguments.
            &lt;li&gt;All init functions have a common parameter type list <c>(A...)</c>, which the final loop handle will also have.
            &lt;li&gt;All fini functions have a common return type <c>R</c>, which the final loop handle will also have.
            &lt;li&gt;All non-init functions have a common parameter type list <c>(V... A...)</c>, of
            (non-<c>void</c>) iteration variables <c>V</c> followed by loop parameters.
            &lt;li&gt;Each pair of init and step functions agrees in their return type <c>V</c>.
            &lt;li&gt;Each non-init function will be able to observe the current values <c>(v...)</c> of all iteration variables.
            &lt;li&gt;Every function will be able to observe the incoming values <c>(a...)</c> of all loop parameters.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Example.&lt;/em&gt; As a consequence of step 1A above, the <c>loop</c> combinator has the following property:
            &lt;ul&gt;
            &lt;li&gt;Given <c>N</c> clauses <c>Cn = {null, Sn, Pn</c>} with <c>n = 1..N</c>.
            &lt;li&gt;Suppose predicate handles <c>Pn</c> are either <c>null</c> or have no parameters.
            (Only one <c>Pn</c> has to be non-<c>null</c>.)
            &lt;li&gt;Suppose step handles <c>Sn</c> have signatures <c>(B1..BX)Rn</c>, for some constant <c>X&gt;=N</c>.
            &lt;li&gt;Suppose <c>Q</c> is the count of non-void types <c>Rn</c>, and <c>(V1...VQ)</c> is the sequence of those types.
            &lt;li&gt;It must be that <c>Vn == Bn</c> for <c>n = 1..min(X,Q)</c>.
            &lt;li&gt;The parameter types <c>Vn</c> will be interpreted as loop-local state elements <c>(V...)</c>.
            &lt;li&gt;Any remaining types <c>BQ+1..BX</c> (if <c>Q&lt;X</c>) will determine
            the resulting loop handle's parameter types <c>(A...)</c>.
            &lt;/ul&gt;
            In this example, the loop handle parameters <c>(A...)</c> were derived from the step functions,
            which is natural if most of the loop computation happens in the steps.  For some loops,
            the burden of computation might be heaviest in the pred functions, and so the pred functions
            might need to accept the loop parameter values.  For loops with complex exit logic, the fini
            functions might need to accept loop parameters, and likewise for loops with complex entry logic,
            where the init functions will need the extra parameters.  For such reasons, the rules for
            determining these parameters are as symmetric as possible, across all clause parts.
            In general, the loop parameters function as common invariant values across the whole
            loop, while the iteration variables function as common variant values, or (if there is
            no step function) as internal loop invariant temporaries.</para>
          <para>&lt;em&gt;Loop execution.&lt;/em&gt;&lt;ol type="a"&gt;
            &lt;li&gt;When the loop is called, the loop input values are saved in locals, to be passed to
            every clause function. These locals are loop invariant.
            &lt;li&gt;Each init function is executed in clause order (passing the external arguments <c>(a...)</c>)
            and the non-<c>void</c> values are saved (as the iteration variables <c>(v...)</c>) into locals.
            These locals will be loop varying (unless their steps behave as identity functions, as noted above).
            &lt;li&gt;All function executions (except init functions) will be passed the internal parameter list, consisting of
            the non-<c>void</c> iteration values <c>(v...)</c> (in clause order) and then the loop inputs <c>(a...)</c>
            (in argument order).
            &lt;li&gt;The step and pred functions are then executed, in clause order (step before pred), until a pred function
            returns <c>false</c>.
            &lt;li&gt;The non-<c>void</c> result from a step function call is used to update the corresponding value in the
            sequence <c>(v...)</c> of loop variables.
            The updated value is immediately visible to all subsequent function calls.
            &lt;li&gt;If a pred function returns <c>false</c>, the corresponding fini function is called, and the resulting value
            (of type <c>R</c>) is returned from the loop as a whole.
            &lt;li&gt;If all the pred functions always return true, no fini function is ever invoked, and the loop cannot exit
            except by throwing an exception.
            &lt;/ol&gt;</para>
          <para>&lt;em&gt;Usage tips.&lt;/em&gt;
            &lt;ul&gt;
            &lt;li&gt;Although each step function will receive the current values of &lt;em&gt;all&lt;/em&gt; the loop variables,
            sometimes a step function only needs to observe the current value of its own variable.
            In that case, the step function may need to explicitly #dropArguments drop all preceding loop variables.
            This will require mentioning their types, in an expression like <c>dropArguments(step, 0, V0.class, ...)</c>.
            &lt;li&gt;Loop variables are not required to vary; they can be loop invariant.  A clause can create
            a loop invariant by a suitable init function with no step, pred, or fini function.  This may be
            useful to "wire" an incoming loop argument into the step or pred function of an adjacent loop variable.
            &lt;li&gt;If some of the clause functions are virtual methods on an instance, the instance
            itself can be conveniently placed in an initial invariant loop "variable", using an initial clause
            like <c>new MethodHandle[]{identity(ObjType.class)</c>}.  In that case, the instance reference
            will be the first iteration variable value, and it will be easy to use virtual
            methods as clause parts, since all of them will take a leading instance reference matching that value.
            &lt;/ul&gt;</para>
          <para>Here is pseudocode for the resulting loop handle. As above, <c>V</c> and <c>v</c> represent the types
            and values of loop variables; <c>A</c> and <c>a</c> represent arguments passed to the whole loop;
            and <c>R</c> is the common result type of all finalizers as well as of the resulting loop.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            V... init...(A...);
            boolean pred...(V..., A...);
            V... step...(V..., A...);
            R fini...(V..., A...);
            R loop(A... a) {
              V... v... = init...(a...);
              for (;;) {
                for ((v, p, s, f) in (v..., pred..., step..., fini...)) {
                  v = s(v..., a...);
                  if (!p(v..., a...)) {
                    return f(v..., a...);
                  }
                }
              }
            }
            }</code>
          <para>&lt;/blockquote&gt;
            Note that the parameter type lists <c>(V...)</c> and <c>(A...)</c> have been expanded
            to their full length, even though individual clause functions may neglect to take them all.
            As noted above, missing parameters are filled in as if by <c>#dropArgumentsToMatch(MethodHandle, int, List, int)</c>.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#loop(java.lang.invoke.MethodHandle[]...)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.loop(java.lang.invoke.MethodHandle[]...)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PermuteArguments">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? PermuteArguments (Java.Lang.Invoke.MethodHandle? target, Java.Lang.Invoke.MethodType? newType, params int[]? reorder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle PermuteArguments(class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Invoke.MethodType newType, int32[] reorder) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.PermuteArguments(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodType,System.Int32[])" />
      <MemberSignature Language="F#" Value="static member PermuteArguments : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodType * int[] -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.PermuteArguments (target, newType, reorder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("permuteArguments", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;[I)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("permuteArguments", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;[I)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="newType" Type="Java.Lang.Invoke.MethodType" />
        <Parameter Name="reorder" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="target">the method handle to invoke after arguments are reordered</param>
        <param name="newType">the expected type of the new method handle</param>
        <param name="reorder">an index array which controls the reordering</param>
        <summary>Produces a method handle which adapts the calling sequence of the
            given method handle to a new type, by reordering the arguments.</summary>
        <returns>a method handle which delegates to the target after it
                      drops unused arguments and moves and/or duplicates the other arguments</returns>
        <remarks>
          <para>Produces a method handle which adapts the calling sequence of the
            given method handle to a new type, by reordering the arguments.
            The resulting method handle is guaranteed to report a type
            which is equal to the desired new type.</para>
          <para>The given array controls the reordering.
            Call <c>#I</c> the number of incoming parameters (the value
            <c>newType.parameterCount()</c>, and call <c>#O</c> the number
            of outgoing parameters (the value <c>target.type().parameterCount()</c>).
            Then the length of the reordering array must be <c>#O</c>,
            and each element must be a non-negative number less than <c>#I</c>.
            For every <c>N</c> less than <c>#O</c>, the <c>N</c>-th
            outgoing argument will be taken from the <c>I</c>-th incoming
            argument, where <c>I</c> is <c>reorder[N]</c>.</para>
          <para>No argument or return value conversions are applied.
            The type of each incoming argument, as determined by <c>newType</c>,
            must be identical to the type of the corresponding outgoing parameter
            or parameters in the target method handle.
            The return type of <c>newType</c> must be identical to the return
            type of the original target.</para>
          <para>The reordering array need not specify an actual permutation.
            An incoming argument will be duplicated if its index appears
            more than once in the array, and an incoming argument will be dropped
            if its index does not appear in the array.
            As in the case of <c>#dropArguments(MethodHandle,int,List) dropArguments</c>,
            incoming arguments which are not mentioned in the reordering array
            are may be any type, as determined only by <c>newType</c>.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodType intfn1 = methodType(int.class, int.class);
            MethodType intfn2 = methodType(int.class, int.class, int.class);
            MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
            assert(sub.type().equals(intfn2));
            MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
            MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
            assert((int)rsub.invokeExact(1, 100) == 99);
            MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
            assert(add.type().equals(intfn2));
            MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
            assert(twice.type().equals(intfn1));
            assert((int)twice.invokeExact(21) == 42);
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#permuteArguments(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodType,%20int...)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.permuteArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType, int...)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateLookupIn">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandles.Lookup? PrivateLookupIn (Java.Lang.Class? targetClass, Java.Lang.Invoke.MethodHandles.Lookup? lookup);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandles/Lookup PrivateLookupIn(class Java.Lang.Class targetClass, class Java.Lang.Invoke.MethodHandles/Lookup lookup) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.PrivateLookupIn(Java.Lang.Class,Java.Lang.Invoke.MethodHandles.Lookup)" />
      <MemberSignature Language="F#" Value="static member PrivateLookupIn : Java.Lang.Class * Java.Lang.Invoke.MethodHandles.Lookup -&gt; Java.Lang.Invoke.MethodHandles.Lookup" Usage="Java.Lang.Invoke.MethodHandles.PrivateLookupIn (targetClass, lookup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("privateLookupIn", "(Ljava/lang/Class;Ljava/lang/invoke/MethodHandles$Lookup;)Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("privateLookupIn", "(Ljava/lang/Class;Ljava/lang/invoke/MethodHandles$Lookup;)Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandles+Lookup</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetClass" Type="Java.Lang.Class" />
        <Parameter Name="lookup" Type="Java.Lang.Invoke.MethodHandles+Lookup" />
      </Parameters>
      <Docs>
        <param name="targetClass">To be added.</param>
        <param name="lookup">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicLookup">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandles.Lookup? PublicLookup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandles/Lookup PublicLookup() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.PublicLookup" />
      <MemberSignature Language="F#" Value="static member PublicLookup : unit -&gt; Java.Lang.Invoke.MethodHandles.Lookup" Usage="Java.Lang.Invoke.MethodHandles.PublicLookup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("publicLookup", "()Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("publicLookup", "()Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandles+Lookup</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <c>Lookup lookup object</c> which is trusted minimally.</summary>
        <returns>a lookup object which is trusted minimally</returns>
        <remarks>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#publicLookup()" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.publicLookup()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectAs">
      <MemberSignature Language="C#" Value="public static Java.Lang.Object? ReflectAs (Java.Lang.Class? expected, Java.Lang.Invoke.MethodHandle? target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Object ReflectAs(class Java.Lang.Class expected, class Java.Lang.Invoke.MethodHandle target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ReflectAs(Java.Lang.Class,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member ReflectAs : Java.Lang.Class * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Object" Usage="Java.Lang.Invoke.MethodHandles.ReflectAs (expected, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("reflectAs", "(Ljava/lang/Class;Ljava/lang/invoke/MethodHandle;)Ljava/lang/reflect/Member;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("reflectAs", "(Ljava/lang/Class;Ljava/lang/invoke/MethodHandle;)Ljava/lang/reflect/Member;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[Java.Interop.JavaTypeParameters(new System.String[] { "T extends java.lang.reflect.Member" })]</AttributeName>
          <AttributeName Language="F#">[&lt;Java.Interop.JavaTypeParameters(new System.String[] { "T extends java.lang.reflect.Member" })&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expected" Type="Java.Lang.Class" />
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="&lt;T&gt;&lt;T&gt;">the desired type of the result, either <c>Member</c> or a subtype</param>
        <param name="target">a direct method handle to crack into symbolic reference components</param>
        <param name="expected">a class object representing the desired result type <c>T</c></param>
        <summary>Performs an unchecked "crack" of a
            direct method handle.</summary>
        <returns>a reference to the method, constructor, or field object</returns>
        <remarks>
          <para>Performs an unchecked "crack" of a
            direct method handle.
            The result is as if the user had obtained a lookup object capable enough
            to crack the target method handle, called
            <c>java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect</c>
            on the target to obtain its symbolic reference, and then called
            <c>java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs</c>
            to resolve the symbolic reference to a member.</para>
          <para>If there is a security manager, its <c>checkPermission</c> method
            is called with a <c>ReflectPermission("suppressAccessChecks")</c> permission.</para>
          <para>Added in 1.8.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#reflectAs(java.lang.Class%3CT%3E,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.reflectAs(java.lang.Class&lt;T&gt;, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SpreadInvoker">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? SpreadInvoker (Java.Lang.Invoke.MethodType? type, int leadingArgCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle SpreadInvoker(class Java.Lang.Invoke.MethodType type, int32 leadingArgCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.SpreadInvoker(Java.Lang.Invoke.MethodType,System.Int32)" />
      <MemberSignature Language="F#" Value="static member SpreadInvoker : Java.Lang.Invoke.MethodType * int -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.SpreadInvoker (type, leadingArgCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("spreadInvoker", "(Ljava/lang/invoke/MethodType;I)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("spreadInvoker", "(Ljava/lang/invoke/MethodType;I)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
        <Parameter Name="leadingArgCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="type">the desired target type</param>
        <param name="leadingArgCount">number of fixed arguments, to be passed unchanged to the target</param>
        <summary>Produces a method handle which will invoke any method handle of the
            given <c>type</c>, with a given number of trailing arguments replaced by
            a single trailing <c>Object[]</c> array.</summary>
        <returns>a method handle suitable for invoking any method handle of the given type</returns>
        <remarks>
          <para>Produces a method handle which will invoke any method handle of the
            given <c>type</c>, with a given number of trailing arguments replaced by
            a single trailing <c>Object[]</c> array.
            The resulting invoker will be a method handle with the following
            arguments:
            &lt;ul&gt;
            &lt;li&gt;a single <c>MethodHandle</c> target
            &lt;li&gt;zero or more leading values (counted by <c>leadingArgCount</c>)
            &lt;li&gt;an <c>Object[]</c> array containing trailing arguments
            &lt;/ul&gt;</para>
          <para>The invoker will invoke its target like a call to <c>MethodHandle#invoke invoke</c> with
            the indicated <c>type</c>.
            That is, if the target is exactly of the given <c>type</c>, it will behave
            like <c>invokeExact</c>; otherwise it behave as if <c>MethodHandle#asType asType</c>
            is used to convert the target to the required <c>type</c>.</para>
          <para>The type of the returned invoker will not be the given <c>type</c>, but rather
            will have all parameters except the first <c>leadingArgCount</c>
            replaced by a single array of type <c>Object[]</c>, which will be
            the final parameter.</para>
          <para>Before invoking its target, the invoker will spread the final array, apply
            reference casts as necessary, and unbox and widen primitive arguments.
            If, when the invoker is called, the supplied array argument does
            not have the correct number of elements, the invoker will throw
            an <c>IllegalArgumentException</c> instead of invoking the target.</para>
          <para>This method is equivalent to the following code (though it may be more efficient):
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            MethodHandle invoker = MethodHandles.invoker(type);
            int spreadArgCount = type.parameterCount() - leadingArgCount;
            invoker = invoker.asSpreader(Object[].class, spreadArgCount);
            return invoker;
            }</code>
          <para>&lt;/blockquote&gt;
            This method throws no reflective or security exceptions.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#spreadInvoker(java.lang.invoke.MethodType,%20int)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.spreadInvoker(java.lang.invoke.MethodType, int)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableSwitch">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? TableSwitch (Java.Lang.Invoke.MethodHandle? fallback, params Java.Lang.Invoke.MethodHandle[]? targets);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle TableSwitch(class Java.Lang.Invoke.MethodHandle fallback, class Java.Lang.Invoke.MethodHandle[] targets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.TableSwitch(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle[])" />
      <MemberSignature Language="F#" Value="static member TableSwitch : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle[] -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.TableSwitch (fallback, targets)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("tableSwitch", "(Ljava/lang/invoke/MethodHandle;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=34)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("tableSwitch", "(Ljava/lang/invoke/MethodHandle;[Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=34)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android34.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android34.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fallback" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="targets" Type="Java.Lang.Invoke.MethodHandle[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="fallback">To be added.</param>
        <param name="targets">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberSignature Language="DocId" Value="P:Java.Lang.Invoke.MethodHandles.ThresholdClass" />
      <MemberSignature Language="F#" Value="member this.ThresholdClass : nativeint" Usage="Java.Lang.Invoke.MethodHandles.ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberSignature Language="DocId" Value="P:Java.Lang.Invoke.MethodHandles.ThresholdType" />
      <MemberSignature Language="F#" Value="member this.ThresholdType : Type" Usage="Java.Lang.Invoke.MethodHandles.ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowException">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? ThrowException (Java.Lang.Class? returnType, Java.Lang.Class? exType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle ThrowException(class Java.Lang.Class returnType, class Java.Lang.Class exType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.ThrowException(Java.Lang.Class,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member ThrowException : Java.Lang.Class * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.ThrowException (returnType, exType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("throwException", "(Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("throwException", "(Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="Java.Lang.Class" />
        <Parameter Name="exType" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="returnType">the return type of the desired method handle</param>
        <param name="exType">the parameter type of the desired method handle</param>
        <summary>Produces a method handle which will throw exceptions of the given <c>exType</c>.</summary>
        <returns>method handle which can throw the given exceptions</returns>
        <remarks>
          <para>Produces a method handle which will throw exceptions of the given <c>exType</c>.
            The method handle will accept a single argument of <c>exType</c>,
            and immediately throw it as an exception.
            The method type will nominally specify a return of <c>returnType</c>.
            The return type may be anything convenient:  It doesn't matter to the
            method handle's behavior, since it will never return normally.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#throwException(java.lang.Class%3C?%3E,%20java.lang.Class%3C?%20extends%20java.lang.Throwable%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.throwException(java.lang.Class&lt;?&gt;, java.lang.Class&lt;? extends java.lang.Throwable&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFinally">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? TryFinally (Java.Lang.Invoke.MethodHandle? target, Java.Lang.Invoke.MethodHandle? cleanup);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle TryFinally(class Java.Lang.Invoke.MethodHandle target, class Java.Lang.Invoke.MethodHandle cleanup) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.TryFinally(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member TryFinally : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.TryFinally (target, cleanup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("tryFinally", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("tryFinally", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="cleanup" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">the handle whose execution is to be wrapped in a <c>try</c> block.</param>
        <param name="cleanup">the handle that is invoked in the finally block.</param>
        <summary>Makes a method handle that adapts a <c>target</c> method handle by wrapping it in a <c>try-finally</c> block.</summary>
        <returns>a method handle embodying the <c>try-finally</c> block composed of the two arguments.</returns>
        <remarks>
          <para>Makes a method handle that adapts a <c>target</c> method handle by wrapping it in a <c>try-finally</c> block.
            Another method handle, <c>cleanup</c>, represents the functionality of the <c>finally</c> block. Any exception
            thrown during the execution of the <c>target</c> handle will be passed to the <c>cleanup</c> handle. The
            exception will be rethrown, unless <c>cleanup</c> handle throws an exception first.  The
            value returned from the <c>cleanup</c> handle's execution will be the result of the execution of the
            <c>try-finally</c> handle.</para>
          <para>The <c>cleanup</c> handle will be passed one or two additional leading arguments.
            The first is the exception thrown during the
            execution of the <c>target</c> handle, or <c>null</c> if no exception was thrown.
            The second is the result of the execution of the <c>target</c> handle, or, if it throws an exception,
            a <c>null</c>, zero, or <c>false</c> value of the required type is supplied as a placeholder.
            The second argument is not present if the <c>target</c> handle has a <c>void</c> return type.
            (Note that, except for argument type conversions, combinators represent <c>void</c> values in parameter lists
            by omitting the corresponding paradoxical arguments, not by inserting <c>null</c> or zero values.)</para>
          <para>The <c>target</c> and <c>cleanup</c> handles must have the same corresponding argument and return types, except
            that the <c>cleanup</c> handle may omit trailing arguments. Also, the <c>cleanup</c> handle must have one or
            two extra leading parameters:&lt;ul&gt;
            &lt;li&gt;a <c>Throwable</c>, which will carry the exception thrown by the <c>target</c> handle (if any); and
            &lt;li&gt;a parameter of the same type as the return type of both <c>target</c> and <c>cleanup</c>, which will carry
            the result from the execution of the <c>target</c> handle.
            This parameter is not present if the <c>target</c> returns <c>void</c>.
            &lt;/ul&gt;</para>
          <para>The pseudocode for the resulting adapter looks as follows. In the code, <c>V</c> represents the result type of
            the <c>try/finally</c> construct; <c>A</c>/<c>a</c>, the types and values of arguments to the resulting
            handle consumed by the cleanup; and <c>B</c>/<c>b</c>, those of arguments to the resulting handle discarded by
            the cleanup.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            V target(A..., B...);
            V cleanup(Throwable, V, A...);
            V adapter(A... a, B... b) {
              V result = (zero value for V);
              Throwable throwable = null;
              try {
                result = target(a..., b...);
              } catch (Throwable t) {
                throwable = t;
                throw t;
              } finally {
                result = cleanup(throwable, result, a...);
              }
              return result;
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Note that the saved arguments (<c>a...</c> in the pseudocode) cannot
            be modified by execution of the target, and so are passed unchanged
            from the caller to the cleanup, if it is invoked.</para>
          <para>The target and cleanup must return the same type, even if the cleanup
            always throws.
            To create such a throwing cleanup, compose the cleanup logic
            with <c>#throwException throwException</c>,
            in order to create a method handle of the correct return type.</para>
          <para>Note that <c>tryFinally</c> never converts exceptions into normal returns.
            In rare cases where exceptions must be converted in that way, first wrap
            the target with <c>#catchException(MethodHandle, Class, MethodHandle)</c>
            to capture an outgoing exception, and then wrap with <c>tryFinally</c>.</para>
          <para>It is recommended that the first parameter type of <c>cleanup</c> be
            declared <c>Throwable</c> rather than a narrower subtype.  This ensures
            <c>cleanup</c> will always be invoked with whatever exception that
            <c>target</c> throws.  Declaring a narrower type may result in a
            <c>ClassCastException</c> being thrown by the <c>try-finally</c>
            handle if the type of the exception thrown by <c>target</c> is not
            assignable to the first parameter type of <c>cleanup</c>.  Note that
            various exception types of <c>VirtualMachineError</c>,
            <c>LinkageError</c>, and <c>RuntimeException</c> can in principle be
            thrown by almost any kind of Java code, and a finally clause that
            catches (say) only <c>IOException</c> would mask any of the others
            behind a <c>ClassCastException</c>.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#tryFinally(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.tryFinally(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VarHandleExactInvoker">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? VarHandleExactInvoker (Java.Lang.Invoke.VarHandle.AccessMode? accessMode, Java.Lang.Invoke.MethodType? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle VarHandleExactInvoker(class Java.Lang.Invoke.VarHandle/AccessMode accessMode, class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.VarHandleExactInvoker(Java.Lang.Invoke.VarHandle.AccessMode,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="static member VarHandleExactInvoker : Java.Lang.Invoke.VarHandle.AccessMode * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.VarHandleExactInvoker (accessMode, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("varHandleExactInvoker", "(Ljava/lang/invoke/VarHandle$AccessMode;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("varHandleExactInvoker", "(Ljava/lang/invoke/VarHandle$AccessMode;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accessMode" Type="Java.Lang.Invoke.VarHandle+AccessMode" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="accessMode">To be added.</param>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VarHandleInvoker">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? VarHandleInvoker (Java.Lang.Invoke.VarHandle.AccessMode? accessMode, Java.Lang.Invoke.MethodType? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle VarHandleInvoker(class Java.Lang.Invoke.VarHandle/AccessMode accessMode, class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.VarHandleInvoker(Java.Lang.Invoke.VarHandle.AccessMode,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="static member VarHandleInvoker : Java.Lang.Invoke.VarHandle.AccessMode * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.VarHandleInvoker (accessMode, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("varHandleInvoker", "(Ljava/lang/invoke/VarHandle$AccessMode;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("varHandleInvoker", "(Ljava/lang/invoke/VarHandle$AccessMode;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accessMode" Type="Java.Lang.Invoke.VarHandle+AccessMode" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="accessMode">To be added.</param>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WhileLoop">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? WhileLoop (Java.Lang.Invoke.MethodHandle? init, Java.Lang.Invoke.MethodHandle? pred, Java.Lang.Invoke.MethodHandle? body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle WhileLoop(class Java.Lang.Invoke.MethodHandle init, class Java.Lang.Invoke.MethodHandle pred, class Java.Lang.Invoke.MethodHandle body) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.WhileLoop(Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle,Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="static member WhileLoop : Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle * Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.WhileLoop (init, pred, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("whileLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("whileLoop", "(Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="init" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="pred" Type="Java.Lang.Invoke.MethodHandle" />
        <Parameter Name="body" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="init">optional initializer, providing the initial value of the loop variable.
                        May be <c>null</c>, implying a default initial value.  See above for other constraints.</param>
        <param name="pred">condition for the loop, which may not be <c>null</c>. Its result type must be <c>boolean</c>. See
                        above for other constraints.</param>
        <param name="body">body of the loop, which may not be <c>null</c>. It controls the loop parameters and result type.
                        See above for other constraints.</param>
        <summary>Constructs a <c>while</c> loop from an initializer, a body, and a predicate.</summary>
        <returns>a method handle implementing the <c>while</c> loop as described by the arguments.</returns>
        <remarks>
          <para>Constructs a <c>while</c> loop from an initializer, a body, and a predicate.
            This is a convenience wrapper for the #loop(MethodHandle[][]) generic loop combinator.</para>
          <para>The <c>pred</c> handle describes the loop condition; and <c>body</c>, its body. The loop resulting from this
            method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate
            evaluates to <c>true</c>).
            The loop will terminate once the predicate evaluates to <c>false</c> (the body will not be executed in this case).</para>
          <para>The <c>init</c> handle describes the initial value of an additional optional loop-local variable.
            In each iteration, this loop-local variable, if present, will be passed to the <c>body</c>
            and updated with the value returned from its invocation. The result of loop execution will be
            the final value of the additional loop-local variable (if present).</para>
          <para>The following rules hold for these argument handles:&lt;ul&gt;
            &lt;li&gt;The <c>body</c> handle must not be <c>null</c>; its type must be of the form
            <c>(V A...)V</c>, where <c>V</c> is non-<c>void</c>, or else <c>(A...)void</c>.
            (In the <c>void</c> case, we assign the type <c>void</c> to the name <c>V</c>,
            and we will write <c>(V A...)V</c> with the understanding that a <c>void</c> type <c>V</c>
            is quietly dropped from the parameter list, leaving <c>(A...)V</c>.)
            &lt;li&gt;The parameter list <c>(V A...)</c> of the body is called the &lt;em&gt;internal parameter list&lt;/em&gt;.
            It will constrain the parameter lists of the other loop parts.
            &lt;li&gt;If the iteration variable type <c>V</c> is dropped from the internal parameter list, the resulting shorter
            list <c>(A...)</c> is called the &lt;em&gt;external parameter list&lt;/em&gt;.
            &lt;li&gt;The body return type <c>V</c>, if non-<c>void</c>, determines the type of an
            additional state variable of the loop.
            The body must both accept and return a value of this type <c>V</c>.
            &lt;li&gt;If <c>init</c> is non-<c>null</c>, it must have return type <c>V</c>.
            Its parameter list (of some form &lt;c&gt;(A*)&lt;/c&gt;) must be
            effectively identical
            to the external parameter list <c>(A...)</c>.
            &lt;li&gt;If <c>init</c> is <c>null</c>, the loop variable will be initialized to its
            #empty default value.
            &lt;li&gt;The <c>pred</c> handle must not be <c>null</c>.  It must have <c>boolean</c> as its return type.
            Its parameter list (either empty or of the form <c>(V A*)</c>) must be
            effectively identical to the internal parameter list.
            &lt;/ul&gt;</para>
          <para>The resulting loop handle's result type and parameter signature are determined as follows:&lt;ul&gt;
            &lt;li&gt;The loop handle's result type is the result type <c>V</c> of the body.
            &lt;li&gt;The loop handle's parameter types are the types <c>(A...)</c>,
            from the external parameter list.
            &lt;/ul&gt;</para>
          <para>Here is pseudocode for the resulting loop handle. In the code, <c>V</c>/<c>v</c> represent the type / value of
            the sole loop variable as well as the result type of the loop; and <c>A</c>/<c>a</c>, that of the argument
            passed to the loop.
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            V init(A...);
            boolean pred(V, A...);
            V body(V, A...);
            V whileLoop(A... a...) {
              V v = init(a...);
              while (pred(v, a...)) {
                v = body(v, a...);
              }
              return v;
            }
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#whileLoop(java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle,%20java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.whileLoop(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static Java.Lang.Invoke.MethodHandle? Zero (Java.Lang.Class? type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Java.Lang.Invoke.MethodHandle Zero(class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Zero(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="static member Zero : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="Java.Lang.Invoke.MethodHandles.Zero type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("zero", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("zero", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="type">the expected return type of the desired method handle</param>
        <summary>Produces a constant method handle of the requested return type which
            returns the default value for that type every time it is invoked.</summary>
        <returns>a constant method handle that takes no arguments
                    and returns the default value of the given type (or void, if the type is void)</returns>
        <remarks>
          <para>Produces a constant method handle of the requested return type which
            returns the default value for that type every time it is invoked.
            The resulting constant method handle will have no side effects.</para>
          <para>The returned method handle is equivalent to <c>empty(methodType(type))</c>.
            It is also equivalent to <c>explicitCastArguments(constant(Object.class, null), methodType(type))</c>,
            since <c>explicitCastArguments</c> converts <c>null</c> to default values.</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles#zero(java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.zero(java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
