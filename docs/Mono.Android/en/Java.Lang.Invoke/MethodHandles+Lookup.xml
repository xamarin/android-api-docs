<Type Name="MethodHandles+Lookup" FullName="Java.Lang.Invoke.MethodHandles+Lookup">
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MethodHandles.Lookup&#xA;Inherits Object" />
  <TypeSignature Language="C++ CLI" Value="public: ref class MethodHandles::Lookup sealed : Java::Lang::Object" />
  <TypeSignature Language="C#" Value="public sealed class MethodHandles.Lookup : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi sealed beforefieldinit MethodHandles/Lookup extends Java.Lang.Object" />
  <TypeSignature Language="DocId" Value="T:Java.Lang.Invoke.MethodHandles.Lookup" />
  <TypeSignature Language="F#" Value="type MethodHandles.Lookup = class&#xA;    inherit Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Android.Runtime.Register("java/lang/invoke/MethodHandles$Lookup", ApiSince=26, DoNotGenerateAcw=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;Android.Runtime.Register("java/lang/invoke/MethodHandles$Lookup", ApiSince=26, DoNotGenerateAcw=true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
            when the creation requires access checking.</summary>
    <remarks>
      <para>A &lt;em&gt;lookup object&lt;/em&gt; is a factory for creating method handles,
            when the creation requires access checking.
            Method handles do not perform
            access checks when they are called, but rather when they are created.
            Therefore, method handle access
            restrictions must be enforced when a method handle is created.
            The caller class against which those restrictions are enforced
            is known as the #lookupClass lookup class.</para>
      <para>A lookup class which needs to create method handles will call
            <c>#lookup MethodHandles.lookup</c> to create a factory for itself.
            When the <c>Lookup</c> factory object is created, the identity of the lookup class is
            determined, and securely stored in the <c>Lookup</c> object.
            The lookup class (or its delegates) may then use factory methods
            on the <c>Lookup</c> object to create method handles for access-checked members.
            This includes all methods, constructors, and fields which are allowed to the lookup class,
            even private ones.
            
            &lt;h1&gt;"lookups"&gt;Lookup Factory Methods&lt;/h1&gt;
            The factory methods on a <c>Lookup</c> object correspond to all major
            use cases for methods, constructors, and fields.
            Each method handle created by a factory method is the functional
            equivalent of a particular &lt;em&gt;bytecode behavior&lt;/em&gt;.
            (Bytecode behaviors are described in section 5.4.3.5 of the Java Virtual Machine Specification.)
            Here is a summary of the correspondence between these factory methods and
            the behavior the resulting method handles:
            &lt;table border=1 cellpadding=5 summary="lookup method behaviors"&gt;
            &lt;tr&gt;
                &lt;th&gt;"equiv"&gt;lookup expression&lt;/th&gt;
                &lt;th&gt;member&lt;/th&gt;
                &lt;th&gt;bytecode behavior&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findGetter lookup.findGetter(C.class,"f",FT.class)</c>&lt;/td&gt;
                &lt;td&gt;<c>FT f;</c>&lt;/td&gt;&lt;td&gt;<c>(T) this.f;</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findStaticGetter lookup.findStaticGetter(C.class,"f",FT.class)</c>&lt;/td&gt;
                &lt;td&gt;<c>static</c>&lt;br&gt;<c>FT f;</c>&lt;/td&gt;&lt;td&gt;<c>(T) C.f;</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findSetter lookup.findSetter(C.class,"f",FT.class)</c>&lt;/td&gt;
                &lt;td&gt;<c>FT f;</c>&lt;/td&gt;&lt;td&gt;<c>this.f = x;</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findStaticSetter lookup.findStaticSetter(C.class,"f",FT.class)</c>&lt;/td&gt;
                &lt;td&gt;<c>static</c>&lt;br&gt;<c>FT f;</c>&lt;/td&gt;&lt;td&gt;<c>C.f = arg;</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findVirtual lookup.findVirtual(C.class,"m",MT)</c>&lt;/td&gt;
                &lt;td&gt;<c>T m(A*);</c>&lt;/td&gt;&lt;td&gt;<c>(T) this.m(arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findStatic lookup.findStatic(C.class,"m",MT)</c>&lt;/td&gt;
                &lt;td&gt;<c>static</c>&lt;br&gt;<c>T m(A*);</c>&lt;/td&gt;&lt;td&gt;<c>(T) C.m(arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findSpecial lookup.findSpecial(C.class,"m",MT,this.class)</c>&lt;/td&gt;
                &lt;td&gt;<c>T m(A*);</c>&lt;/td&gt;&lt;td&gt;<c>(T) super.m(arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#findConstructor lookup.findConstructor(C.class,MT)</c>&lt;/td&gt;
                &lt;td&gt;<c>C(A*);</c>&lt;/td&gt;&lt;td&gt;<c>new C(arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#unreflectGetter lookup.unreflectGetter(aField)</c>&lt;/td&gt;
                &lt;td&gt;(<c>static</c>)?&lt;br&gt;<c>FT f;</c>&lt;/td&gt;&lt;td&gt;<c>(FT) aField.get(thisOrNull);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#unreflectSetter lookup.unreflectSetter(aField)</c>&lt;/td&gt;
                &lt;td&gt;(<c>static</c>)?&lt;br&gt;<c>FT f;</c>&lt;/td&gt;&lt;td&gt;<c>aField.set(thisOrNull, arg);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)</c>&lt;/td&gt;
                &lt;td&gt;(<c>static</c>)?&lt;br&gt;<c>T m(A*);</c>&lt;/td&gt;&lt;td&gt;<c>(T) aMethod.invoke(thisOrNull, arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#unreflectConstructor lookup.unreflectConstructor(aConstructor)</c>&lt;/td&gt;
                &lt;td&gt;<c>C(A*);</c>&lt;/td&gt;&lt;td&gt;<c>(C) aConstructor.newInstance(arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;<c>java.lang.invoke.MethodHandles.Lookup#unreflect lookup.unreflect(aMethod)</c>&lt;/td&gt;
                &lt;td&gt;(<c>static</c>)?&lt;br&gt;<c>T m(A*);</c>&lt;/td&gt;&lt;td&gt;<c>(T) aMethod.invoke(thisOrNull, arg*);</c>&lt;/td&gt;
            &lt;/tr&gt;
            &lt;/table&gt;
            
            Here, the type <c>C</c> is the class or interface being searched for a member,
            documented as a parameter named <c>refc</c> in the lookup methods.
            The method type <c>MT</c> is composed from the return type <c>T</c>
            and the sequence of argument types <c>A*</c>.
            The constructor also has a sequence of argument types <c>A*</c> and
            is deemed to return the newly-created object of type <c>C</c>.
            Both <c>MT</c> and the field type <c>FT</c> are documented as a parameter named <c>type</c>.
            The formal parameter <c>this</c> stands for the self-reference of type <c>C</c>;
            if it is present, it is always the leading argument to the method handle invocation.
            (In the case of some <c>protected</c> members, <c>this</c> may be
            restricted in type to the lookup class; see below.)
            The name <c>arg</c> stands for all the other method handle arguments.
            In the code examples for the Core Reflection API, the name <c>thisOrNull</c>
            stands for a null reference if the accessed method or field is static,
            and <c>this</c> otherwise.
            The names <c>aMethod</c>, <c>aField</c>, and <c>aConstructor</c> stand
            for reflective objects corresponding to the given members.</para>
      <para>In cases where the given member is of variable arity (i.e., a method or constructor)
            the returned method handle will also be of MethodHandle#asVarargsCollector variable arity.
            In all other cases, the returned method handle will be of fixed arity.
            &lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;Discussion:&lt;/em&gt;
            The equivalence between looked-up method handles and underlying
            class members and bytecode behaviors
            can break down in a few ways:
            &lt;ul style="font-size:smaller;"&gt;
            &lt;li&gt;If <c>C</c> is not symbolically accessible from the lookup class's loader,
            the lookup can still succeed, even when there is no equivalent
            Java expression or bytecoded constant.
            &lt;li&gt;Likewise, if <c>T</c> or <c>MT</c>
            is not symbolically accessible from the lookup class's loader,
            the lookup can still succeed.
            For example, lookups for <c>MethodHandle.invokeExact</c> and
            <c>MethodHandle.invoke</c> will always succeed, regardless of requested type.
            &lt;li&gt;If there is a security manager installed, it can forbid the lookup
            on various grounds (see below).
            By contrast, the <c>ldc</c> instruction on a <c>CONSTANT_MethodHandle</c>
            constant is not subject to security manager checks.
            &lt;li&gt;If the looked-up method has a
            very large arity,
            the method handle creation may fail, due to the method handle
            type having too many parameters.
            &lt;/ul&gt;
            
            &lt;h1&gt;"access"&gt;Access checking&lt;/h1&gt;
            Access checks are applied in the factory methods of <c>Lookup</c>,
            when a method handle is created.
            This is a key difference from the Core Reflection API, since
            <c>java.lang.reflect.Method#invoke java.lang.reflect.Method.invoke</c>
            performs access checking against every caller, on every call.</para>
      <para>All access checks start from a <c>Lookup</c> object, which
            compares its recorded lookup class against all requests to
            create method handles.
            A single <c>Lookup</c> object can be used to create any number
            of access-checked method handles, all checked against a single
            lookup class.</para>
      <para>A <c>Lookup</c> object can be shared with other trusted code,
            such as a metaobject protocol.
            A shared <c>Lookup</c> object delegates the capability
            to create method handles on private members of the lookup class.
            Even if privileged code uses the <c>Lookup</c> object,
            the access checking is confined to the privileges of the
            original lookup class.</para>
      <para>A lookup can fail, because
            the containing class is not accessible to the lookup class, or
            because the desired class member is missing, or because the
            desired class member is not accessible to the lookup class, or
            because the lookup object is not trusted enough to access the member.
            In any of these cases, a <c>ReflectiveOperationException</c> will be
            thrown from the attempted lookup.  The exact class will be one of
            the following:
            &lt;ul&gt;
            &lt;li&gt;NoSuchMethodException &amp;mdash; if a method is requested but does not exist
            &lt;li&gt;NoSuchFieldException &amp;mdash; if a field is requested but does not exist
            &lt;li&gt;IllegalAccessException &amp;mdash; if the member exists but an access check fails
            &lt;/ul&gt;</para>
      <para>In general, the conditions under which a method handle may be
            looked up for a method <c>M</c> are no more restrictive than the conditions
            under which the lookup class could have compiled, verified, and resolved a call to <c>M</c>.
            Where the JVM would raise exceptions like <c>NoSuchMethodError</c>,
            a method handle lookup will generally raise a corresponding
            checked exception, such as <c>NoSuchMethodException</c>.
            And the effect of invoking the method handle resulting from the lookup
            is exactly equivalent
            to executing the compiled, verified, and resolved call to <c>M</c>.
            The same point is true of fields and constructors.
            &lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;Discussion:&lt;/em&gt;
            Access checks only apply to named and reflected methods,
            constructors, and fields.
            Other method handle creation methods, such as
            <c>MethodHandle#asType MethodHandle.asType</c>,
            do not require any access checks, and are used
            independently of any <c>Lookup</c> object.</para>
      <para>If the desired member is <c>protected</c>, the usual JVM rules apply,
            including the requirement that the lookup class must be either be in the
            same package as the desired member, or must inherit that member.
            (See the Java Virtual Machine Specification, sections 4.9.2, 5.4.3.5, and 6.4.)
            In addition, if the desired member is a non-static field or method
            in a different package, the resulting method handle may only be applied
            to objects of the lookup class or one of its subclasses.
            This requirement is enforced by narrowing the type of the leading
            <c>this</c> parameter from <c>C</c>
            (which will necessarily be a superclass of the lookup class)
            to the lookup class itself.</para>
      <para>The JVM imposes a similar requirement on <c>invokespecial</c> instruction,
            that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
            the current class.  Again, this requirement is enforced by narrowing the
            type of the leading parameter to the resulting method handle.
            (See the Java Virtual Machine Specification, section 4.10.1.9.)</para>
      <para>The JVM represents constructors and static initializer blocks as internal methods
            with special names (<c>"&lt;init&gt;"</c> and <c>"&lt;clinit&gt;"</c>).
            The internal syntax of invocation instructions allows them to refer to such internal
            methods as if they were normal methods, but the JVM bytecode verifier rejects them.
            A lookup of such an internal method will produce a <c>NoSuchMethodException</c>.</para>
      <para>In some cases, access between nested classes is obtained by the Java compiler by creating
            an wrapper method to access a private method of another class
            in the same top-level declaration.
            For example, a nested class <c>C.D</c>
            can access private members within other related classes such as
            <c>C</c>, <c>C.D.E</c>, or <c>C.B</c>,
            but the Java compiler may need to generate wrapper methods in
            those related classes.  In such cases, a <c>Lookup</c> object on
            <c>C.E</c> would be unable to those private members.
            A workaround for this limitation is the <c>Lookup#in Lookup.in</c> method,
            which can transform a lookup on <c>C.E</c> into one on any of those other
            classes, without special elevation of privilege.</para>
      <para>The accesses permitted to a given lookup object may be limited,
            according to its set of <c>#lookupModes lookupModes</c>,
            to a subset of members normally accessible to the lookup class.
            For example, the <c>#publicLookup publicLookup</c>
            method produces a lookup object which is only allowed to access
            public members in public classes.
            The caller sensitive method <c>#lookup lookup</c>
            produces a lookup object with full capabilities relative to
            its caller class, to emulate all supported bytecode behaviors.
            Also, the <c>Lookup#in Lookup.in</c> method may produce a lookup object
            with fewer access modes than the original lookup object.
            
            &lt;p style="font-size:smaller;"&gt;
            "privacc"&gt;&lt;em&gt;Discussion of private access:&lt;/em&gt;
            We say that a lookup has &lt;em&gt;private access&lt;/em&gt;
            if its #lookupModes lookup modes
            include the possibility of accessing <c>private</c> members.
            As documented in the relevant methods elsewhere,
            only lookups with private access possess the following capabilities:
            &lt;ul style="font-size:smaller;"&gt;
            &lt;li&gt;access private fields, methods, and constructors of the lookup class
            &lt;li&gt;create method handles which invoke caller sensitive methods,
                such as <c>Class.forName</c>&lt;li&gt;create method handles which <c>Lookup#findSpecial emulate invokespecial</c> instructions
            &lt;li&gt;avoid package access checks
                for classes accessible to the lookup class
            &lt;li&gt;create <c>Lookup#in delegated lookup objects</c> which have private access to other classes
                within the same package member
            &lt;/ul&gt;
            &lt;p style="font-size:smaller;"&gt;
            Each of these permissions is a consequence of the fact that a lookup object
            with private access can be securely traced back to an originating class,
            whose bytecode behaviors and Java language access permissions
            can be reliably determined and emulated by method handles.
            
            &lt;h1&gt;"secmgr"&gt;Security manager interactions&lt;/h1&gt;
            Although bytecode instructions can only refer to classes in
            a related class loader, this API can search for methods in any
            class, as long as a reference to its <c>Class</c> object is
            available.  Such cross-loader references are also possible with the
            Core Reflection API, and are impossible to bytecode instructions
            such as <c>invokestatic</c> or <c>getfield</c>.
            There is a java.lang.SecurityManager security manager API
            to allow applications to check such cross-loader references.
            These checks apply to both the <c>MethodHandles.Lookup</c> API
            and the Core Reflection API
            (as found on <c>java.lang.Class Class</c>).</para>
      <para>If a security manager is present, member lookups are subject to
            additional checks.
            From one to three calls are made to the security manager.
            Any of these calls can refuse access by throwing a
            <c>java.lang.SecurityException SecurityException</c>.
            Define <c>smgr</c> as the security manager,
            <c>lookc</c> as the lookup class of the current lookup object,
            <c>refc</c> as the containing class in which the member
            is being sought, and <c>defc</c> as the class in which the
            member is actually defined.
            The value <c>lookc</c> is defined as &lt;em&gt;not present&lt;/em&gt;
            if the current lookup object does not have
            private access.
            The calls are made according to the following rules:
            &lt;ul&gt;
            &lt;li&gt;&lt;b&gt;Step 1:&lt;/b&gt;
                If <c>lookc</c> is not present, or if its class loader is not
                the same as or an ancestor of the class loader of <c>refc</c>,
                then <c>SecurityManager#checkPackageAccess
                smgr.checkPackageAccess(refcPkg)</c> is called,
                where <c>refcPkg</c> is the package of <c>refc</c>.
            &lt;li&gt;&lt;b&gt;Step 2:&lt;/b&gt;
                If the retrieved member is not public and
                <c>lookc</c> is not present, then
                <c>SecurityManager#checkPermission smgr.checkPermission</c>
                with <c>RuntimePermission("accessDeclaredMembers")</c> is called.
            &lt;li&gt;&lt;b&gt;Step 3:&lt;/b&gt;
                If the retrieved member is not public,
                and if <c>lookc</c> is not present,
                and if <c>defc</c> and <c>refc</c> are different,
                then <c>SecurityManager#checkPackageAccess
                smgr.checkPackageAccess(defcPkg)</c> is called,
                where <c>defcPkg</c> is the package of <c>defc</c>.
            &lt;/ul&gt;
            Security checks are performed after other access checks have passed.
            Therefore, the above rules presuppose a member that is public,
            or else that is being accessed from a lookup class that has
            rights to access the member.
            
            &lt;h1&gt;"callsens"&gt;Caller sensitive methods&lt;/h1&gt;
            A small number of Java methods have a special property called caller sensitivity.
            A &lt;em&gt;caller-sensitive&lt;/em&gt; method can behave differently depending on the
            identity of its immediate caller.</para>
      <para>If a method handle for a caller-sensitive method is requested,
            the general rules for bytecode behaviors apply,
            but they take account of the lookup class in a special way.
            The resulting method handle behaves as if it were called
            from an instruction contained in the lookup class,
            so that the caller-sensitive method detects the lookup class.
            (By contrast, the invoker of the method handle is disregarded.)
            Thus, in the case of caller-sensitive methods,
            different lookup classes may give rise to
            differently behaving method handles.</para>
      <para>In cases where the lookup object is
            <c>#publicLookup publicLookup()</c>,
            or some other lookup object without
            private access,
            the lookup class is disregarded.
            In such cases, no caller-sensitive method handle can be created,
            access is forbidden, and the lookup fails with an
            <c>IllegalAccessException</c>.
            &lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;Discussion:&lt;/em&gt;
            For example, the caller-sensitive method
            <c>java.lang.Class#forName(String) Class.forName(x)</c>
            can return varying classes or throw varying exceptions,
            depending on the class loader of the class that calls it.
            A public lookup of <c>Class.forName</c> will fail, because
            there is no reasonable way to determine its bytecode behavior.
            &lt;p style="font-size:smaller;"&gt;
            If an application caches method handles for broad sharing,
            it should use <c>publicLookup()</c> to create them.
            If there is a lookup of <c>Class.forName</c>, it will fail,
            and the application must take appropriate action in that case.
            It may be that a later lookup, perhaps during the invocation of a
            bootstrap method, can incorporate the specific identity
            of the caller, making the method accessible.
            &lt;p style="font-size:smaller;"&gt;
            The function <c>MethodHandles.lookup</c> is caller sensitive
            so that there can be a secure foundation for lookups.
            Nearly all other methods in the JSR 292 API rely on lookup
            objects to check access requests.</para>
      <para>
        <format type="text/html">
          <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup</code>.</a>
        </format>
      </para>
      <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Bind">
      <MemberSignature Language="VB.NET" Value="Public Function Bind (receiver As Object, name As String, type As MethodType) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ Bind(Java::Lang::Object ^ receiver, System::String ^ name, Java::Lang::Invoke::MethodType ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle Bind (Java.Lang.Object receiver, string name, Java.Lang.Invoke.MethodType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle Bind(class Java.Lang.Object receiver, string name, class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.Bind(Java.Lang.Object,System.String,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="member this.Bind : Java.Lang.Object * string * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.Bind (receiver, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("bind", "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("bind", "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiver" Type="Java.Lang.Object" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="receiver">the object from which the method is accessed</param>
        <param name="name">the name of the method</param>
        <param name="type">the type of the method, with the receiver argument omitted</param>
        <summary>Produces an early-bound method handle for a non-static method.</summary>
        <returns>the desired method handle</returns>
        <remarks>
          <para>Produces an early-bound method handle for a non-static method.
            The receiver must have a supertype <c>defc</c> in which a method
            of the given name and type is accessible to the lookup class.
            The method and all its argument types must be accessible to the lookup object.
            The type of the method handle will be that of the method,
            without any insertion of an additional receiver parameter.
            The given receiver will be bound into the method handle,
            so that every call to the method handle will invoke the
            requested method on the given receiver.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the method's variable arity modifier bit (<c>0x0080</c>) is set
            &lt;em&gt;and&lt;/em&gt; the trailing array argument is not the only argument.
            (If the trailing array argument is the only argument,
            the given receiver value will be bound to it.)</para>
          <para>This is equivalent to the following code:
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle mh0 = lookup().findVirtual(defc, name, type);
            MethodHandle mh1 = mh0.bindTo(receiver);
            MethodType mt1 = mh1.type();
            if (mh0.isVarargsCollector())
              mh1 = mh1.asVarargsCollector(mt1.parameterType(mt1.parameterCount()-1));
            return mh1;
            }</code>
          <para>&lt;/blockquote&gt;
            where <c>defc</c> is either <c>receiver.getClass()</c> or a super
            type of that class, in which the requested method is accessible
            to the lookup class.
            (Note that <c>bindTo</c> does not preserve variable arity.)</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#bind(java.lang.Object,%20java.lang.String,%20java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.bind(java.lang.Object, java.lang.String, java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindConstructor">
      <MemberSignature Language="VB.NET" Value="Public Function FindConstructor (refc As Class, type As MethodType) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindConstructor(Java::Lang::Class ^ refc, Java::Lang::Invoke::MethodType ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindConstructor (Java.Lang.Class refc, Java.Lang.Invoke.MethodType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindConstructor(class Java.Lang.Class refc, class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindConstructor(Java.Lang.Class,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="member this.FindConstructor : Java.Lang.Class * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindConstructor (refc, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findConstructor", "(Ljava/lang/Class;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findConstructor", "(Ljava/lang/Class;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="type">the type of the method, with the receiver argument omitted, and a void return type</param>
        <summary>Produces a method handle which creates an object and initializes it, using
            the constructor of the specified type.</summary>
        <returns>the desired method handle</returns>
        <remarks>
          <para>Produces a method handle which creates an object and initializes it, using
            the constructor of the specified type.
            The parameter types of the method handle will be those of the constructor,
            while the return type will be a reference to the constructor's class.
            The constructor and all its argument types must be accessible to the lookup object.</para>
          <para>The requested type must have a return type of <c>void</c>.
            (This is consistent with the JVM's treatment of constructor type descriptors.)</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the constructor's variable arity modifier bit (<c>0x0080</c>) is set.</para>
          <para>If the returned method handle is invoked, the constructor's class will
            be initialized, if it has not already been initialized.</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle MH_newArrayList = publicLookup().findConstructor(
              ArrayList.class, methodType(void.class, Collection.class));
            Collection orig = Arrays.asList("x", "y");
            Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
            assert(orig != copy);
            assertEquals(orig, copy);
            // a variable-arity constructor:
            MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
              ProcessBuilder.class, methodType(void.class, String[].class));
            ProcessBuilder pb = (ProcessBuilder)
              MH_newProcessBuilder.invoke("x", "y", "z");
            assertEquals("[x, y, z]", pb.command().toString());
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findConstructor(java.lang.Class%3C?%3E,%20java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findConstructor(java.lang.Class&lt;?&gt;, java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindGetter">
      <MemberSignature Language="VB.NET" Value="Public Function FindGetter (refc As Class, name As String, type As Class) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindGetter(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Class ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindGetter (Java.Lang.Class refc, string name, Java.Lang.Class type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindGetter(class Java.Lang.Class refc, string name, class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindGetter(Java.Lang.Class,System.String,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindGetter : Java.Lang.Class * string * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindGetter (refc, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findGetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findGetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="name">the field's name</param>
        <param name="type">the field's type</param>
        <summary>Produces a method handle giving read access to a non-static field.</summary>
        <returns>a method handle which can load values from the field</returns>
        <remarks>
          <para>Produces a method handle giving read access to a non-static field.
            The type of the method handle will have a return type of the field's
            value type.
            The method handle's single argument will be the instance containing
            the field.
            Access checking is performed immediately on behalf of the lookup class.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findGetter(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findGetter(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSetter">
      <MemberSignature Language="VB.NET" Value="Public Function FindSetter (refc As Class, name As String, type As Class) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindSetter(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Class ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindSetter (Java.Lang.Class refc, string name, Java.Lang.Class type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindSetter(class Java.Lang.Class refc, string name, class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindSetter(Java.Lang.Class,System.String,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindSetter : Java.Lang.Class * string * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindSetter (refc, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findSetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findSetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="name">the field's name</param>
        <param name="type">the field's type</param>
        <summary>Produces a method handle giving write access to a non-static field.</summary>
        <returns>a method handle which can store values into the field</returns>
        <remarks>
          <para>Produces a method handle giving write access to a non-static field.
            The type of the method handle will have a void return type.
            The method handle will take two arguments, the instance containing
            the field, and the value to be stored.
            The second argument will be of the field's value type.
            Access checking is performed immediately on behalf of the lookup class.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findSetter(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findSetter(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindSpecial">
      <MemberSignature Language="VB.NET" Value="Public Function FindSpecial (refc As Class, name As String, type As MethodType, specialCaller As Class) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindSpecial(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Invoke::MethodType ^ type, Java::Lang::Class ^ specialCaller);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindSpecial (Java.Lang.Class refc, string name, Java.Lang.Invoke.MethodType type, Java.Lang.Class specialCaller);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindSpecial(class Java.Lang.Class refc, string name, class Java.Lang.Invoke.MethodType type, class Java.Lang.Class specialCaller) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindSpecial(Java.Lang.Class,System.String,Java.Lang.Invoke.MethodType,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindSpecial : Java.Lang.Class * string * Java.Lang.Invoke.MethodType * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindSpecial (refc, name, type, specialCaller)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findSpecial", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findSpecial", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
        <Parameter Name="specialCaller" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="name">the name of the method (which must not be "&amp;lt;init&amp;gt;")</param>
        <param name="type">the type of the method, with the receiver argument omitted</param>
        <param name="specialCaller">the proposed calling class to perform the <c>invokespecial</c></param>
        <summary>Produces an early-bound method handle for a virtual method.</summary>
        <returns>the desired method handle</returns>
        <remarks>
          <para>Produces an early-bound method handle for a virtual method.
            It will bypass checks for overriding methods on the receiver,
            as if called from an <c>invokespecial</c>
            instruction from within the explicitly specified <c>specialCaller</c>.
            The type of the method handle will be that of the method,
            with a suitably restricted receiver type prepended.
            (The receiver type will be <c>specialCaller</c> or a subtype.)
            The method and all its argument types must be accessible
            to the lookup object.</para>
          <para>Before method resolution,
            if the explicitly specified caller class is not identical with the
            lookup class, or if this lookup object does not have
            private access
            privileges, the access fails.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the method's variable arity modifier bit (<c>0x0080</c>) is set.
            &lt;p style="font-size:smaller;"&gt;
            &lt;em&gt;(Note:  JVM internal methods named <c>"&lt;init&gt;"</c> are not visible to this API,
            even though the <c>invokespecial</c> instruction can refer to them
            in special circumstances.  Use <c>#findConstructor findConstructor</c>
            to access instance initialization methods in a safe manner.)&lt;/em&gt;</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            static class Listie extends ArrayList {
              public String toString() { return "[wee Listie]"; }
              static Lookup lookup() { return MethodHandles.lookup(); }
            }
            ...
            // no access to constructor via invokeSpecial:
            MethodHandle MH_newListie = Listie.lookup()
              .findConstructor(Listie.class, methodType(void.class));
            Listie l = (Listie) MH_newListie.invokeExact();
            try { assertEquals("impossible", Listie.lookup().findSpecial(
                    Listie.class, "&lt;init&gt;", methodType(void.class), Listie.class));
             } catch (NoSuchMethodException ex) { } // OK
            // access to super and self methods via invokeSpecial:
            MethodHandle MH_super = Listie.lookup().findSpecial(
              ArrayList.class, "toString" , methodType(String.class), Listie.class);
            MethodHandle MH_this = Listie.lookup().findSpecial(
              Listie.class, "toString" , methodType(String.class), Listie.class);
            MethodHandle MH_duper = Listie.lookup().findSpecial(
              Object.class, "toString" , methodType(String.class), Listie.class);
            assertEquals("[]", (String) MH_super.invokeExact(l));
            assertEquals(""+l, (String) MH_this.invokeExact(l));
            assertEquals("[]", (String) MH_duper.invokeExact(l)); // ArrayList method
            try { assertEquals("inaccessible", Listie.lookup().findSpecial(
                    String.class, "toString", methodType(String.class), Listie.class));
             } catch (IllegalAccessException ex) { } // OK
            Listie subl = new Listie() { public String toString() { return "[subclass]"; } };
            assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findSpecial(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.invoke.MethodType,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findSpecial(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindStatic">
      <MemberSignature Language="VB.NET" Value="Public Function FindStatic (refc As Class, name As String, type As MethodType) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindStatic(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Invoke::MethodType ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindStatic (Java.Lang.Class refc, string name, Java.Lang.Invoke.MethodType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindStatic(class Java.Lang.Class refc, string name, class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindStatic(Java.Lang.Class,System.String,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="member this.FindStatic : Java.Lang.Class * string * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindStatic (refc, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findStatic", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findStatic", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="refc">the class from which the method is accessed</param>
        <param name="name">the name of the method</param>
        <param name="type">the type of the method</param>
        <summary>Produces a method handle for a static method.</summary>
        <returns>the desired method handle</returns>
        <remarks>
          <para>Produces a method handle for a static method.
            The type of the method handle will be that of the method.
            (Since static methods do not take receivers, there is no
            additional receiver argument inserted into the method handle type,
            as there would be with <c>#findVirtual findVirtual</c> or <c>#findSpecial findSpecial</c>.)
            The method and all its argument types must be accessible to the lookup object.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the method's variable arity modifier bit (<c>0x0080</c>) is set.</para>
          <para>If the returned method handle is invoked, the method's class will
            be initialized, if it has not already been initialized.</para>
          <para>&lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
              "asList", methodType(List.class, Object[].class));
            assertEquals("[x, y]", MH_asList.invoke("x", "y").toString());
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findStatic(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findStatic(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindStaticGetter">
      <MemberSignature Language="VB.NET" Value="Public Function FindStaticGetter (refc As Class, name As String, type As Class) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindStaticGetter(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Class ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindStaticGetter (Java.Lang.Class refc, string name, Java.Lang.Class type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindStaticGetter(class Java.Lang.Class refc, string name, class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindStaticGetter(Java.Lang.Class,System.String,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindStaticGetter : Java.Lang.Class * string * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindStaticGetter (refc, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findStaticGetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findStaticGetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="name">the field's name</param>
        <param name="type">the field's type</param>
        <summary>Produces a method handle giving read access to a static field.</summary>
        <returns>a method handle which can load values from the field</returns>
        <remarks>
          <para>Produces a method handle giving read access to a static field.
            The type of the method handle will have a return type of the field's
            value type.
            The method handle will take no arguments.
            Access checking is performed immediately on behalf of the lookup class.</para>
          <para>If the returned method handle is invoked, the field's class will
            be initialized, if it has not already been initialized.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findStaticGetter(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findStaticGetter(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindStaticSetter">
      <MemberSignature Language="VB.NET" Value="Public Function FindStaticSetter (refc As Class, name As String, type As Class) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindStaticSetter(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Class ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindStaticSetter (Java.Lang.Class refc, string name, Java.Lang.Class type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindStaticSetter(class Java.Lang.Class refc, string name, class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindStaticSetter(Java.Lang.Class,System.String,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindStaticSetter : Java.Lang.Class * string * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindStaticSetter (refc, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findStaticSetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findStaticSetter", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="name">the field's name</param>
        <param name="type">the field's type</param>
        <summary>Produces a method handle giving write access to a static field.</summary>
        <returns>a method handle which can store values into the field</returns>
        <remarks>
          <para>Produces a method handle giving write access to a static field.
            The type of the method handle will have a void return type.
            The method handle will take a single
            argument, of the field's value type, the value to be stored.
            Access checking is performed immediately on behalf of the lookup class.</para>
          <para>If the returned method handle is invoked, the field's class will
            be initialized, if it has not already been initialized.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findStaticSetter(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findStaticSetter(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindStaticVarHandle">
      <MemberSignature Language="VB.NET" Value="Public Function FindStaticVarHandle (decl As Class, name As String, type As Class) As VarHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::VarHandle ^ FindStaticVarHandle(Java::Lang::Class ^ decl, System::String ^ name, Java::Lang::Class ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.VarHandle FindStaticVarHandle (Java.Lang.Class decl, string name, Java.Lang.Class type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.VarHandle FindStaticVarHandle(class Java.Lang.Class decl, string name, class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindStaticVarHandle(Java.Lang.Class,System.String,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindStaticVarHandle : Java.Lang.Class * string * Java.Lang.Class -&gt; Java.Lang.Invoke.VarHandle" Usage="lookup.FindStaticVarHandle (decl, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findStaticVarHandle", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findStaticVarHandle", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.VarHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="decl" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="decl">the class that declares the static field</param>
        <param name="name">the field's name</param>
        <param name="type">the field's type, of type <c>T</c></param>
        <summary>Produces a VarHandle giving access to a static field <c>name</c> of
            type <c>type</c> declared in a class of type <c>decl</c>.</summary>
        <returns>a VarHandle giving access to a static field</returns>
        <remarks>
          <para>Produces a VarHandle giving access to a static field <c>name</c> of
            type <c>type</c> declared in a class of type <c>decl</c>.
            The VarHandle's variable type is <c>type</c> and it has no
            coordinate types.</para>
          <para>Access checking is performed immediately on behalf of the lookup
            class.</para>
          <para>If the returned VarHandle is operated on, the declaring class will be
            initialized, if it has not already been initialized.</para>
          <para>Certain access modes of the returned VarHandle are unsupported under
            the following conditions:
            &lt;ul&gt;
            &lt;li&gt;if the field is declared <c>final</c>, then the write, atomic
                update, numeric atomic update, and bitwise atomic update access
                modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>byte</c>,
                <c>short</c>, <c>char</c>, <c>int</c>, <c>long</c>,
                <c>float</c>, or <c>double</c>, then numeric atomic update
                access modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>boolean</c>,
                <c>byte</c>, <c>short</c>, <c>char</c>, <c>int</c> or
                <c>long</c> then bitwise atomic update access modes are
                unsupported.
            &lt;/ul&gt;</para>
          <para>If the field is declared <c>volatile</c> then the returned VarHandle
            will override access to the field (effectively ignore the
            <c>volatile</c> declaration) in accordance to its specified
            access modes.</para>
          <para>If the field type is <c>float</c> or <c>double</c> then numeric
            and atomic update access modes compare values using their bitwise
            representation (see <c>Float#floatToRawIntBits</c> and
            <c>Double#doubleToRawLongBits</c>, respectively).</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findStaticVarHandle(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findStaticVarHandle(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindVarHandle">
      <MemberSignature Language="VB.NET" Value="Public Function FindVarHandle (recv As Class, name As String, type As Class) As VarHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::VarHandle ^ FindVarHandle(Java::Lang::Class ^ recv, System::String ^ name, Java::Lang::Class ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.VarHandle FindVarHandle (Java.Lang.Class recv, string name, Java.Lang.Class type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.VarHandle FindVarHandle(class Java.Lang.Class recv, string name, class Java.Lang.Class type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindVarHandle(Java.Lang.Class,System.String,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.FindVarHandle : Java.Lang.Class * string * Java.Lang.Class -&gt; Java.Lang.Invoke.VarHandle" Usage="lookup.FindVarHandle (recv, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findVarHandle", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findVarHandle", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.VarHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="recv" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="recv">the receiver class, of type <c>R</c>, that declares the
            non-static field</param>
        <param name="name">the field's name</param>
        <param name="type">the field's type, of type <c>T</c></param>
        <summary>Produces a VarHandle giving access to a non-static field <c>name</c>
            of type <c>type</c> declared in a class of type <c>recv</c>.</summary>
        <returns>a VarHandle giving access to non-static fields.</returns>
        <remarks>
          <para>Produces a VarHandle giving access to a non-static field <c>name</c>
            of type <c>type</c> declared in a class of type <c>recv</c>.
            The VarHandle's variable type is <c>type</c> and it has one
            coordinate type, <c>recv</c>.</para>
          <para>Access checking is performed immediately on behalf of the lookup
            class.</para>
          <para>Certain access modes of the returned VarHandle are unsupported under
            the following conditions:
            &lt;ul&gt;
            &lt;li&gt;if the field is declared <c>final</c>, then the write, atomic
                update, numeric atomic update, and bitwise atomic update access
                modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>byte</c>,
                <c>short</c>, <c>char</c>, <c>int</c>, <c>long</c>,
                <c>float</c>, or <c>double</c> then numeric atomic update
                access modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>boolean</c>,
                <c>byte</c>, <c>short</c>, <c>char</c>, <c>int</c> or
                <c>long</c> then bitwise atomic update access modes are
                unsupported.
            &lt;/ul&gt;</para>
          <para>If the field is declared <c>volatile</c> then the returned VarHandle
            will override access to the field (effectively ignore the
            <c>volatile</c> declaration) in accordance to its specified
            access modes.</para>
          <para>If the field type is <c>float</c> or <c>double</c> then numeric
            and atomic update access modes compare values using their bitwise
            representation (see <c>Float#floatToRawIntBits</c> and
            <c>Double#doubleToRawLongBits</c>, respectively).</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findVarHandle(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findVarHandle(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindVirtual">
      <MemberSignature Language="VB.NET" Value="Public Function FindVirtual (refc As Class, name As String, type As MethodType) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ FindVirtual(Java::Lang::Class ^ refc, System::String ^ name, Java::Lang::Invoke::MethodType ^ type);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle FindVirtual (Java.Lang.Class refc, string name, Java.Lang.Invoke.MethodType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle FindVirtual(class Java.Lang.Class refc, string name, class Java.Lang.Invoke.MethodType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.FindVirtual(Java.Lang.Class,System.String,Java.Lang.Invoke.MethodType)" />
      <MemberSignature Language="F#" Value="member this.FindVirtual : Java.Lang.Class * string * Java.Lang.Invoke.MethodType -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.FindVirtual (refc, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("findVirtual", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("findVirtual", "(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refc" Type="Java.Lang.Class" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="Java.Lang.Invoke.MethodType" />
      </Parameters>
      <Docs>
        <param name="refc">the class or interface from which the method is accessed</param>
        <param name="name">the name of the method</param>
        <param name="type">the type of the method, with the receiver argument omitted</param>
        <summary>Produces a method handle for a virtual method.</summary>
        <returns>the desired method handle</returns>
        <remarks>
          <para>Produces a method handle for a virtual method.
            The type of the method handle will be that of the method,
            with the receiver type (usually <c>refc</c>) prepended.
            The method and all its argument types must be accessible to the lookup object.</para>
          <para>When called, the handle will treat the first argument as a receiver
            and dispatch on the receiver's type to determine which method
            implementation to enter.
            (The dispatching action is identical with that performed by an
            <c>invokevirtual</c> or <c>invokeinterface</c> instruction.)</para>
          <para>The first argument will be of type <c>refc</c> if the lookup
            class has full privileges to access the member.  Otherwise
            the member must be <c>protected</c> and the first argument
            will be restricted in type to the lookup class.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the method's variable arity modifier bit (<c>0x0080</c>) is set.</para>
          <para>Because of the general equivalence between <c>invokevirtual</c>
            instructions and method handles produced by <c>findVirtual</c>,
            if the class is <c>MethodHandle</c> and the name string is
            <c>invokeExact</c> or <c>invoke</c>, the resulting
            method handle is equivalent to one produced by
            <c>java.lang.invoke.MethodHandles#exactInvoker MethodHandles.exactInvoker</c> or
            <c>java.lang.invoke.MethodHandles#invoker MethodHandles.invoker</c>
            with the same <c>type</c> argument.
            
            &lt;b&gt;Example:&lt;/b&gt;
            &lt;blockquote&gt;</para>
          <code lang="text/java">{@code
            import static java.lang.invoke.MethodHandles.*;
            import static java.lang.invoke.MethodType.*;
            ...
            MethodHandle MH_concat = publicLookup().findVirtual(String.class,
              "concat", methodType(String.class, String.class));
            MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
              "hashCode", methodType(int.class));
            MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
              "hashCode", methodType(int.class));
            assertEquals("xy", (String) MH_concat.invokeExact("x", "y"));
            assertEquals("xy".hashCode(), (int) MH_hashCode.invokeExact((Object)"xy"));
            assertEquals("xy".hashCode(), (int) MH_hashCode_String.invokeExact("xy"));
            // interface method:
            MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
              "subSequence", methodType(CharSequence.class, int.class, int.class));
            assertEquals("def", MH_subSequence.invoke("abcdefghi", 3, 6).toString());
            // constructor "internal method" must be accessed differently:
            MethodType MT_newString = methodType(void.class); //()V for new String()
            try { assertEquals("impossible", lookup()
                    .findVirtual(String.class, "&lt;init&gt;", MT_newString));
             } catch (NoSuchMethodException ex) { } // OK
            MethodHandle MH_newString = publicLookup()
              .findConstructor(String.class, MT_newString);
            assertEquals("", (String) MH_newString.invokeExact());
            }</code>
          <para>&lt;/blockquote&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#findVirtual(java.lang.Class%3C?%3E,%20java.lang.String,%20java.lang.invoke.MethodType)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.findVirtual(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="VB.NET" Value="Public Function In (requestedLookupClass As Class) As MethodHandles.Lookup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandles::Lookup ^ In(Java::Lang::Class ^ requestedLookupClass);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandles.Lookup In (Java.Lang.Class requestedLookupClass);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandles/Lookup In(class Java.Lang.Class requestedLookupClass) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.In(Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.In : Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandles.Lookup" Usage="lookup.In requestedLookupClass" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("in", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("in", "(Ljava/lang/Class;)Ljava/lang/invoke/MethodHandles$Lookup;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandles+Lookup</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedLookupClass" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="requestedLookupClass">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JniPeerMembers">
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property JniPeerMembers As JniPeerMembers" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Java::Interop::JniPeerMembers ^ JniPeerMembers { Java::Interop::JniPeerMembers ^ get(); };" />
      <MemberSignature Language="C#" Value="public override Java.Interop.JniPeerMembers JniPeerMembers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Interop.JniPeerMembers JniPeerMembers" />
      <MemberSignature Language="DocId" Value="P:Java.Lang.Invoke.MethodHandles.Lookup.JniPeerMembers" />
      <MemberSignature Language="F#" Value="member this.JniPeerMembers : Java.Interop.JniPeerMembers" Usage="Java.Lang.Invoke.MethodHandles.Lookup.JniPeerMembers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Interop.JniPeerMembers</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupClass">
      <MemberSignature Language="VB.NET" Value="Public Function LookupClass () As Class" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Class ^ LookupClass();" />
      <MemberSignature Language="C#" Value="public Java.Lang.Class LookupClass ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Class LookupClass() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.LookupClass" />
      <MemberSignature Language="F#" Value="member this.LookupClass : unit -&gt; Java.Lang.Class" Usage="lookup.LookupClass " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("lookupClass", "()Ljava/lang/Class;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("lookupClass", "()Ljava/lang/Class;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Class</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells which class is performing the lookup.</summary>
        <returns>the lookup class, on behalf of which this lookup object finds members</returns>
        <remarks>
          <para>Tells which class is performing the lookup.  It is this class against
             which checks are performed for visibility and access permissions.</para>
          <para>The class implies a maximum level of access permission,
             but the permissions may be additionally limited by the bitmask
             <c>#lookupModes lookupModes</c>, which controls whether non-public members
             can be accessed.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#lookupClass()" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.lookupClass()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupModes">
      <MemberSignature Language="VB.NET" Value="Public Function LookupModes () As MethodLookupModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodLookupModes LookupModes();" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodLookupModes LookupModes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype Java.Lang.Invoke.MethodLookupModes LookupModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.LookupModes" />
      <MemberSignature Language="F#" Value="member this.LookupModes : unit -&gt; Java.Lang.Invoke.MethodLookupModes" Usage="lookup.LookupModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("lookupModes", "()I", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("lookupModes", "()I", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodLookupModes</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[Android.Runtime.GeneratedEnum]</AttributeName>
            <AttributeName Language="F#">[&lt;Android.Runtime.GeneratedEnum&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tells which access-protection classes of members this lookup object can produce.</summary>
        <returns>the lookup modes, which limit the kinds of access performed by this lookup object</returns>
        <remarks>
          <para>Tells which access-protection classes of members this lookup object can produce.
             The result is a bit-mask of the bits
             #PUBLIC PUBLIC (0x01),
             #PRIVATE PRIVATE (0x02),
             #PROTECTED PROTECTED (0x04),
             and #PACKAGE PACKAGE (0x08).</para>
          <para>A freshly-created lookup object
             on the java.lang.invoke.MethodHandles#lookup() caller's class
             has all possible bits set, since the caller class can access all its own members.
             A lookup object on a new lookup class
             java.lang.invoke.MethodHandles.Lookup#in created from a previous lookup object
             may have some mode bits set to zero.
             The purpose of this is to restrict access via the new lookup object,
             so that it can access only names which can be reached by the original
             lookup object, and also by the new lookup class.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#lookupModes()" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.lookupModes()</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="VB.NET" Value="Public Const Package As MethodLookupModes  = 8" />
      <MemberSignature Language="C++ CLI" Value="public: Java::Lang::Invoke::MethodLookupModes Package = 8;" />
      <MemberSignature Language="C#" Value="public const Java.Lang.Invoke.MethodLookupModes Package = 8;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Java.Lang.Invoke.MethodLookupModes Package = (8)" />
      <MemberSignature Language="DocId" Value="F:Java.Lang.Invoke.MethodHandles.Lookup.Package" />
      <MemberSignature Language="F#" Value="val mutable Package : Java.Lang.Invoke.MethodLookupModes" Usage="Java.Lang.Invoke.MethodHandles.Lookup.Package" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("PACKAGE", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("PACKAGE", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodLookupModes</ReturnType>
      </ReturnValue>
      <MemberValue>8</MemberValue>
      <Docs>
        <summary>A single-bit mask representing <c>package</c> access (default access),
             which may contribute to the result of <c>#lookupModes lookupModes</c>.</summary>
        <remarks>
          <para>A single-bit mask representing <c>package</c> access (default access),
             which may contribute to the result of <c>#lookupModes lookupModes</c>.
             The value is <c>0x08</c>, which does not correspond meaningfully to
             any particular java.lang.reflect.Modifier modifier bit.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#PACKAGE" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.PACKAGE</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Private">
      <MemberSignature Language="VB.NET" Value="Public Const Private As MethodLookupModes  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: Java::Lang::Invoke::MethodLookupModes Private = 2;" />
      <MemberSignature Language="C#" Value="public const Java.Lang.Invoke.MethodLookupModes Private = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Java.Lang.Invoke.MethodLookupModes Private = (2)" />
      <MemberSignature Language="DocId" Value="F:Java.Lang.Invoke.MethodHandles.Lookup.Private" />
      <MemberSignature Language="F#" Value="val mutable Private : Java.Lang.Invoke.MethodLookupModes" Usage="Java.Lang.Invoke.MethodHandles.Lookup.Private" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("PRIVATE", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("PRIVATE", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodLookupModes</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>A single-bit mask representing <c>private</c> access,
             which may contribute to the result of <c>#lookupModes lookupModes</c>.</summary>
        <remarks>
          <para>A single-bit mask representing <c>private</c> access,
             which may contribute to the result of <c>#lookupModes lookupModes</c>.
             The value, <c>0x02</c>, happens to be the same as the value of the
             <c>private</c>java.lang.reflect.Modifier#PRIVATE modifier bit.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#PRIVATE" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.PRIVATE</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="VB.NET" Value="Public Const Protected As MethodLookupModes  = 4" />
      <MemberSignature Language="C++ CLI" Value="public: Java::Lang::Invoke::MethodLookupModes Protected = 4;" />
      <MemberSignature Language="C#" Value="public const Java.Lang.Invoke.MethodLookupModes Protected = 4;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Java.Lang.Invoke.MethodLookupModes Protected = (4)" />
      <MemberSignature Language="DocId" Value="F:Java.Lang.Invoke.MethodHandles.Lookup.Protected" />
      <MemberSignature Language="F#" Value="val mutable Protected : Java.Lang.Invoke.MethodLookupModes" Usage="Java.Lang.Invoke.MethodHandles.Lookup.Protected" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("PROTECTED", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("PROTECTED", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodLookupModes</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>A single-bit mask representing <c>protected</c> access,
             which may contribute to the result of <c>#lookupModes lookupModes</c>.</summary>
        <remarks>
          <para>A single-bit mask representing <c>protected</c> access,
             which may contribute to the result of <c>#lookupModes lookupModes</c>.
             The value, <c>0x04</c>, happens to be the same as the value of the
             <c>protected</c>java.lang.reflect.Modifier#PROTECTED modifier bit.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#PROTECTED" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.PROTECTED</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Public">
      <MemberSignature Language="VB.NET" Value="Public Const Public As MethodLookupModes  = 1" />
      <MemberSignature Language="C++ CLI" Value="public: Java::Lang::Invoke::MethodLookupModes Public = 1;" />
      <MemberSignature Language="C#" Value="public const Java.Lang.Invoke.MethodLookupModes Public = 1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Java.Lang.Invoke.MethodLookupModes Public = (1)" />
      <MemberSignature Language="DocId" Value="F:Java.Lang.Invoke.MethodHandles.Lookup.Public" />
      <MemberSignature Language="F#" Value="val mutable Public : Java.Lang.Invoke.MethodLookupModes" Usage="Java.Lang.Invoke.MethodHandles.Lookup.Public" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("PUBLIC", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("PUBLIC", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This constant will be removed in the future version. Use Java.Lang.Invoke.MethodLookupModes enum directly instead of this field.", true)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodLookupModes</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>A single-bit mask representing <c>public</c> access,
             which may contribute to the result of <c>#lookupModes lookupModes</c>.</summary>
        <remarks>
          <para>A single-bit mask representing <c>public</c> access,
             which may contribute to the result of <c>#lookupModes lookupModes</c>.
             The value, <c>0x01</c>, happens to be the same as the value of the
             <c>public</c>java.lang.reflect.Modifier#PUBLIC modifier bit.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#PUBLIC" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.PUBLIC</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RevealDirect">
      <MemberSignature Language="VB.NET" Value="Public Function RevealDirect (target As MethodHandle) As IMethodHandleInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::IMethodHandleInfo ^ RevealDirect(Java::Lang::Invoke::MethodHandle ^ target);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.IMethodHandleInfo RevealDirect (Java.Lang.Invoke.MethodHandle target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.IMethodHandleInfo RevealDirect(class Java.Lang.Invoke.MethodHandle target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.RevealDirect(Java.Lang.Invoke.MethodHandle)" />
      <MemberSignature Language="F#" Value="member this.RevealDirect : Java.Lang.Invoke.MethodHandle -&gt; Java.Lang.Invoke.IMethodHandleInfo" Usage="lookup.RevealDirect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("revealDirect", "(Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandleInfo;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("revealDirect", "(Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandleInfo;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.IMethodHandleInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="Java.Lang.Invoke.MethodHandle" />
      </Parameters>
      <Docs>
        <param name="target">a direct method handle to crack into symbolic reference components</param>
        <summary>Cracks a direct method handle
            created by this lookup object or a similar one.</summary>
        <returns>a symbolic reference which can be used to reconstruct this method handle from this lookup object</returns>
        <remarks>
          <para>Cracks a direct method handle
            created by this lookup object or a similar one.
            Security and access checks are performed to ensure that this lookup object
            is capable of reproducing the target method handle.
            This means that the cracking may fail if target is a direct method handle
            but was created by an unrelated lookup object.
            This can happen if the method handle is caller sensitive
            and was created by a lookup object for a different class.</para>
          <para>Added in 1.8.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#revealDirect(java.lang.invoke.MethodHandle)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.revealDirect(java.lang.invoke.MethodHandle)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property ThresholdClass As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property IntPtr ThresholdClass { IntPtr get(); };" />
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberSignature Language="DocId" Value="P:Java.Lang.Invoke.MethodHandles.Lookup.ThresholdClass" />
      <MemberSignature Language="F#" Value="member this.ThresholdClass : nativeint" Usage="Java.Lang.Invoke.MethodHandles.Lookup.ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property ThresholdType As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Type ^ ThresholdType { Type ^ get(); };" />
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberSignature Language="DocId" Value="P:Java.Lang.Invoke.MethodHandles.Lookup.ThresholdType" />
      <MemberSignature Language="F#" Value="member this.ThresholdType : Type" Usage="Java.Lang.Invoke.MethodHandles.Lookup.ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unreflect">
      <MemberSignature Language="VB.NET" Value="Public Function Unreflect (m As Method) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ Unreflect(Java::Lang::Reflect::Method ^ m);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle Unreflect (Java.Lang.Reflect.Method m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle Unreflect(class Java.Lang.Reflect.Method m) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.Unreflect(Java.Lang.Reflect.Method)" />
      <MemberSignature Language="F#" Value="member this.Unreflect : Java.Lang.Reflect.Method -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.Unreflect m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("unreflect", "(Ljava/lang/reflect/Method;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("unreflect", "(Ljava/lang/reflect/Method;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="Java.Lang.Reflect.Method" />
      </Parameters>
      <Docs>
        <param name="m">the reflected method</param>
        <summary>Makes a direct method handle
            to <i>m</i>, if the lookup class has permission.</summary>
        <returns>a method handle which can invoke the reflected method</returns>
        <remarks>
          <para>Makes a direct method handle
            to <i>m</i>, if the lookup class has permission.
            If <i>m</i> is non-static, the receiver argument is treated as an initial argument.
            If <i>m</i> is virtual, overriding is respected on every call.
            Unlike the Core Reflection API, exceptions are &lt;em&gt;not&lt;/em&gt; wrapped.
            The type of the method handle will be that of the method,
            with the receiver type prepended (but only if it is non-static).
            If the method's <c>accessible</c> flag is not set,
            access checking is performed immediately on behalf of the lookup class.
            If <i>m</i> is not public, do not share the resulting handle with untrusted parties.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the method's variable arity modifier bit (<c>0x0080</c>) is set.</para>
          <para>If <i>m</i> is static, and
            if the returned method handle is invoked, the method's class will
            be initialized, if it has not already been initialized.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#unreflect(java.lang.reflect.Method)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.unreflect(java.lang.reflect.Method)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreflectConstructor">
      <MemberSignature Language="VB.NET" Value="Public Function UnreflectConstructor (c As Constructor) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ UnreflectConstructor(Java::Lang::Reflect::Constructor ^ c);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle UnreflectConstructor (Java.Lang.Reflect.Constructor c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle UnreflectConstructor(class Java.Lang.Reflect.Constructor c) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.UnreflectConstructor(Java.Lang.Reflect.Constructor)" />
      <MemberSignature Language="F#" Value="member this.UnreflectConstructor : Java.Lang.Reflect.Constructor -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.UnreflectConstructor c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("unreflectConstructor", "(Ljava/lang/reflect/Constructor;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("unreflectConstructor", "(Ljava/lang/reflect/Constructor;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="Java.Lang.Reflect.Constructor" />
      </Parameters>
      <Docs>
        <param name="c">the reflected constructor</param>
        <summary>Produces a method handle for a reflected constructor.</summary>
        <returns>a method handle which can invoke the reflected constructor</returns>
        <remarks>
          <para>Produces a method handle for a reflected constructor.
            The type of the method handle will be that of the constructor,
            with the return type changed to the declaring class.
            The method handle will perform a <c>newInstance</c> operation,
            creating a new instance of the constructor's class on the
            arguments passed to the method handle.</para>
          <para>If the constructor's <c>accessible</c> flag is not set,
            access checking is performed immediately on behalf of the lookup class.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the constructor's variable arity modifier bit (<c>0x0080</c>) is set.</para>
          <para>If the returned method handle is invoked, the constructor's class will
            be initialized, if it has not already been initialized.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#unreflectConstructor(java.lang.reflect.Constructor%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.unreflectConstructor(java.lang.reflect.Constructor&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreflectGetter">
      <MemberSignature Language="VB.NET" Value="Public Function UnreflectGetter (f As Field) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ UnreflectGetter(Java::Lang::Reflect::Field ^ f);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle UnreflectGetter (Java.Lang.Reflect.Field f);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle UnreflectGetter(class Java.Lang.Reflect.Field f) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.UnreflectGetter(Java.Lang.Reflect.Field)" />
      <MemberSignature Language="F#" Value="member this.UnreflectGetter : Java.Lang.Reflect.Field -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.UnreflectGetter f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("unreflectGetter", "(Ljava/lang/reflect/Field;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("unreflectGetter", "(Ljava/lang/reflect/Field;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="Java.Lang.Reflect.Field" />
      </Parameters>
      <Docs>
        <param name="f">the reflected field</param>
        <summary>Produces a method handle giving read access to a reflected field.</summary>
        <returns>a method handle which can load values from the reflected field</returns>
        <remarks>
          <para>Produces a method handle giving read access to a reflected field.
            The type of the method handle will have a return type of the field's
            value type.
            If the field is static, the method handle will take no arguments.
            Otherwise, its single argument will be the instance containing
            the field.
            If the field's <c>accessible</c> flag is not set,
            access checking is performed immediately on behalf of the lookup class.</para>
          <para>If the field is static, and
            if the returned method handle is invoked, the field's class will
            be initialized, if it has not already been initialized.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#unreflectGetter(java.lang.reflect.Field)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.unreflectGetter(java.lang.reflect.Field)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreflectSetter">
      <MemberSignature Language="VB.NET" Value="Public Function UnreflectSetter (f As Field) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ UnreflectSetter(Java::Lang::Reflect::Field ^ f);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle UnreflectSetter (Java.Lang.Reflect.Field f);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle UnreflectSetter(class Java.Lang.Reflect.Field f) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.UnreflectSetter(Java.Lang.Reflect.Field)" />
      <MemberSignature Language="F#" Value="member this.UnreflectSetter : Java.Lang.Reflect.Field -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.UnreflectSetter f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("unreflectSetter", "(Ljava/lang/reflect/Field;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("unreflectSetter", "(Ljava/lang/reflect/Field;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="Java.Lang.Reflect.Field" />
      </Parameters>
      <Docs>
        <param name="f">the reflected field</param>
        <summary>Produces a method handle giving write access to a reflected field.</summary>
        <returns>a method handle which can store values into the reflected field</returns>
        <remarks>
          <para>Produces a method handle giving write access to a reflected field.
            The type of the method handle will have a void return type.
            If the field is static, the method handle will take a single
            argument, of the field's value type, the value to be stored.
            Otherwise, the two arguments will be the instance containing
            the field, and the value to be stored.
            If the field's <c>accessible</c> flag is not set,
            access checking is performed immediately on behalf of the lookup class.</para>
          <para>If the field is static, and
            if the returned method handle is invoked, the field's class will
            be initialized, if it has not already been initialized.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#unreflectSetter(java.lang.reflect.Field)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.unreflectSetter(java.lang.reflect.Field)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreflectSpecial">
      <MemberSignature Language="VB.NET" Value="Public Function UnreflectSpecial (m As Method, specialCaller As Class) As MethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::MethodHandle ^ UnreflectSpecial(Java::Lang::Reflect::Method ^ m, Java::Lang::Class ^ specialCaller);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.MethodHandle UnreflectSpecial (Java.Lang.Reflect.Method m, Java.Lang.Class specialCaller);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.MethodHandle UnreflectSpecial(class Java.Lang.Reflect.Method m, class Java.Lang.Class specialCaller) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.UnreflectSpecial(Java.Lang.Reflect.Method,Java.Lang.Class)" />
      <MemberSignature Language="F#" Value="member this.UnreflectSpecial : Java.Lang.Reflect.Method * Java.Lang.Class -&gt; Java.Lang.Invoke.MethodHandle" Usage="lookup.UnreflectSpecial (m, specialCaller)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("unreflectSpecial", "(Ljava/lang/reflect/Method;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("unreflectSpecial", "(Ljava/lang/reflect/Method;Ljava/lang/Class;)Ljava/lang/invoke/MethodHandle;", "", ApiSince=26)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android26.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android26.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.MethodHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="Java.Lang.Reflect.Method" />
        <Parameter Name="specialCaller" Type="Java.Lang.Class" />
      </Parameters>
      <Docs>
        <param name="m">the reflected method</param>
        <param name="specialCaller">the class nominally calling the method</param>
        <summary>Produces a method handle for a reflected method.</summary>
        <returns>a method handle which can invoke the reflected method</returns>
        <remarks>
          <para>Produces a method handle for a reflected method.
            It will bypass checks for overriding methods on the receiver,
            as if called from an <c>invokespecial</c>
            instruction from within the explicitly specified <c>specialCaller</c>.
            The type of the method handle will be that of the method,
            with a suitably restricted receiver type prepended.
            (The receiver type will be <c>specialCaller</c> or a subtype.)
            If the method's <c>accessible</c> flag is not set,
            access checking is performed immediately on behalf of the lookup class,
            as if <c>invokespecial</c> instruction were being linked.</para>
          <para>Before method resolution,
            if the explicitly specified caller class is not identical with the
            lookup class, or if this lookup object does not have
            private access
            privileges, the access fails.</para>
          <para>The returned method handle will have
            MethodHandle#asVarargsCollector variable arity if and only if
            the method's variable arity modifier bit (<c>0x0080</c>) is set.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#unreflectSpecial(java.lang.reflect.Method,%20java.lang.Class%3C?%3E)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.unreflectSpecial(java.lang.reflect.Method, java.lang.Class&lt;?&gt;)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnreflectVarHandle">
      <MemberSignature Language="VB.NET" Value="Public Function UnreflectVarHandle (f As Field) As VarHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Java::Lang::Invoke::VarHandle ^ UnreflectVarHandle(Java::Lang::Reflect::Field ^ f);" />
      <MemberSignature Language="C#" Value="public Java.Lang.Invoke.VarHandle UnreflectVarHandle (Java.Lang.Reflect.Field f);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Java.Lang.Invoke.VarHandle UnreflectVarHandle(class Java.Lang.Reflect.Field f) cil managed" />
      <MemberSignature Language="DocId" Value="M:Java.Lang.Invoke.MethodHandles.Lookup.UnreflectVarHandle(Java.Lang.Reflect.Field)" />
      <MemberSignature Language="F#" Value="member this.UnreflectVarHandle : Java.Lang.Reflect.Field -&gt; Java.Lang.Invoke.VarHandle" Usage="lookup.UnreflectVarHandle f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("unreflectVarHandle", "(Ljava/lang/reflect/Field;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("unreflectVarHandle", "(Ljava/lang/reflect/Field;)Ljava/lang/invoke/VarHandle;", "", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Invoke.VarHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="Java.Lang.Reflect.Field" />
      </Parameters>
      <Docs>
        <param name="f">the reflected field, with a field of type <c>T</c>, and
            a declaring class of type <c>R</c></param>
        <summary>Produces a VarHandle giving access to a reflected field <c>f</c>
            of type <c>T</c> declared in a class of type <c>R</c>.</summary>
        <returns>a VarHandle giving access to non-static fields or a static
            field</returns>
        <remarks>
          <para>Produces a VarHandle giving access to a reflected field <c>f</c>
            of type <c>T</c> declared in a class of type <c>R</c>.
            The VarHandle's variable type is <c>T</c>.
            If the field is non-static the VarHandle has one coordinate type,
            <c>R</c>.  Otherwise, the field is static, and the VarHandle has no
            coordinate types.</para>
          <para>Access checking is performed immediately on behalf of the lookup
            class, regardless of the value of the field's <c>accessible</c>
            flag.</para>
          <para>If the field is static, and if the returned VarHandle is operated
            on, the field's declaring class will be initialized, if it has not
            already been initialized.</para>
          <para>Certain access modes of the returned VarHandle are unsupported under
            the following conditions:
            &lt;ul&gt;
            &lt;li&gt;if the field is declared <c>final</c>, then the write, atomic
                update, numeric atomic update, and bitwise atomic update access
                modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>byte</c>,
                <c>short</c>, <c>char</c>, <c>int</c>, <c>long</c>,
                <c>float</c>, or <c>double</c> then numeric atomic update
                access modes are unsupported.
            &lt;li&gt;if the field type is anything other than <c>boolean</c>,
                <c>byte</c>, <c>short</c>, <c>char</c>, <c>int</c> or
                <c>long</c> then bitwise atomic update access modes are
                unsupported.
            &lt;/ul&gt;</para>
          <para>If the field is declared <c>volatile</c> then the returned VarHandle
            will override access to the field (effectively ignore the
            <c>volatile</c> declaration) in accordance to its specified
            access modes.</para>
          <para>If the field type is <c>float</c> or <c>double</c> then numeric
            and atomic update access modes compare values using their bitwise
            representation (see <c>Float#floatToRawIntBits</c> and
            <c>Double#doubleToRawLongBits</c>, respectively).</para>
          <para>Added in 9.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/java/lang/invoke/MethodHandles.Lookup#unreflectVarHandle(java.lang.reflect.Field)" title="Reference documentation">Java documentation for <code>java.lang.invoke.MethodHandles.Lookup.unreflectVarHandle(java.lang.reflect.Field)</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
