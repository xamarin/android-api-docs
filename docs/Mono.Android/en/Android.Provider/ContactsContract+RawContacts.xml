<Type Name="ContactsContract+RawContacts" FullName="Android.Provider.ContactsContract+RawContacts">
  <TypeSignature Language="C#" Value="public sealed class ContactsContract.RawContacts : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class nested public auto ansi sealed beforefieldinit ContactsContract/RawContacts extends Java.Lang.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("android/provider/ContactsContract$RawContacts", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Constants for the raw contacts table, which contains one row of contact
 information for each person in each synced account.</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">Constants for the raw contacts table, which contains one row of contact
 information for each person in each synced account. Sync adapters and
 contact management apps
 are the primary consumers of this API.

 <format type="text/html"><h3>Aggregation</h3></format><format type="text/html"><h3>Operations</h3></format><format type="text/html"><dl><dt><b>Insert</b></dt><dd><dt><b>Update</b></dt><dd /><dt><b>Delete</b></dt><dd>
 The invocation of <c>resolver.delete(...)</c>, does not immediately delete
 a raw contacts row.
 Instead, it sets the <c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.Deleted" /></c> flag on the raw contact and
 removes the raw contact from its aggregate contact.
 The sync adapter then deletes the raw contact from the server and
 finalizes phone-side deletion by calling <c>resolver.delete(...)</c>
 again and passing the <c><see cref="F:Android.Provider.ContactsContract.CallerIsSyncadapter" /></c> query parameter.Some sync adapters are read-only, meaning that they only sync server-side
 changes to the phone, but not the reverse.  If one of those raw contacts
 is marked for deletion, it will remain on the phone.  However it will be
 effectively invisible, because it will not be part of any aggregate contact.
 </dd><dt><b>Query</b></dt><dd /></dd></dl></format><format type="text/html"><h2>Columns</h2></format><format type="text/html"><table class="jd-sumtable"><tr><th colspan="4">RawContacts</th></tr><tr><td>long</td><td><c><see cref="F:Android.Provider.BaseColumns.Id" /></c></td><td>read-only</td><td>Row ID. Sync adapters should try to preserve row IDs during updates. In other words,
 it is much better for a sync adapter to update a raw contact rather than to delete and
 re-insert it.</td></tr><tr><td>long</td><td><c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.ContactId" /></c></td><td>read-only</td><td>The ID of the row in the <c><see cref="T:Android.Provider.ContactsContract+Contacts" /></c> table
 that this raw contact belongs
 to. Raw contacts are linked to contacts by the aggregation process, which can be controlled
 by the <c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.AggregationMode" /></c> field and <c><see cref="T:Android.Provider.ContactsContract+AggregationExceptions" /></c>.</td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.AggregationMode" /></c></td><td>read/write</td><td>A mechanism that allows programmatic control of the aggregation process. The allowed
 values are <c><see cref="F:Android.Provider.AggregationMode.Default" /></c>, <c><see cref="F:Android.Provider.AggregationMode.Disabled" /></c>
 and <c><see cref="F:Android.Provider.AggregationMode.Suspended" /></c>. See also <c><see cref="T:Android.Provider.ContactsContract+AggregationExceptions" /></c>.</td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.Deleted" /></c></td><td>read/write</td><td>The "deleted" flag: "0" by default, "1" if the row has been marked
 for deletion. When <c><see cref="M:Android.Content.ContentResolver.Delete(Android.Net.Uri, System.String, System.String)" /></c> is
 called on a raw contact, it is marked for deletion and removed from its
 aggregate contact. The sync adaptor deletes the raw contact on the server and
 then calls ContactResolver.delete once more, this time passing the
 <c><see cref="F:Android.Provider.ContactsContract.CallerIsSyncadapter" /></c> query parameter to finalize
 the data removal.</td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.ContactOptionsColumns.TimesContacted" /></c></td><td>read/write</td><td>The number of times the contact has been contacted. To have an effect
 on the corresponding value of the aggregate contact, this field
 should be set at the time the raw contact is inserted.
 After that, this value is typically updated via
 <c><see cref="M:Android.Provider.ContactsContract.Contacts.MarkAsContacted(Android.Content.ContentResolver, System.Int64)" /></c>.</td></tr><tr><td>long</td><td><c><see cref="F:Android.Provider.ContactsContract.ContactOptionsColumns.LastTimeContacted" /></c></td><td>read/write</td><td>The timestamp of the last time the contact was contacted. To have an effect
 on the corresponding value of the aggregate contact, this field
 should be set at the time the raw contact is inserted.
 After that, this value is typically updated via
 <c><see cref="M:Android.Provider.ContactsContract.Contacts.MarkAsContacted(Android.Content.ContentResolver, System.Int64)" /></c>.
 </td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.ContactOptionsColumns.Starred" /></c></td><td>read/write</td><td>An indicator for favorite contacts: '1' if favorite, '0' otherwise.
 Changing this field immediately affects the corresponding aggregate contact:
 if any raw contacts in that aggregate contact are starred, then the contact
 itself is marked as starred.</td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.ContactOptionsColumns.CustomRingtone" /></c></td><td>read/write</td><td>A custom ringtone associated with a raw contact. Typically this is the
 URI returned by an activity launched with the
 <c><see cref="F:Android.Media.RingtoneManager.ActionRingtonePicker" /></c> intent.
 To have an effect on the corresponding value of the aggregate contact, this field
 should be set at the time the raw contact is inserted. To set a custom
 ringtone on a contact, use the field <c><see cref="F:Android.Provider.ContactsContract.ContactOptionsColumns.CustomRingtone" /></c>
 instead.</td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.ContactOptionsColumns.SendToVoicemail" /></c></td><td>read/write</td><td>An indicator of whether calls from this raw contact should be forwarded
 directly to voice mail ('1') or not ('0'). To have an effect
 on the corresponding value of the aggregate contact, this field
 should be set at the time the raw contact is inserted.</td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.SyncColumns.AccountName" /></c></td><td>read/write-once</td><td>The name of the account instance to which this row belongs, which when paired with
 <c><see cref="F:Android.Provider.ContactsContract.SyncColumns.AccountType" /></c> identifies a specific account.
 For example, this will be the Gmail address if it is a Google account.
 It should be set at the time the raw contact is inserted and never
 changed afterwards.</td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.SyncColumns.AccountType" /></c></td><td>read/write-once</td><td /></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.DataSet" /></c></td><td>read/write-once</td><td /></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.SyncColumns.SourceId" /></c></td><td>read/write</td><td>String that uniquely identifies this row to its source account.
 Typically it is set at the time the raw contact is inserted and never
 changed afterwards. The one notable exception is a new raw contact: it
 will have an account name and type (and possibly a data set), but no
 source id. This indicates to the sync adapter that a new contact needs
 to be created server-side and its ID stored in the corresponding
 SOURCE_ID field on the phone.
 </td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.SyncColumns.Version" /></c></td><td>read-only</td><td>Version number that is updated whenever this row or its related data
 changes. This field can be used for optimistic locking of a raw contact.
 </td></tr><tr><td>int</td><td><c><see cref="F:Android.Provider.ContactsContract.SyncColumns.Dirty" /></c></td><td>read/write</td><td>Flag indicating that <c><see cref="F:Android.Provider.ContactsContract.SyncColumns.Version" /></c> has changed, and this row needs
 to be synchronized by its owning account.  The value is set to "1" automatically
 whenever the raw contact changes, unless the URI has the
 <c><see cref="F:Android.Provider.ContactsContract.CallerIsSyncadapter" /></c> query parameter specified.
 The sync adapter should always supply this query parameter to prevent
 unnecessary synchronization: user changes some data on the server,
 the sync adapter updates the contact on the phone (without the
 CALLER_IS_SYNCADAPTER flag) flag, which sets the DIRTY flag,
 which triggers a sync to bring the changes to the server.
 </td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.BaseSyncColumns.Sync1" /></c></td><td>read/write</td><td>Generic column provided for arbitrary use by sync adapters.
 The content provider
 stores this information on behalf of the sync adapter but does not
 interpret it in any way.
 </td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.BaseSyncColumns.Sync2" /></c></td><td>read/write</td><td>Generic column for use by sync adapters.
 </td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.BaseSyncColumns.Sync3" /></c></td><td>read/write</td><td>Generic column for use by sync adapters.
 </td></tr><tr><td>String</td><td><c><see cref="F:Android.Provider.ContactsContract.BaseSyncColumns.Sync4" /></c></td><td>read/write</td><td>Generic column for use by sync adapters.
 </td></tr></table></format></para>
      <para tool="javadoc-to-mdoc">
 As soon as a raw contact is inserted or whenever its constituent data
 changes, the provider will check if the raw contact matches other
 existing raw contacts and if so will aggregate it with those. The
 aggregation is reflected in the <c><see cref="T:Android.Provider.ContactsContract+RawContacts" /></c> table by the change of the
 <c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.ContactId" /></c> field, which is the reference to the aggregate contact.
 </para>
      <para tool="javadoc-to-mdoc">
 Changes to the structured name, organization, phone number, email address,
 or nickname trigger a re-aggregation.
 </para>
      <para tool="javadoc-to-mdoc">
 See also <c><see cref="T:Android.Provider.ContactsContract+AggregationExceptions" /></c> for a mechanism to control
 aggregation programmatically.
 </para>
      <para tool="javadoc-to-mdoc">
 Raw contacts can be inserted incrementally or in a batch.
 The incremental method is more traditional but less efficient.
 It should be used
 only if no <c><see cref="T:Android.Provider.ContactsContract+RawContacts+Data" /></c> values are available at the time the raw contact is created:
 <example><code lang="java">
 ContentValues values = new ContentValues();
 values.put(RawContacts.ACCOUNT_TYPE, accountType);
 values.put(RawContacts.ACCOUNT_NAME, accountName);
 Uri rawContactUri = getContentResolver().insert(RawContacts.CONTENT_URI, values);
 long rawContactId = ContentUris.parseId(rawContactUri);
 </code></example></para>
      <para tool="javadoc-to-mdoc">
 Once <c><see cref="T:Android.Provider.ContactsContract+RawContacts+Data" /></c> values become available, insert those.
 For example, here's how you would insert a name:

 <example><code lang="java">
 values.clear();
 values.put(Data.RAW_CONTACT_ID, rawContactId);
 values.put(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE);
 values.put(StructuredName.DISPLAY_NAME, "Mike Sullivan");
 getContentResolver().insert(Data.CONTENT_URI, values);
 </code></example></para>
      <para tool="javadoc-to-mdoc">
 The batch method is by far preferred.  It inserts the raw contact and its
 constituent data rows in a single database transaction
 and causes at most one aggregation pass.
 <example><code lang="java">
 ArrayList&lt;ContentProviderOperation&gt; ops =
          new ArrayList&lt;ContentProviderOperation&gt;();
 ...
 int rawContactInsertIndex = ops.size();
 ops.add(ContentProviderOperation.newInsert(RawContacts.CONTENT_URI)
          .withValue(RawContacts.ACCOUNT_TYPE, accountType)
          .withValue(RawContacts.ACCOUNT_NAME, accountName)
          .build());

 ops.add(ContentProviderOperation.newInsert(Data.CONTENT_URI)
          .withValueBackReference(Data.RAW_CONTACT_ID, rawContactInsertIndex)
          .withValue(Data.MIMETYPE, StructuredName.CONTENT_ITEM_TYPE)
          .withValue(StructuredName.DISPLAY_NAME, "Mike Sullivan")
          .build());

 getContentResolver().applyBatch(ContactsContract.AUTHORITY, ops);
 </code></example></para>
      <para tool="javadoc-to-mdoc">
 Note the use of <c><see cref="M:Android.Content.ContentProviderOperation.Builder.WithValueBackReference(System.String, System.Int32)" /></c>
 to refer to the as-yet-unknown index value of the raw contact inserted in the
 first operation.
 </para>
      <para tool="javadoc-to-mdoc">
 Raw contacts can be updated incrementally or in a batch.
 Batch mode should be used whenever possible.
 The procedures and considerations are analogous to those documented above for inserts.
 </para>
      <para tool="javadoc-to-mdoc">When a raw contact is deleted, all of its Data rows as well as StatusUpdates,
 AggregationExceptions, PhoneLookup rows are deleted automatically. When all raw
 contacts associated with a <c><see cref="T:Android.Provider.Contacts" /></c> row are deleted, the <c><see cref="T:Android.Provider.Contacts" /></c> row
 itself is also deleted automatically.
 </para>
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc">
 It is easy to find all raw contacts in a Contact:
 <example><code lang="java">
 Cursor c = getContentResolver().query(RawContacts.CONTENT_URI,
          new String[]{RawContacts._ID},
          RawContacts.CONTACT_ID + "=?",
          new String[]{String.valueOf(contactId)}, null);
 </code></example></para>
      <para tool="javadoc-to-mdoc">
 To find raw contacts within a specific account,
 you can either put the account name and type in the selection or pass them as query
 parameters.  The latter approach is preferable, especially when you can reuse the
 URI:
 <sample external-id="DE63557D9054224162099591BC9A33A2" /></para>
      <para tool="javadoc-to-mdoc">The best way to read a raw contact along with all the data associated with it is
 by using the <c><see cref="T:Android.Provider.ContactsContract+RawContacts+Entity" /></c> directory. If the raw contact has data rows,
 the Entity cursor will contain a row for each data row.  If the raw contact has no
 data rows, the cursor will still contain one row with the raw contact-level information.
 <example><code lang="java">
 Uri rawContactUri = ContentUris.withAppendedId(RawContacts.CONTENT_URI, rawContactId);
 Uri entityUri = Uri.withAppendedPath(rawContactUri, Entity.CONTENT_DIRECTORY);
 Cursor c = getContentResolver().query(entityUri,
          new String[]{RawContacts.SOURCE_ID, Entity.DATA_ID, Entity.MIMETYPE, Entity.DATA1},
          null, null, null);
 try {
     while (c.moveToNext()) {
         String sourceId = c.getString(0);
         if (!c.isNull(1)) {
             String mimeType = c.getString(2);
             String data = c.getString(3);
             ...
         }
     }
 } finally {
     c.close();
 }
 </code></example></para>
      <para tool="javadoc-to-mdoc">
 The type of account to which this row belongs, which when paired with
 <c><see cref="F:Android.Provider.ContactsContract.SyncColumns.AccountName" /></c> identifies a specific account.
 It should be set at the time the raw contact is inserted and never
 changed afterwards.
 </para>
      <para tool="javadoc-to-mdoc">
 To ensure uniqueness, new account types should be chosen according to the
 Java package naming convention.  Thus a Google account is of type "com.google".
 </para>
      <para tool="javadoc-to-mdoc">
 The data set within the account that this row belongs to.  This allows
 multiple sync adapters for the same account type to distinguish between
 each others' data.  The combination of <c><see cref="F:Android.Provider.ContactsContract.SyncColumns.AccountType" /></c>,
 <c><see cref="F:Android.Provider.ContactsContract.SyncColumns.AccountName" /></c>, and <c><see cref="F:Android.Provider.ContactsContract.RawContactsColumns.DataSet" /></c> identifies a set of data
 that is associated with a single sync adapter.
 </para>
      <para tool="javadoc-to-mdoc">
 This is empty by default, and is completely optional.  It only needs to
 be populated if multiple sync adapters are entering distinct data for
 the same account type and account name.
 </para>
      <para tool="javadoc-to-mdoc">
 It should be set at the time the raw contact is inserted and never
 changed afterwards.
 </para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 5" />
  </Docs>
  <Members>
    <Member MemberName="ContentItemType">
      <MemberSignature Language="C#" Value="public const string ContentItemType;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string ContentItemType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("CONTENT_ITEM_TYPE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The MIME type of the results when a raw contact ID is appended to <c><see cref="P:Android.Provider.ContactsContract.RawContacts.ContentUri" /></c>,
 yielding a subdirectory of a single person.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">The MIME type of the results when a raw contact ID is appended to <c><see cref="P:Android.Provider.ContactsContract.RawContacts.ContentUri" /></c>,
 yielding a subdirectory of a single person.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html#CONTENT_ITEM_TYPE" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public const string ContentType;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string ContentType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("CONTENT_TYPE")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The MIME type of the results from <c><see cref="P:Android.Provider.ContactsContract.RawContacts.ContentUri" /></c> when a specific
 ID value is not provided, and multiple raw contacts may be returned.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">The MIME type of the results from <c><see cref="P:Android.Provider.ContactsContract.RawContacts.ContentUri" /></c> when a specific
 ID value is not provided, and multiple raw contacts may be returned.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html#CONTENT_TYPE" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
      </Docs>
    </Member>
    <Member MemberName="ContentUri">
      <MemberSignature Language="C#" Value="public static Android.Net.Uri ContentUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Android.Net.Uri ContentUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("CONTENT_URI")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Net.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The content:// style URI for this table, which requests a directory of
 raw contact rows matching the selection criteria.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">The content:// style URI for this table, which requests a directory of
 raw contact rows matching the selection criteria.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html#CONTENT_URI" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
      </Docs>
    </Member>
    <Member MemberName="GetContactLookupUri">
      <MemberSignature Language="C#" Value="public static Android.Net.Uri GetContactLookupUri (Android.Content.ContentResolver resolver, Android.Net.Uri rawContactUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Android.Net.Uri GetContactLookupUri(class Android.Content.ContentResolver resolver, class Android.Net.Uri rawContactUri) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getContactLookupUri", "(Landroid/content/ContentResolver;Landroid/net/Uri;)Landroid/net/Uri;", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Net.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resolver" Type="Android.Content.ContentResolver" />
        <Parameter Name="rawContactUri" Type="Android.Net.Uri" />
      </Parameters>
      <Docs>
        <param name="resolver">To be added.</param>
        <param name="rawContactUri">To be added.</param>
        <summary>Build a <c><see cref="P:Android.Provider.ContactsContract.Contacts.ContentLookupUri" /></c>
 style <c><see cref="T:Android.Net.Uri" /></c> for the parent <c><see cref="T:Android.Provider.ContactsContract+Contacts" /></c>
 entry of the given <c><see cref="T:Android.Provider.ContactsContract+RawContacts" /></c> entry.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Build a <c><see cref="P:Android.Provider.ContactsContract.Contacts.ContentLookupUri" /></c>
 style <c><see cref="T:Android.Net.Uri" /></c> for the parent <c><see cref="T:Android.Provider.ContactsContract+Contacts" /></c>
 entry of the given <c><see cref="T:Android.Provider.ContactsContract+RawContacts" /></c> entry.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/provider/ContactsContract.RawContacts.html#getContactLookupUri(android.content.ContentResolver, android.net.Uri)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonvirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>