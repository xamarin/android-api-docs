<Type Name="FileObserver" FullName="Android.OS.FileObserver">
  <TypeSignature Language="C#" Value="public abstract class FileObserver : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit FileObserver extends Java.Lang.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("android/os/FileObserver", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="1">
    <summary>Monitors files (using )
 to fire an event after files are accessed or changed by by any process on
 the device (including this one).</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">Monitors files (using )
 to fire an event after files are accessed or changed by by any process on
 the device (including this one).  FileObserver is an abstract class;
 subclasses must implement the event handler <c><see cref="M:Android.OS.FileObserver.OnEvent(Android.OS.FileObserverEvents,System.String)" /></c>.

 </para>
      <para tool="javadoc-to-mdoc">Each FileObserver instance monitors a single file or directory.
 If a directory is monitored, events will be triggered for all files and
 subdirectories inside the monitored directory.</para>
      <para tool="javadoc-to-mdoc">An event mask is used to specify which changes or actions to report.
 Event type constants are used to describe the possible changes in the
 event mask as well as what actually happened in event callbacks.</para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <b>Warning</b>
        </format>: If a FileObserver is garbage collected, it
 will stop sending events.  To ensure you keep receiving events, you must
 keep a reference to the FileObserver instance from some other live object.</para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/android/os/FileObserver.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileObserver (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(Ljava/lang/String;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <summary>Equivalent to FileObserver(path, FileObserver.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Equivalent to FileObserver(path, FileObserver.ALL_EVENTS).
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/os/FileObserver.html#FileObserver(java.lang.String)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected FileObserver (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject{T,U}(System.IntPtr,Android.Runtime.JniHandleOwnership)" tool="ReplaceLinkValue" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileObserver (string path, Android.OS.FileObserverEvents mask);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype Android.OS.FileObserverEvents mask) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(Ljava/lang/String;I)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mask" Type="Android.OS.FileObserverEvents">
          <Attributes>
            <Attribute>
              <AttributeName>Android.Runtime.GeneratedEnum</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="mask">To be added.</param>
        <summary>Create a new file observer for a certain file or directory.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Create a new file observer for a certain file or directory.
 Monitoring does not start on creation!  You must call
 <c><see cref="M:Android.OS.FileObserver.StartWatching" /></c> before you will receive events.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/os/FileObserver.html#FileObserver(java.lang.String, int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnEvent">
      <MemberSignature Language="C#" Value="public abstract void OnEvent (Android.OS.FileObserverEvents e, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnEvent(valuetype Android.OS.FileObserverEvents e, string path) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onEvent", "(ILjava/lang/String;)V", "GetOnEvent_ILjava_lang_String_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="Android.OS.FileObserverEvents">
          <Attributes>
            <Attribute>
              <AttributeName>Android.Runtime.GeneratedEnum</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="e">The type of event which happened</param>
        <param name="path">The path, relative to the main monitored file or directory,
     of the file or directory which triggered the event
</param>
        <summary>The event handler, which must be implemented by subclasses.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">The event handler, which must be implemented by subclasses.

 </para>
          <para tool="javadoc-to-mdoc">This method is invoked on a special FileObserver thread.
 It runs independently of any threads, so take care to use appropriate
 synchronization!  Consider using <c><see cref="M:Android.OS.Handler.Post(Java.Lang.IRunnable)" /></c> to shift
 event handling work to the main thread to avoid concurrency problems.</para>
          <para tool="javadoc-to-mdoc">Event handlers must not throw exceptions.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/os/FileObserver.html#onEvent(int, java.lang.String)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="StartWatching">
      <MemberSignature Language="C#" Value="public virtual void StartWatching ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StartWatching() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("startWatching", "()V", "GetStartWatchingHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Start watching for events.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Start watching for events.  The monitored file or directory must exist at
 this time, or else no events will be reported (even if it appears later).
 If monitoring is already started, this call has no effect.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/os/FileObserver.html#startWatching()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="StopWatching">
      <MemberSignature Language="C#" Value="public virtual void StopWatching ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void StopWatching() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("stopWatching", "()V", "GetStopWatchingHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stop watching for events.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Stop watching for events.  Some events may be in process, so events
 may continue to be reported even after this method completes.  If
 monitoring is already stopped, this call has no effect.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/os/FileObserver.html#stopWatching()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonvirtualVoidMethod" tool="ReplaceLinkValue" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
