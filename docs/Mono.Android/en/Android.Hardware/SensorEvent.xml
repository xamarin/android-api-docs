<Type Name="SensorEvent" FullName="Android.Hardware.SensorEvent">
  <TypeSignature Language="VB.NET" Value="Public Class SensorEvent&#xA;Inherits Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class SensorEvent : Java::Lang::Object" />
  <TypeSignature Language="C#" Value="public class SensorEvent : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SensorEvent extends Java.Lang.Object" />
  <TypeSignature Language="DocId" Value="T:Android.Hardware.SensorEvent" />
  <TypeSignature Language="F#" Value="type SensorEvent = class&#xA;    inherit Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Android.Runtime.Register("android/hardware/SensorEvent", DoNotGenerateAcw=true)]</AttributeName>
      <AttributeName Language="F#">[&lt;Android.Runtime.Register("android/hardware/SensorEvent", DoNotGenerateAcw=true)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="3">
    <summary>This class represents a <c>android.hardware.Sensor Sensor</c> event and
            holds information such as the sensor's type, the time-stamp, accuracy and of
            course the sensor's <c>SensorEvent#values data</c>.</summary>
    <remarks>
      <para>This class represents a <c>android.hardware.Sensor Sensor</c> event and
            holds information such as the sensor's type, the time-stamp, accuracy and of
            course the sensor's <c>SensorEvent#values data</c>.</para>
      <para>&lt;u&gt;Definition of the coordinate system used by the SensorEvent API.&lt;/u&gt;</para>
      <para>The coordinate-system is defined relative to the screen of the phone in its
            default orientation. The axes are not swapped when the device's screen
            orientation changes.</para>
      <para>The X axis is horizontal and points to the right, the Y axis is vertical and
            points up and the Z axis points towards the outside of the front face of the
            screen. In this system, coordinates behind the screen have negative Z values.</para>
      <para>&lt;center&gt;&lt;img src="../../../images/axis_device.png"
            alt="Sensors coordinate-system diagram." border="0" /&gt;&lt;/center&gt;</para>
      <para>&lt;b&gt;Note:&lt;/b&gt; This coordinate system is different from the one used in the
            Android 2D APIs where the origin is in the top-left corner.</para>
      <para>
        <format type="text/html">
          <a href="https://developer.android.com/reference/android/hardware/SensorEvent" title="Reference documentation">Java documentation for <code>android.hardware.SensorEvent</code>.</a>
        </format>
      </para>
      <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
    </remarks>
    <since version="Added in API level 3" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="VB.NET" Value="Protected Sub New (javaReference As IntPtr, transfer As JniHandleOwnership)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SensorEvent(IntPtr javaReference, Android::Runtime::JniHandleOwnership transfer);" />
      <MemberSignature Language="C#" Value="protected SensorEvent (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Android.Hardware.SensorEvent.#ctor(System.IntPtr,Android.Runtime.JniHandleOwnership)" />
      <MemberSignature Language="F#" Value="new Android.Hardware.SensorEvent : nativeint * Android.Runtime.JniHandleOwnership -&gt; Android.Hardware.SensorEvent" Usage="new Android.Hardware.SensorEvent (javaReference, transfer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accuracy">
      <MemberSignature Language="VB.NET" Value="Public Property Accuracy As SensorStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Android::Hardware::SensorStatus Accuracy { Android::Hardware::SensorStatus get(); void set(Android::Hardware::SensorStatus value); };" />
      <MemberSignature Language="C#" Value="public Android.Hardware.SensorStatus Accuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Android.Hardware.SensorStatus Accuracy" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.Accuracy" />
      <MemberSignature Language="F#" Value="member this.Accuracy : Android.Hardware.SensorStatus with get, set" Usage="Android.Hardware.SensorEvent.Accuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("accuracy")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("accuracy")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Hardware.SensorStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The accuracy of this event.</summary>
        <value>To be added.</value>
        <remarks>
          <para>The accuracy of this event. See <c>android.hardware.SensorManager
            SensorManager</c> for details.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/android/hardware/SensorEvent#accuracy" title="Reference documentation">Java documentation for <code>android.hardware.SensorEvent.accuracy</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="FirstEventAfterDiscontinuity">
      <MemberSignature Language="VB.NET" Value="Public Property FirstEventAfterDiscontinuity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FirstEventAfterDiscontinuity { bool get(); void set(bool value); };" />
      <MemberSignature Language="C#" Value="public bool FirstEventAfterDiscontinuity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FirstEventAfterDiscontinuity" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.FirstEventAfterDiscontinuity" />
      <MemberSignature Language="F#" Value="member this.FirstEventAfterDiscontinuity : bool with get, set" Usage="Android.Hardware.SensorEvent.FirstEventAfterDiscontinuity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("firstEventAfterDiscontinuity", ApiSince=33)]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("firstEventAfterDiscontinuity", ApiSince=33)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.Versioning.SupportedOSPlatform("android33.0")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.Versioning.SupportedOSPlatform("android33.0")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Set to true when this is the first sensor event after a discontinuity.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Set to true when this is the first sensor event after a discontinuity.
            
            The exact meaning of discontinuity depends on the sensor type. For
            <c>android.hardware.Sensor#TYPE_HEAD_TRACKER Sensor.TYPE_HEAD_TRACKER</c>, this means that
            the reference frame has suddenly and significantly changed, for example if the head tracking
            device was removed then put back.
            
            Note that this concept is either not relevant to or not supported by most sensor types,
            <c>android.hardware.Sensor#TYPE_HEAD_TRACKER Sensor.TYPE_HEAD_TRACKER</c> being the notable
            exception.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/android/hardware/SensorEvent#firstEventAfterDiscontinuity" title="Reference documentation">Java documentation for <code>android.hardware.SensorEvent.firstEventAfterDiscontinuity</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JniPeerMembers">
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property JniPeerMembers As JniPeerMembers" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Java::Interop::JniPeerMembers ^ JniPeerMembers { Java::Interop::JniPeerMembers ^ get(); };" />
      <MemberSignature Language="C#" Value="public override Java.Interop.JniPeerMembers JniPeerMembers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Interop.JniPeerMembers JniPeerMembers" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.JniPeerMembers" />
      <MemberSignature Language="F#" Value="member this.JniPeerMembers : Java.Interop.JniPeerMembers" Usage="Android.Hardware.SensorEvent.JniPeerMembers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Mono.Android</AssemblyName>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Interop.JniPeerMembers</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sensor">
      <MemberSignature Language="VB.NET" Value="Public Property Sensor As Sensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Android::Hardware::Sensor ^ Sensor { Android::Hardware::Sensor ^ get(); void set(Android::Hardware::Sensor ^ value); };" />
      <MemberSignature Language="C#" Value="public Android.Hardware.Sensor? Sensor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Android.Hardware.Sensor Sensor" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.Sensor" />
      <MemberSignature Language="F#" Value="member this.Sensor : Android.Hardware.Sensor with get, set" Usage="Android.Hardware.SensorEvent.Sensor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("sensor")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("sensor")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Hardware.Sensor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The sensor that generated this event.</summary>
        <value>To be added.</value>
        <remarks>
          <para>The sensor that generated this event. See
            <c>android.hardware.SensorManager SensorManager</c> for details.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/android/hardware/SensorEvent#sensor" title="Reference documentation">Java documentation for <code>android.hardware.SensorEvent.sensor</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property ThresholdClass As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property IntPtr ThresholdClass { IntPtr get(); };" />
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.ThresholdClass" />
      <MemberSignature Language="F#" Value="member this.ThresholdClass : nativeint" Usage="Android.Hardware.SensorEvent.ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property ThresholdType As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property Type ^ ThresholdType { Type ^ get(); };" />
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.ThresholdType" />
      <MemberSignature Language="F#" Value="member this.ThresholdType : Type" Usage="Android.Hardware.SensorEvent.ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para>Portions of this page are modifications based on work created and shared by the <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format> and used according to terms described in the <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="VB.NET" Value="Public Property Timestamp As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long Timestamp { long get(); void set(long value); };" />
      <MemberSignature Language="C#" Value="public long Timestamp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Timestamp" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.Timestamp" />
      <MemberSignature Language="F#" Value="member this.Timestamp : int64 with get, set" Usage="Android.Hardware.SensorEvent.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("timestamp")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("timestamp")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The time in nanoseconds at which the event happened.</summary>
        <value>To be added.</value>
        <remarks>
          <para>The time in nanoseconds at which the event happened. For a given sensor,
            each new sensor event should be monotonically increasing using the same
            time base as <c>android.os.SystemClock#elapsedRealtimeNanos()</c>.</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/android/hardware/SensorEvent#timestamp" title="Reference documentation">Java documentation for <code>android.hardware.SensorEvent.timestamp</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="VB.NET" Value="Public Property Values As IList(Of Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;float&gt; ^ Values { System::Collections::Generic::IList&lt;float&gt; ^ get(); void set(System::Collections::Generic::IList&lt;float&gt; ^ value); };" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;float&gt;? Values { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;float32&gt; Values" />
      <MemberSignature Language="DocId" Value="P:Android.Hardware.SensorEvent.Values" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.IList&lt;single&gt; with get, set" Usage="Android.Hardware.SensorEvent.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
        <AssemblyName>Mono.Android</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[Android.Runtime.Register("values")]</AttributeName>
          <AttributeName Language="F#">[&lt;Android.Runtime.Register("values")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The length and contents of the <c>#values values</c> array depends on
            which <c>android.hardware.Sensor sensor</c> type is being monitored (see
            also <c>SensorEvent</c> for a definition of the coordinate system used).</summary>
        <value>To be added.</value>
        <remarks>
          <para>The length and contents of the <c>#values values</c> array depends on
            which <c>android.hardware.Sensor sensor</c> type is being monitored (see
            also <c>SensorEvent</c> for a definition of the coordinate system used).</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_ACCELEROMETER
            Sensor.TYPE_ACCELEROMETER</c>:&lt;/h4&gt; All values are in SI units (m/s^2)
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: Acceleration minus Gx on the x-axis &lt;/li&gt;
            &lt;li&gt; values[1]: Acceleration minus Gy on the y-axis &lt;/li&gt;
            &lt;li&gt; values[2]: Acceleration minus Gz on the z-axis &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>A sensor of this type measures the acceleration applied to the device
            (&lt;b&gt;Ad&lt;/b&gt;). Conceptually, it does so by measuring forces applied to the
            sensor itself (&lt;b&gt;Fs&lt;/b&gt;) using the relation:</para>
          <para>&lt;b&gt;&lt;center&gt;Ad = - &amp;#8721;Fs / mass&lt;/center&gt;&lt;/b&gt;</para>
          <para>In particular, the force of gravity is always influencing the measured
            acceleration:</para>
          <para>&lt;b&gt;&lt;center&gt;Ad = -g - &amp;#8721;F / mass&lt;/center&gt;&lt;/b&gt;</para>
          <para>For this reason, when the device is sitting on a table (and obviously not
            accelerating), the accelerometer reads a magnitude of &lt;b&gt;g&lt;/b&gt; = 9.81
            m/s^2</para>
          <para>Similarly, when the device is in free-fall and therefore dangerously
            accelerating towards to ground at 9.81 m/s^2, its accelerometer reads a
            magnitude of 0 m/s^2.</para>
          <para>It should be apparent that in order to measure the real acceleration of
            the device, the contribution of the force of gravity must be eliminated.
            This can be achieved by applying a <i>high-pass</i> filter. Conversely, a
            <i>low-pass</i> filter can be used to isolate the force of gravity.</para>
          <code lang="text/java">public void onSensorChanged(SensorEvent event)
                {
                     // alpha is calculated as t / (t + dT)
                     // with t, the low-pass filter's time-constant
                     // and dT, the event delivery rate
            
                     final float alpha = 0.8;
            
                     gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];
                     gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];
                     gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];
            
                     linear_acceleration[0] = event.values[0] - gravity[0];
                     linear_acceleration[1] = event.values[1] - gravity[1];
                     linear_acceleration[2] = event.values[2] - gravity[2];
                }
            </code>
          <para>&lt;u&gt;Examples&lt;/u&gt;:
            &lt;ul&gt;
            &lt;li&gt;When the device lies flat on a table and is pushed on its left side
            toward the right, the x acceleration value is positive.&lt;/li&gt;
            
            &lt;li&gt;When the device lies flat on a table, the acceleration value is
            +9.81, which correspond to the acceleration of the device (0 m/s^2) minus
            the force of gravity (-9.81 m/s^2).&lt;/li&gt;
            
            &lt;li&gt;When the device lies flat on a table and is pushed toward the sky
            with an acceleration of A m/s^2, the acceleration value is equal to
            A+9.81 which correspond to the acceleration of the device (+A m/s^2)
            minus the force of gravity (-9.81 m/s^2).&lt;/li&gt;
            &lt;/ul&gt;
            
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_MAGNETIC_FIELD
            Sensor.TYPE_MAGNETIC_FIELD</c>:&lt;/h4&gt;
            All values are in micro-Tesla (uT) and measure the ambient magnetic field
            in the X, Y and Z axis.
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_GYROSCOPE Sensor.TYPE_GYROSCOPE</c>:
            &lt;/h4&gt; All values are in radians/second and measure the rate of rotation
            around the device's local X, Y and Z axis. The coordinate system is the
            same as is used for the acceleration sensor. Rotation is positive in the
            counter-clockwise direction. That is, an observer looking from some
            positive location on the x, y or z axis at a device positioned on the
            origin would report positive rotation if the device appeared to be
            rotating counter clockwise. Note that this is the standard mathematical
            definition of positive rotation and does not agree with the definition of
            roll given earlier.
            &lt;ul&gt;
            &lt;li&gt; values[0]: Angular speed around the x-axis &lt;/li&gt;
            &lt;li&gt; values[1]: Angular speed around the y-axis &lt;/li&gt;
            &lt;li&gt; values[2]: Angular speed around the z-axis &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>Typically the output of the gyroscope is integrated over time to
            calculate a rotation describing the change of angles over the time step,
            for example:</para>
          <code lang="text/java">private static final float NS2S = 1.0f / 1000000000.0f;
                private final float[] deltaRotationVector = new float[4]();
                private float timestamp;
            
                public void onSensorChanged(SensorEvent event) {
                     // This time step's delta rotation to be multiplied by the current rotation
                     // after computing it from the gyro sample data.
                     if (timestamp != 0) {
                         final float dT = (event.timestamp - timestamp) * NS2S;
                         // Axis of the rotation sample, not normalized yet.
                         float axisX = event.values[0];
                         float axisY = event.values[1];
                         float axisZ = event.values[2];
            
                         // Calculate the angular speed of the sample
                         float omegaMagnitude = sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);
            
                         // Normalize the rotation vector if it's big enough to get the axis
                         if (omegaMagnitude &gt; EPSILON) {
                             axisX /= omegaMagnitude;
                             axisY /= omegaMagnitude;
                             axisZ /= omegaMagnitude;
                         }
            
                         // Integrate around this axis with the angular speed by the time step
                         // in order to get a delta rotation from this sample over the time step
                         // We will convert this axis-angle representation of the delta rotation
                         // into a quaternion before turning it into the rotation matrix.
                         float thetaOverTwo = omegaMagnitude * dT / 2.0f;
                         float sinThetaOverTwo = sin(thetaOverTwo);
                         float cosThetaOverTwo = cos(thetaOverTwo);
                         deltaRotationVector[0] = sinThetaOverTwo * axisX;
                         deltaRotationVector[1] = sinThetaOverTwo * axisY;
                         deltaRotationVector[2] = sinThetaOverTwo * axisZ;
                         deltaRotationVector[3] = cosThetaOverTwo;
                     }
                     timestamp = event.timestamp;
                     float[] deltaRotationMatrix = new float[9];
                     SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);
                     // User code should concatenate the delta rotation we computed with the current
                     // rotation in order to get the updated rotation.
                     // rotationCurrent = rotationCurrent * deltaRotationMatrix;
                }
            </code>
          <para>In practice, the gyroscope noise and offset will introduce some errors
            which need to be compensated for. This is usually done using the
            information from other sensors, but is beyond the scope of this document.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_LIGHT Sensor.TYPE_LIGHT</c>:&lt;/h4&gt;
            &lt;ul&gt;
            &lt;li&gt;values[0]: Ambient light level in SI lux units &lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_PRESSURE Sensor.TYPE_PRESSURE</c>:&lt;/h4&gt;
            &lt;ul&gt;
            &lt;li&gt;values[0]: Atmospheric pressure in hPa (millibar) &lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_PROXIMITY Sensor.TYPE_PROXIMITY</c>:
            &lt;/h4&gt;
            
            &lt;ul&gt;
            &lt;li&gt;values[0]: Proximity sensor distance measured in centimeters &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>&lt;b&gt;Note:&lt;/b&gt; Some proximity sensors only support a binary <i>near</i> or
            <i>far</i> measurement. In this case, the sensor should report its
            <c>android.hardware.Sensor#getMaximumRange() maximum range</c> value in
            the <i>far</i> state and a lesser value in the <i>near</i> state.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_GRAVITY Sensor.TYPE_GRAVITY</c>:&lt;/h4&gt;</para>
          <para>A three dimensional vector indicating the direction and magnitude of gravity.  Units
             are m/s^2. The coordinate system is the same as is used by the acceleration sensor.</para>
          <para>&lt;b&gt;Note:&lt;/b&gt; When the device is at rest, the output of the gravity sensor should be
             identical to that of the accelerometer.</para>
          <para>&lt;h4&gt;
             <c>android.hardware.Sensor#TYPE_LINEAR_ACCELERATION Sensor.TYPE_LINEAR_ACCELERATION</c>:
             &lt;/h4&gt; A three dimensional vector indicating acceleration along each device axis, not
             including gravity. All values have units of m/s^2.  The coordinate system is the same as is
             used by the acceleration sensor.</para>
          <para>The output of the accelerometer, gravity and  linear-acceleration sensors must obey the
             following relation:</para>
          <para>&lt;ul&gt;acceleration = gravity + linear-acceleration&lt;/ul&gt;</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_ROTATION_VECTOR Sensor.TYPE_ROTATION_VECTOR</c>:&lt;/h4&gt;</para>
          <para>The rotation vector represents the orientation of the device as a combination of an
             <i>angle</i> and an <i>axis</i>, in which the device has rotated through an angle &amp;#952
             around an axis &amp;lt;x, y, z&gt;.</para>
          <para>The three elements of the rotation vector are
             &amp;lt;x*sin(&amp;#952/2), y*sin(&amp;#952/2), z*sin(&amp;#952/2)&gt;, such that the magnitude of the rotation
             vector is equal to sin(&amp;#952/2), and the direction of the rotation vector is equal to the
             direction of the axis of rotation.</para>
          <para>&lt;/p&gt;The three elements of the rotation vector are equal to
             the last three components of a &lt;b&gt;unit&lt;/b&gt; quaternion
             &amp;lt;cos(&amp;#952/2), x*sin(&amp;#952/2), y*sin(&amp;#952/2), z*sin(&amp;#952/2)&gt;.&lt;/p&gt;</para>
          <para>Elements of the rotation vector are unitless.
             The x,y, and z axis are defined in the same way as the acceleration
             sensor.</para>
          <para>The reference coordinate system is defined as a direct orthonormal basis,
             where:
            &lt;/p&gt;
            
            &lt;ul&gt;
            &lt;li&gt;X is defined as the vector product &lt;b&gt;Y.Z&lt;/b&gt; (It is tangential to
            the ground at the device's current location and roughly points East).&lt;/li&gt;
            &lt;li&gt;Y is tangential to the ground at the device's current location and
            points towards magnetic north.&lt;/li&gt;
            &lt;li&gt;Z points towards the sky and is perpendicular to the ground.&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>&lt;center&gt;&lt;img src="../../../images/axis_globe.png"
            alt="World coordinate-system diagram." border="0" /&gt;&lt;/center&gt;</para>
          <para>&lt;ul&gt;
            &lt;li&gt; values[0]: x*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[1]: y*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[2]: z*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[3]: cos(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[4]: estimated heading Accuracy (in radians) (-1 if unavailable)&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>values[3], originally optional, will always be present from SDK Level 18 onwards.
            values[4] is a new value that has been added in SDK Level 18.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_ORIENTATION
            Sensor.TYPE_ORIENTATION</c>:&lt;/h4&gt; All values are angles in degrees.
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: Azimuth, angle between the magnetic north direction and the
            y-axis, around the z-axis (0 to 359). 0=North, 90=East, 180=South,
            270=West
            &lt;/p&gt;</para>
          <para>values[1]: Pitch, rotation around x-axis (-180 to 180), with positive
            values when the z-axis moves &lt;b&gt;toward&lt;/b&gt; the y-axis.</para>
          <para>values[2]: Roll, rotation around the y-axis (-90 to 90)
            increasing as the device moves clockwise.</para>
          <para>&lt;/ul&gt;</para>
          <para>&lt;b&gt;Note:&lt;/b&gt; This definition is different from &lt;b&gt;yaw, pitch and roll&lt;/b&gt;
            used in aviation where the X axis is along the long side of the plane
            (tail to nose).</para>
          <para>&lt;b&gt;Note:&lt;/b&gt; This sensor type exists for legacy reasons, please use
            <c>android.hardware.Sensor#TYPE_ROTATION_VECTOR
            rotation vector sensor type</c> and
            <c>android.hardware.SensorManager#getRotationMatrix
            getRotationMatrix()</c> in conjunction with
            <c>android.hardware.SensorManager#remapCoordinateSystem
            remapCoordinateSystem()</c> and
            <c>android.hardware.SensorManager#getOrientation getOrientation()</c> to
            compute these values instead.</para>
          <para>&lt;b&gt;Important note:&lt;/b&gt; For historical reasons the roll angle is positive
            in the clockwise direction (mathematically speaking, it should be
            positive in the counter-clockwise direction).</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_RELATIVE_HUMIDITY
            Sensor.TYPE_RELATIVE_HUMIDITY</c>:&lt;/h4&gt;
            &lt;ul&gt;
            &lt;li&gt; values[0]: Relative ambient air humidity in percent &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>When relative ambient air humidity and ambient temperature are
            measured, the dew point and absolute humidity can be calculated.</para>
          <para>&lt;u&gt;Dew Point&lt;/u&gt;</para>
          <para>The dew point is the temperature to which a given parcel of air must be
            cooled, at constant barometric pressure, for water vapor to condense
            into water.</para>
          <para>&lt;center&gt;</para>
          <code lang="text/java">ln(RH/100%) + m&amp;#183;t/(T&lt;sub&gt;n&lt;/sub&gt;+t)
            t&lt;sub&gt;d&lt;/sub&gt;(t,RH) = T&lt;sub&gt;n&lt;/sub&gt; &amp;#183; ------------------------------
                            m - [ln(RH/100%) + m&amp;#183;t/(T&lt;sub&gt;n&lt;/sub&gt;+t)]
            </code>
          <para>&lt;/center&gt;
            &lt;dl&gt;
            &lt;dt&gt;t&lt;sub&gt;d&lt;/sub&gt;&lt;/dt&gt; &lt;dd&gt;dew point temperature in &amp;deg;C&lt;/dd&gt;
            &lt;dt&gt;t&lt;/dt&gt;             &lt;dd&gt;actual temperature in &amp;deg;C&lt;/dd&gt;
            &lt;dt&gt;RH&lt;/dt&gt;            &lt;dd&gt;actual relative humidity in %&lt;/dd&gt;
            &lt;dt&gt;m&lt;/dt&gt;             &lt;dd&gt;17.62&lt;/dd&gt;
            &lt;dt&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/dt&gt; &lt;dd&gt;243.12 &amp;deg;C&lt;/dd&gt;
            &lt;/dl&gt;</para>
          <para>for example:</para>
          <code lang="text/java">h = Math.log(rh / 100.0) + (17.62 * t) / (243.12 + t);
            td = 243.12 * h / (17.62 - h);
            </code>
          <para>&lt;u&gt;Absolute Humidity&lt;/u&gt;</para>
          <para>The absolute humidity is the mass of water vapor in a particular volume
            of dry air. The unit is g/m&lt;sup&gt;3&lt;/sup&gt;.</para>
          <para>&lt;center&gt;</para>
          <code lang="text/java">RH/100%&amp;#183;A&amp;#183;exp(m&amp;#183;t/(T&lt;sub&gt;n&lt;/sub&gt;+t))
            d&lt;sub&gt;v&lt;/sub&gt;(t,RH) = 216.7 &amp;#183; -------------------------
                                      273.15 + t
            </code>
          <para>&lt;/center&gt;
            &lt;dl&gt;
            &lt;dt&gt;d&lt;sub&gt;v&lt;/sub&gt;&lt;/dt&gt; &lt;dd&gt;absolute humidity in g/m&lt;sup&gt;3&lt;/sup&gt;&lt;/dd&gt;
            &lt;dt&gt;t&lt;/dt&gt;             &lt;dd&gt;actual temperature in &amp;deg;C&lt;/dd&gt;
            &lt;dt&gt;RH&lt;/dt&gt;            &lt;dd&gt;actual relative humidity in %&lt;/dd&gt;
            &lt;dt&gt;m&lt;/dt&gt;             &lt;dd&gt;17.62&lt;/dd&gt;
            &lt;dt&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/dt&gt; &lt;dd&gt;243.12 &amp;deg;C&lt;/dd&gt;
            &lt;dt&gt;A&lt;/dt&gt;             &lt;dd&gt;6.112 hPa&lt;/dd&gt;
            &lt;/dl&gt;</para>
          <para>for example:</para>
          <code lang="text/java">dv = 216.7 *
            (rh / 100.0 * 6.112 * Math.exp(17.62 * t / (243.12 + t)) / (273.15 + t));
            </code>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_AMBIENT_TEMPERATURE Sensor.TYPE_AMBIENT_TEMPERATURE</c>:
            &lt;/h4&gt;
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: ambient (room) temperature in degree Celsius.&lt;/li&gt;
            &lt;/ul&gt;
            
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_MAGNETIC_FIELD_UNCALIBRATED
            Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED</c>:&lt;/h4&gt;
            Similar to <c>android.hardware.Sensor#TYPE_MAGNETIC_FIELD</c>,
            but the hard iron calibration is reported separately instead of being included
            in the measurement. Factory calibration and temperature compensation will still
            be applied to the "uncalibrated" measurement. Assumptions that the magnetic field
            is due to the Earth's poles is avoided.</para>
          <para>The values array is shown below:
            &lt;ul&gt;
            &lt;li&gt; values[0] = x_uncalib &lt;/li&gt;
            &lt;li&gt; values[1] = y_uncalib &lt;/li&gt;
            &lt;li&gt; values[2] = z_uncalib &lt;/li&gt;
            &lt;li&gt; values[3] = x_bias &lt;/li&gt;
            &lt;li&gt; values[4] = y_bias &lt;/li&gt;
            &lt;li&gt; values[5] = z_bias &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>x_uncalib, y_uncalib, z_uncalib are the measured magnetic field in X, Y, Z axes.
            Soft iron and temperature calibrations are applied. But the hard iron
            calibration is not applied. The values are in micro-Tesla (uT).</para>
          <para>x_bias, y_bias, z_bias give the iron bias estimated in X, Y, Z axes.
            Each field is a component of the estimated hard iron calibration.
            The values are in micro-Tesla (uT).</para>
          <para>Hard iron - These distortions arise due to the magnetized iron, steel or permanent
            magnets on the device.
            Soft iron - These distortions arise due to the interaction with the earth's magnetic
            field.</para>
          <para>&lt;h4&gt; <c>android.hardware.Sensor#TYPE_GAME_ROTATION_VECTOR
            Sensor.TYPE_GAME_ROTATION_VECTOR</c>:&lt;/h4&gt;
            Identical to <c>android.hardware.Sensor#TYPE_ROTATION_VECTOR</c> except that it
            doesn't use the geomagnetic field. Therefore the Y axis doesn't
            point north, but instead to some other reference, that reference is
            allowed to drift by the same order of magnitude as the gyroscope
            drift around the Z axis.</para>
          <para>In the ideal case, a phone rotated and returning to the same real-world
            orientation will report the same game rotation vector
            (without using the earth's geomagnetic field). However, the orientation
            may drift somewhat over time. See <c>android.hardware.Sensor#TYPE_ROTATION_VECTOR</c>
            for a detailed description of the values. This sensor will not have
            the estimated heading accuracy value.</para>
          <para>&lt;h4&gt; <c>android.hardware.Sensor#TYPE_GYROSCOPE_UNCALIBRATED
            Sensor.TYPE_GYROSCOPE_UNCALIBRATED</c>:&lt;/h4&gt;
            All values are in radians/second and measure the rate of rotation
            around the X, Y and Z axis. An estimation of the drift on each axis is
            reported as well.</para>
          <para>No gyro-drift compensation is performed. Factory calibration and temperature
            compensation is still applied to the rate of rotation (angular speeds).</para>
          <para>The coordinate system is the same as is used for the
            <c>android.hardware.Sensor#TYPE_ACCELEROMETER</c>
            Rotation is positive in the counter-clockwise direction (right-hand rule).
            That is, an observer looking from some positive location on the x, y or z axis
            at a device positioned on the origin would report positive rotation if the device
            appeared to be rotating counter clockwise.
            The range would at least be 17.45 rad/s (ie: ~1000 deg/s).
            &lt;ul&gt;
            &lt;li&gt; values[0] : angular speed (w/o drift compensation) around the X axis in rad/s &lt;/li&gt;
            &lt;li&gt; values[1] : angular speed (w/o drift compensation) around the Y axis in rad/s &lt;/li&gt;
            &lt;li&gt; values[2] : angular speed (w/o drift compensation) around the Z axis in rad/s &lt;/li&gt;
            &lt;li&gt; values[3] : estimated drift around X axis in rad/s &lt;/li&gt;
            &lt;li&gt; values[4] : estimated drift around Y axis in rad/s &lt;/li&gt;
            &lt;li&gt; values[5] : estimated drift around Z axis in rad/s &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>&lt;b&gt;Pro Tip:&lt;/b&gt; Always use the length of the values array while performing operations
            on it. In earlier versions, this used to be always 3 which has changed now.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_POSE_6DOF
            Sensor.TYPE_POSE_6DOF</c>:&lt;/h4&gt;
            
            A TYPE_POSE_6DOF event consists of a rotation expressed as a quaternion and a translation
            expressed in SI units. The event also contains a delta rotation and translation that show
            how the device?s pose has changed since the previous sequence numbered pose.
            The event uses the cannonical Android Sensor axes.
            
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: x*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[1]: y*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[2]: z*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[3]: cos(&amp;#952/2)   &lt;/li&gt;
            
            
            &lt;li&gt; values[4]: Translation along x axis from an arbitrary origin. &lt;/li&gt;
            &lt;li&gt; values[5]: Translation along y axis from an arbitrary origin. &lt;/li&gt;
            &lt;li&gt; values[6]: Translation along z axis from an arbitrary origin. &lt;/li&gt;
            
            &lt;li&gt; values[7]:  Delta quaternion rotation x*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[8]:  Delta quaternion rotation y*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[9]:  Delta quaternion rotation z*sin(&amp;#952/2) &lt;/li&gt;
            &lt;li&gt; values[10]: Delta quaternion rotation cos(&amp;#952/2) &lt;/li&gt;
            
            &lt;li&gt; values[11]: Delta translation along x axis. &lt;/li&gt;
            &lt;li&gt; values[12]: Delta translation along y axis. &lt;/li&gt;
            &lt;li&gt; values[13]: Delta translation along z axis. &lt;/li&gt;
            
            &lt;li&gt; values[14]: Sequence number &lt;/li&gt;
            
            &lt;/ul&gt;
            
              &lt;h4&gt;<c>android.hardware.Sensor#TYPE_STATIONARY_DETECT
            Sensor.TYPE_STATIONARY_DETECT</c>:&lt;/h4&gt;
            
            A TYPE_STATIONARY_DETECT event is produced if the device has been
            stationary for at least 5 seconds with a maximal latency of 5
            additional seconds. ie: it may take up anywhere from 5 to 10 seconds
            afte the device has been at rest to trigger this event.
            
            The only allowed value is 1.0.
            
            &lt;ul&gt;
             &lt;li&gt; values[0]: 1.0 &lt;/li&gt;
            &lt;/ul&gt;
            
              &lt;h4&gt;<c>android.hardware.Sensor#TYPE_MOTION_DETECT
            Sensor.TYPE_MOTION_DETECT</c>:&lt;/h4&gt;
            
            A TYPE_MOTION_DETECT event is produced if the device has been in
            motion  for at least 5 seconds with a maximal latency of 5
            additional seconds. ie: it may take up anywhere from 5 to 10 seconds
            afte the device has been at rest to trigger this event.
            
            The only allowed value is 1.0.
            
            &lt;ul&gt;
             &lt;li&gt; values[0]: 1.0 &lt;/li&gt;
            &lt;/ul&gt;
            
              &lt;h4&gt;<c>android.hardware.Sensor#TYPE_HEART_BEAT
            Sensor.TYPE_HEART_BEAT</c>:&lt;/h4&gt;
            
            A sensor of this type returns an event everytime a heart beat peak is
            detected.
            
            Peak here ideally corresponds to the positive peak in the QRS complex of
            an ECG signal.
            
            &lt;ul&gt;
             &lt;li&gt; values[0]: confidence&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>A confidence value of 0.0 indicates complete uncertainty - that a peak
            is as likely to be at the indicated timestamp as anywhere else.
            A confidence value of 1.0 indicates complete certainly - that a peak is
            completely unlikely to be anywhere else on the QRS complex.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_LOW_LATENCY_OFFBODY_DETECT
            Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT</c>:&lt;/h4&gt;</para>
          <para>A sensor of this type returns an event every time the device transitions
            from off-body to on-body and from on-body to off-body (e.g. a wearable
            device being removed from the wrist would trigger an event indicating an
            off-body transition). The event returned will contain a single value to
            indicate off-body state:</para>
          <para>&lt;ul&gt;
             &lt;li&gt; values[0]: off-body state&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>Valid values for off-body state:
            &lt;ul&gt;
             &lt;li&gt; 1.0 (device is on-body)&lt;/li&gt;
             &lt;li&gt; 0.0 (device is off-body)&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>When a sensor of this type is activated, it must deliver the initial
            on-body or off-body event representing the current device state within
            5 seconds of activating the sensor.</para>
          <para>This sensor must be able to detect and report an on-body to off-body
            transition within 1 second of the device being removed from the body,
            and must be able to detect and report an off-body to on-body transition
            within 5 seconds of the device being put back onto the body.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_ACCELEROMETER_UNCALIBRATED
            Sensor.TYPE_ACCELEROMETER_UNCALIBRATED</c>:&lt;/h4&gt; All values are in SI
            units (m/s^2)
            
            Similar to <c>android.hardware.Sensor#TYPE_ACCELEROMETER</c>,
            Factory calibration and temperature compensation will still be applied
            to the "uncalibrated" measurement.</para>
          <para>The values array is shown below:
            &lt;ul&gt;
            &lt;li&gt; values[0] = x_uncalib without bias compensation &lt;/li&gt;
            &lt;li&gt; values[1] = y_uncalib without bias compensation &lt;/li&gt;
            &lt;li&gt; values[2] = z_uncalib without bias compensation &lt;/li&gt;
            &lt;li&gt; values[3] = estimated x_bias &lt;/li&gt;
            &lt;li&gt; values[4] = estimated y_bias &lt;/li&gt;
            &lt;li&gt; values[5] = estimated z_bias &lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>x_uncalib, y_uncalib, z_uncalib are the measured acceleration in X, Y, Z
            axes similar to the  <c>android.hardware.Sensor#TYPE_ACCELEROMETER</c>,
            without any bias correction (factory bias compensation and any
            temperature compensation is allowed).
            x_bias, y_bias, z_bias are the estimated biases.</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_HINGE_ANGLE Sensor.TYPE_HINGE_ANGLE</c>:&lt;/h4&gt;
            
            A sensor of this type measures the angle, in degrees, between two integral parts of the
            device. Movement of a hinge measured by this sensor type is expected to alter the ways in
            which the user may interact with the device, for example by unfolding or revealing a display.
            
            &lt;ul&gt;
             &lt;li&gt; values[0]: Measured hinge angle between 0 and 360 degrees inclusive&lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_HEAD_TRACKER Sensor.TYPE_HEAD_TRACKER</c>:&lt;/h4&gt;
            
            A sensor of this type measures the orientation of a user's head relative to an arbitrary
            reference frame, as well as the rate of rotation.
            
            Events produced by this sensor follow a special head-centric coordinate frame, where:
            &lt;ul&gt;
             &lt;li&gt; The X axis crosses through the user's ears, with the positive X direction extending
                  out of the user's right ear&lt;/li&gt;
             &lt;li&gt; The Y axis crosses from the back of the user's head through their nose, with the
                  positive direction extending out of the nose, and the X/Y plane being nominally
                  parallel to the ground when the user is upright and looking straight ahead&lt;/li&gt;
             &lt;li&gt; The Z axis crosses from the neck through the top of the user's head, with the
                  positive direction extending out from the top of the head&lt;/li&gt;
            &lt;/ul&gt;
            
            Data is provided in Euler vector representation, which is a vector whose direction indicates
            the axis of rotation and magnitude indicates the angle to rotate around that axis, in
            radians.
            
            The first three elements provide the transform from the (arbitrary, possibly slowly drifting)
            reference frame to the head frame. The magnitude of this vector is in range [0, &amp;pi;]
            radians, while the value of individual axes is in range [-&amp;pi;, &amp;pi;]. The next three
            elements optionally provide the estimated rotational velocity of the user's head relative to
            itself, in radians per second. If a given sensor does not support determining velocity, these
            elements are set to 0.
            
            &lt;ul&gt;
             &lt;li&gt; values[0] : X component of Euler vector representing rotation&lt;/li&gt;
             &lt;li&gt; values[1] : Y component of Euler vector representing rotation&lt;/li&gt;
             &lt;li&gt; values[2] : Z component of Euler vector representing rotation&lt;/li&gt;
             &lt;li&gt; values[3] : X component of Euler vector representing angular velocity (if
             supported, otherwise 0)&lt;/li&gt;
             &lt;li&gt; values[4] : Y component of Euler vector representing angular velocity (if
             supported, otherwise 0)&lt;/li&gt;
             &lt;li&gt; values[5] : Z component of Euler vector representing angular velocity (if
             supported, otherwise 0)&lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_ACCELEROMETER_LIMITED_AXES
            Sensor.TYPE_ACCELEROMETER_LIMITED_AXES</c>:
            &lt;/h4&gt; Equivalent to TYPE_ACCELEROMETER, but supporting cases where one
            or two axes are not supported.
            
            The last three values represent whether the acceleration value for a
            given axis is supported. A value of 1.0 indicates that the axis is
            supported, while a value of 0 means it isn't supported. The supported
            axes should be determined at build time and these values do not change
            during runtime.
            
            The acceleration values for axes that are not supported are set to 0.
            
            Similar to <c>android.hardware.Sensor#TYPE_ACCELEROMETER</c>.
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: Acceleration minus Gx on the x-axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[1]: Acceleration minus Gy on the y-axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[2]: Acceleration minus Gz on the z-axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[3]: Acceleration supported for x-axis&lt;/li&gt;
            &lt;li&gt; values[4]: Acceleration supported for y-axis&lt;/li&gt;
            &lt;li&gt; values[5]: Acceleration supported for z-axis&lt;/li&gt;
            &lt;/ul&gt;
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_GYROSCOPE_LIMITED_AXES
            Sensor.TYPE_GYROSCOPE_LIMITED_AXES</c>:
            &lt;/h4&gt; Equivalent to TYPE_GYROSCOPE, but supporting cases where one or two
            axes are not supported.
            
            The last three values represent whether the angular speed value for a
            given axis is supported. A value of 1.0 indicates that the axis is
            supported, while a value of 0 means it isn't supported. The supported
            axes should be determined at build time and these values do not change
            during runtime.
            
            The angular speed values for axes that are not supported are set to 0.
            
            Similar to <c>android.hardware.Sensor#TYPE_GYROSCOPE</c>.
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: Angular speed around the x-axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[1]: Angular speed around the y-axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[2]: Angular speed around the z-axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[3]: Angular speed supported for x-axis&lt;/li&gt;
            &lt;li&gt; values[4]: Angular speed supported for y-axis&lt;/li&gt;
            &lt;li&gt; values[5]: Angular speed supported for z-axis&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>&lt;h4&gt;<c>android.hardware.Sensor#TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED
            Sensor.TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED</c>:
            &lt;/h4&gt; Equivalent to TYPE_ACCELEROMETER_UNCALIBRATED, but supporting cases
            where one or two axes are not supported.
            
            The last three values represent whether the acceleration value for a
            given axis is supported. A value of 1.0 indicates that the axis is
            supported, while a value of 0 means it isn't supported. The supported
            axes should be determined at build time and these values do not change
            during runtime.
            
            The acceleration values and bias values for axes that are not supported
            are set to 0.
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: x_uncalib without bias compensation (if supported)&lt;/li&gt;
            &lt;li&gt; values[1]: y_uncalib without bias compensation (if supported)&lt;/li&gt;
            &lt;li&gt; values[2]: z_uncalib without bias compensation (if supported)&lt;/li&gt;
            &lt;li&gt; values[3]: estimated x_bias (if supported)&lt;/li&gt;
            &lt;li&gt; values[4]: estimated y_bias (if supported)&lt;/li&gt;
            &lt;li&gt; values[5]: estimated z_bias (if supported)&lt;/li&gt;
            &lt;li&gt; values[6]: Acceleration supported for x-axis&lt;/li&gt;
            &lt;li&gt; values[7]: Acceleration supported for y-axis&lt;/li&gt;
            &lt;li&gt; values[8]: Acceleration supported for z-axis&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>&lt;h4&gt; <c>android.hardware.Sensor#TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED
            Sensor.TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED</c>:
            &lt;/h4&gt; Equivalent to TYPE_GYROSCOPE_UNCALIBRATED, but supporting cases
            where one or two axes are not supported.
            
            The last three values represent whether the angular speed value for a
            given axis is supported. A value of 1.0 indicates that the axis is
            supported, while a value of 0 means it isn't supported. The supported
            axes should be determined at build time and these values do not change
            during runtime.
            
            The angular speed values and drift values for axes that are not supported
            are set to 0.
            
            &lt;ul&gt;
            &lt;li&gt; values[0]: Angular speed (w/o drift compensation) around the X axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[1]: Angular speed (w/o drift compensation) around the Y axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[2]: Angular speed (w/o drift compensation) around the Z axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[3]: estimated drift around X axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[4]: estimated drift around Y axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[5]: estimated drift around Z axis (if supported)&lt;/li&gt;
            &lt;li&gt; values[6]: Angular speed supported for x-axis&lt;/li&gt;
            &lt;li&gt; values[7]: Angular speed supported for y-axis&lt;/li&gt;
            &lt;li&gt; values[8]: Angular speed supported for z-axis&lt;/li&gt;
            &lt;/ul&gt;
            &lt;/p&gt;
            
            &lt;h4&gt;<c>android.hardware.Sensor#TYPE_HEADING Sensor.TYPE_HEADING</c>:&lt;/h4&gt;
            
            A sensor of this type measures the direction in which the device is
            pointing relative to true north in degrees. The value must be between
            0.0 (inclusive) and 360.0 (exclusive), with 0 indicating north, 90 east,
            180 south, and 270 west.
            
            Accuracy is defined at 68% confidence. In the case where the underlying
            distribution is assumed Gaussian normal, this would be considered one
            standard deviation. For example, if heading returns 60 degrees, and
            accuracy returns 10 degrees, then there is a 68 percent probability of
            the true heading being between 50 degrees and 70 degrees.
            
            &lt;ul&gt;
             &lt;li&gt; values[0]: Measured heading in degrees.&lt;/li&gt;
             &lt;li&gt; values[1]: Heading accuracy in degrees.&lt;/li&gt;
            &lt;/ul&gt;</para>
          <para>
            <format type="text/html">
              <a href="https://developer.android.com/reference/android/hardware/SensorEvent#values" title="Reference documentation">Java documentation for <code>android.hardware.SensorEvent.values</code>.</a>
            </format>
          </para>
          <para>
                    Portions of this page are modifications based on work created and shared by the 
                    <format type="text/html"><a href="https://developers.google.com/terms/site-policies" title="Android Open Source Project">Android Open Source Project</a></format>
                     and used according to terms described in the 
                    <format type="text/html"><a href="https://creativecommons.org/licenses/by/2.5/" title="Creative Commons 2.5 Attribution License">Creative Commons 2.5 Attribution License.</a></format></para>
        </remarks>
        <since version="Added in API level 3" />
        <altmember cref="T:Android.Hardware.GeomagneticField" />
      </Docs>
    </Member>
  </Members>
</Type>
