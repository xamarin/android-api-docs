<Type Name="SensorEvent" FullName="Android.Hardware.SensorEvent">
  <TypeSignature Language="C#" Value="public class SensorEvent : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SensorEvent extends Java.Lang.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("android/hardware/SensorEvent", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="3">
    <summary>This class represents a <c><see cref="T:Android.Hardware.Sensor" /></c> event and
 holds informations such as the sensor's type, the time-stamp, accuracy and of
 course the sensor's <c><see cref="P:Android.Hardware.SensorEvent.Values" /></c>.</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">This class represents a <c><see cref="T:Android.Hardware.Sensor" /></c> event and
 holds informations such as the sensor's type, the time-stamp, accuracy and of
 course the sensor's <c><see cref="P:Android.Hardware.SensorEvent.Values" /></c>.

 </para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <u>Definition of the coordinate system used by the SensorEvent API.</u>
        </format>
      </para>
      <para tool="javadoc-to-mdoc">
 The coordinate-system is defined relative to the screen of the phone in its
 default orientation. The axes are not swapped when the device's screen
 orientation changes.
 </para>
      <para tool="javadoc-to-mdoc">
 The X axis is horizontal and points to the right, the Y axis is vertical and
 points up and the Z axis points towards the outside of the front face of the
 screen. In this system, coordinates behind the screen have negative Z values.
 </para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <center>
            <img src="../../../images/axis_device.png" alt="Sensors coordinate-system diagram." border="0" />
          </center>
        </format>
      </para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <b>Note:</b>
        </format> This coordinate system is different from the one used in the
 Android 2D APIs where the origin is in the top-left corner.
 </para>
      <format type="text/html">
        <h5 class="jd-tagtitle">See Also</h5>
      </format>
      <list type="bullet">
        <item>
          <term>
            <c>
              <see cref="T:Android.Hardware.SensorManager" />
            </c>
          </term>
        </item>
        <item>
          <term>
            <c>
              <see cref="T:Android.Hardware.SensorEvent" />
            </c>
          </term>
        </item>
        <item>
          <term>
            <c>
              <see cref="T:Android.Hardware.Sensor" />
            </c>
          </term>
        </item>
      </list>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/android/hardware/SensorEvent.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 3" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SensorEvent (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject{T,U}(System.IntPtr,Android.Runtime.JniHandleOwnership)" tool="ReplaceLinkValue" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accuracy">
      <MemberSignature Language="C#" Value="public Android.Hardware.SensorStatus Accuracy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Android.Hardware.SensorStatus Accuracy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("accuracy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Hardware.SensorStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The accuracy of this event.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">The accuracy of this event. See <c><see cref="T:Android.Hardware.SensorManager" /></c> for details.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/hardware/SensorEvent.html#accuracy" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="Sensor">
      <MemberSignature Language="C#" Value="public Android.Hardware.Sensor Sensor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Android.Hardware.Sensor Sensor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("sensor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Hardware.Sensor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The sensor that generated this event.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">The sensor that generated this event. See
 <c><see cref="T:Android.Hardware.SensorManager" /></c> for details.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/hardware/SensorEvent.html#sensor" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonvirtualVoidMethod" tool="ReplaceLinkValue" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public long Timestamp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("timestamp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The time in nanosecond at which the event happened
</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">The time in nanosecond at which the event happened
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/hardware/SensorEvent.html#timestamp" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;float&gt; Values { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;float32&gt; Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("values")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <format type="text/html">
            <h4>
              <c>
                <see cref="!:Android.Hardware.Sensor.TYPE_ACCELEROMETER" />
              </c>:</h4>
          </format> All values are in SI units (m/s^2)

 <list type="bullet"><item><term> values[0]: Acceleration minus Gx on the x-axis </term></item><item><term> values[1]: Acceleration minus Gy on the y-axis </term></item><item><term> values[2]: Acceleration minus Gz on the z-axis </term></item></list><format type="text/html"><b><center>Ad = - &amp;#8721;Fs / mass</center></b></format><format type="text/html"><b><center>Ad = -g - &amp;#8721;F / mass</center></b></format><example><code lang="java">

     public void onSensorChanged(SensorEvent event)
     {
          // alpha is calculated as t / (t + dT)
          // with t, the low-pass filter's time-constant
          // and dT, the event delivery rate

          final float alpha = 0.8;

          gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];
          gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];
          gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];

          linear_acceleration[0] = event.values[0] - gravity[0];
          linear_acceleration[1] = event.values[1] - gravity[1];
          linear_acceleration[2] = event.values[2] - gravity[2];
     }
 </code></example>The three elements of the rotation vector are equal to
  the last three components of a <format type="text/html"><b>unit</b></format> quaternion
  &lt;cos(&amp;#952/2), x*sin(&amp;#952/2), y*sin(&amp;#952/2), z*sin(&amp;#952/2)&gt;.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <h4>
                <c>
                  <see cref="!:Android.Hardware.Sensor.TYPE_ACCELEROMETER" />
                </c>:</h4>
            </format> All values are in SI units (m/s^2)

 <list type="bullet"><item><term> values[0]: Acceleration minus Gx on the x-axis </term></item><item><term> values[1]: Acceleration minus Gy on the y-axis </term></item><item><term> values[2]: Acceleration minus Gz on the z-axis </term></item></list><format type="text/html"><b><center>Ad = - &amp;#8721;Fs / mass</center></b></format><format type="text/html"><b><center>Ad = -g - &amp;#8721;F / mass</center></b></format><example><code lang="java">

     public void onSensorChanged(SensorEvent event)
     {
          // alpha is calculated as t / (t + dT)
          // with t, the low-pass filter's time-constant
          // and dT, the event delivery rate

          final float alpha = 0.8;

          gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];
          gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];
          gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];

          linear_acceleration[0] = event.values[0] - gravity[0];
          linear_acceleration[1] = event.values[1] - gravity[1];
          linear_acceleration[2] = event.values[2] - gravity[2];
     }
 </code></example>The three elements of the rotation vector are equal to
  the last three components of a <format type="text/html"><b>unit</b></format> quaternion
  &lt;cos(&amp;#952/2), x*sin(&amp;#952/2), y*sin(&amp;#952/2), z*sin(&amp;#952/2)&gt;.</para>
          <para tool="javadoc-to-mdoc">
 The length and contents of the <c><see cref="P:Android.Hardware.SensorEvent.Values" /></c> array depends on
 which <c><see cref="T:Android.Hardware.Sensor" /></c> type is being monitored (see
 also <c><see cref="T:Android.Hardware.SensorEvent" /></c> for a definition of the coordinate system used).
 </para>
          <para tool="javadoc-to-mdoc">
 A sensor of this type measures the acceleration applied to the device
 (<format type="text/html"><b>Ad</b></format>). Conceptually, it does so by measuring forces applied to the
 sensor itself (<format type="text/html"><b>Fs</b></format>) using the relation:
 </para>
          <para tool="javadoc-to-mdoc">
 In particular, the force of gravity is always influencing the measured
 acceleration:
 </para>
          <para tool="javadoc-to-mdoc">
 For this reason, when the device is sitting on a table (and obviously not
 accelerating), the accelerometer reads a magnitude of <format type="text/html"><b>g</b></format> = 9.81
 m/s^2
 </para>
          <para tool="javadoc-to-mdoc">
 Similarly, when the device is in free-fall and therefore dangerously
 accelerating towards to ground at 9.81 m/s^2, its accelerometer reads a
 magnitude of 0 m/s^2.
 </para>
          <para tool="javadoc-to-mdoc">
 It should be apparent that in order to measure the real acceleration of
 the device, the contribution of the force of gravity must be eliminated.
 This can be achieved by applying a <format type="text/html"><i>high-pass</i></format> filter. Conversely, a
 <format type="text/html"><i>low-pass</i></format> filter can be used to isolate the force of gravity.
 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <u>Examples</u>
            </format>:
 <list type="bullet"><item><term>When the device lies flat on a table and is pushed on its left side
 toward the right, the x acceleration value is positive.</term></item><item><term>When the device lies flat on a table, the acceleration value is
 +9.81, which correspond to the acceleration of the device (0 m/s^2) minus
 the force of gravity (-9.81 m/s^2).</term></item><item><term>When the device lies flat on a table and is pushed toward the sky
 with an acceleration of A m/s^2, the acceleration value is equal to
 A+9.81 which correspond to the acceleration of the device (+A m/s^2)
 minus the force of gravity (-9.81 m/s^2).</term></item></list><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_MAGNETIC_FIELD" /></c>:</h4></format>
 All values are in micro-Tesla (uT) and measure the ambient magnetic field
 in the X, Y and Z axis.

 <format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_GYROSCOPE" /></c>:
 </h4></format> All values are in radians/second and measure the rate of rotation
 around the device's local X, Y and Z axis. The coordinate system is the
 same as is used for the acceleration sensor. Rotation is positive in the
 counter-clockwise direction. That is, an observer looking from some
 positive location on the x, y or z axis at a device positioned on the
 origin would report positive rotation if the device appeared to be
 rotating counter clockwise. Note that this is the standard mathematical
 definition of positive rotation and does not agree with the definition of
 roll given earlier.
 <list type="bullet"><item><term> values[0]: Angular speed around the x-axis </term></item><item><term> values[1]: Angular speed around the y-axis </term></item><item><term> values[2]: Angular speed around the z-axis </term></item></list><example><code lang="java">
     private static final float NS2S = 1.0f / 1000000000.0f;
     private final float[] deltaRotationVector = new float[4]();
     private float timestamp;

     public void onSensorChanged(SensorEvent event) {
          // This timestep's delta rotation to be multiplied by the current rotation
          // after computing it from the gyro sample data.
          if (timestamp != 0) {
              final float dT = (event.timestamp - timestamp) * NS2S;
              // Axis of the rotation sample, not normalized yet.
              float axisX = event.values[0];
              float axisY = event.values[1];
              float axisZ = event.values[2];

              // Calculate the angular speed of the sample
              float omegaMagnitude = sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);

              // Normalize the rotation vector if it's big enough to get the axis
              if (omegaMagnitude &gt; EPSILON) {
                  axisX /= omegaMagnitude;
                  axisY /= omegaMagnitude;
                  axisZ /= omegaMagnitude;
              }

              // Integrate around this axis with the angular speed by the timestep
              // in order to get a delta rotation from this sample over the timestep
              // We will convert this axis-angle representation of the delta rotation
              // into a quaternion before turning it into the rotation matrix.
              float thetaOverTwo = omegaMagnitude * dT / 2.0f;
              float sinThetaOverTwo = sin(thetaOverTwo);
              float cosThetaOverTwo = cos(thetaOverTwo);
              deltaRotationVector[0] = sinThetaOverTwo * axisX;
              deltaRotationVector[1] = sinThetaOverTwo * axisY;
              deltaRotationVector[2] = sinThetaOverTwo * axisZ;
              deltaRotationVector[3] = cosThetaOverTwo;
          }
          timestamp = event.timestamp;
          float[] deltaRotationMatrix = new float[9];
          SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);
          // User code should concatenate the delta rotation we computed with the current rotation
          // in order to get the updated rotation.
          // rotationCurrent = rotationCurrent * deltaRotationMatrix;
     }
 </code></example><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_LIGHT" /></c>:</h4></format><list type="bullet"><item><term>values[0]: Ambient light level in SI lux units </term></item></list><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_PRESSURE" /></c>:</h4></format><list type="bullet"><item><term>values[0]: Atmospheric pressure in hPa (millibar) </term></item></list><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_PROXIMITY" /></c>:
 </h4></format><list type="bullet"><item><term>values[0]: Proximity sensor distance measured in centimeters </term></item></list><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_GRAVITY" /></c>:</h4></format><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_LINEAR_ACCELERATION" /></c>:</h4></format>
  A three dimensional vector indicating acceleration along each device axis, not including
  gravity.  All values have units of m/s^2.  The coordinate system is the same as is used by the
  acceleration sensor.
  <format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_ROTATION_VECTOR" /></c>:</h4></format></para>
          <para tool="javadoc-to-mdoc">
 Typically the output of the gyroscope is integrated over time to
 calculate a rotation describing the change of angles over the timestep,
 for example:
 </para>
          <para tool="javadoc-to-mdoc">
 In practice, the gyroscope noise and offset will introduce some errors
 which need to be compensated for. This is usually done using the
 information from other sensors, but is beyond the scope of this document.
 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Note:</b>
            </format> Some proximity sensors only support a binary <format type="text/html"><i>near</i></format> or
 <format type="text/html"><i>far</i></format> measurement. In this case, the sensor should report its
 <c><see cref="P:Android.Hardware.Sensor.MaximumRange" /></c> value in
 the <format type="text/html"><i>far</i></format> state and a lesser value in the <format type="text/html"><i>near</i></format> state.
 </para>
          <para tool="javadoc-to-mdoc">A three dimensional vector indicating the direction and magnitude of gravity.  Units
  are m/s^2. The coordinate system is the same as is used by the acceleration sensor.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Note:</b>
            </format> When the device is at rest, the output of the gravity sensor should be identical
  to that of the accelerometer.</para>
          <para tool="javadoc-to-mdoc">The output of the accelerometer, gravity and  linear-acceleration sensors must obey the
  following relation:</para>
          <para tool="javadoc-to-mdoc">
            <list type="bullet">acceleration = gravity + linear-acceleration</list>
          </para>
          <para tool="javadoc-to-mdoc">The rotation vector represents the orientation of the device as a combination of an <format type="text/html"><i>angle</i></format>
  and an <format type="text/html"><i>axis</i></format>, in which the device has rotated through an angle &amp;#952 around an axis
  &lt;x, y, z&gt;.</para>
          <para tool="javadoc-to-mdoc">The three elements of the rotation vector are
  &lt;x*sin(&amp;#952/2), y*sin(&amp;#952/2), z*sin(&amp;#952/2)&gt;, such that the magnitude of the rotation
  vector is equal to sin(&amp;#952/2), and the direction of the rotation vector is equal to the
  direction of the axis of rotation.</para>
          <para tool="javadoc-to-mdoc">Elements of the rotation vector are unitless.
  The x,y, and z axis are defined in the same way as the acceleration
  sensor.
  The reference coordinate system is defined as a direct orthonormal basis,
  where:
 </para>
          <para tool="javadoc-to-mdoc">
            <list type="bullet">
              <item>
                <term>X is defined as the vector product <format type="text/html"><b>Y.Z</b></format> (It is tangential to
 the ground at the device's current location and roughly points East).</term>
              </item>
              <item>
                <term>Y is tangential to the ground at the device's current location and
 points towards magnetic north.</term>
              </item>
              <item>
                <term>Z points towards the sky and is perpendicular to the ground.</term>
              </item>
            </list>
            <list type="bullet">
              <item>
                <term> values[0]: x*sin(&amp;#952/2) </term>
              </item>
              <item>
                <term> values[1]: y*sin(&amp;#952/2) </term>
              </item>
              <item>
                <term> values[2]: z*sin(&amp;#952/2) </term>
              </item>
              <item>
                <term> values[3]: cos(&amp;#952/2) </term>
              </item>
              <item>
                <term> values[4]: estimated heading Accuracy (in radians) (-1 if unavailable)</term>
              </item>
            </list>
            <format type="text/html">
              <h4>
                <c>
                  <see cref="!:Android.Hardware.Sensor.TYPE_ORIENTATION" />
                </c>:</h4>
            </format> All values are angles in degrees.

 <list type="bullet"><item><term> values[0]: Azimuth, angle between the magnetic north direction and the
 y-axis, around the z-axis (0 to 359). 0=North, 90=East, 180=South,
 270=West
 </term></item></list><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_RELATIVE_HUMIDITY" /></c>:</h4></format><list type="bullet"><item><term> values[0]: Relative ambient air humidity in percent </term></item></list><format type="text/html"><u>Dew Point</u></format><format type="text/html"><center><example><code lang="java">
                    ln(RH/100%) + m&amp;#183;t/(Tn+t)
 td(t,RH) = Tn &amp;#183; ------------------------------
                 m - [ln(RH/100%) + m&amp;#183;t/(Tn+t)]
 </code></example></center></format><format type="text/html"><dl><dt>t<sub>d</sub></dt><dd>dew point temperature in &amp;deg;C</dd><dt>t</dt><dd>actual temperature in &amp;deg;C</dd><dt>RH</dt><dd>actual relative humidity in %</dd><dt>m</dt><dd>17.62</dd><dt>T<sub>n</sub></dt><dd>243.12 &amp;deg;C</dd></dl></format><example><code lang="java">
 h = Math.log(rh / 100.0) + (17.62 * t) / (243.12 + t);
 td = 243.12 * h / (17.62 - h);
 </code></example><format type="text/html"><u>Absolute Humidity</u></format><format type="text/html"><center><example><code lang="java">
                    RH/100%&amp;#183;A&amp;#183;exp(m&amp;#183;t/(Tn+t))
 dv(t,RH) = 216.7 &amp;#183; -------------------------
                           273.15 + t
 </code></example></center></format><format type="text/html"><dl><dt>d<sub>v</sub></dt><dd>absolute humidity in g/m<sup>3</sup></dd><dt>t</dt><dd>actual temperature in &amp;deg;C</dd><dt>RH</dt><dd>actual relative humidity in %</dd><dt>m</dt><dd>17.62</dd><dt>T<sub>n</sub></dt><dd>243.12 &amp;deg;C</dd><dt>A</dt><dd>6.112 hPa</dd></dl></format><example><code lang="java">
 dv = 216.7 *
 (rh / 100.0 * 6.112 * Math.exp(17.62 * t / (243.12 + t)) / (273.15 + t));
 </code></example><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_AMBIENT_TEMPERATURE" /></c>:
 </h4></format><list type="bullet"><item><term> values[0]: ambient (room) temperature in degree Celsius.</term></item></list><format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED" /></c>:</h4></format>
 Similar to <c><see cref="!:Android.Hardware.Sensor.TYPE_MAGNETIC_FIELD" /></c>,
 but the hard iron calibration is reported separately instead of being included
 in the measurement. Factory calibration and temperature compensation will still
 be applied to the "uncalibrated" measurement. Assumptions that the magnetic field
 is due to the Earth's poles is avoided.
 <format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_GAME_ROTATION_VECTOR" /></c>:</h4></format>
 Identical to <c><see cref="!:Android.Hardware.Sensor.TYPE_ROTATION_VECTOR" /></c> except that it
 doesn't use the geomagnetic field. Therefore the Y axis doesn't
 point north, but instead to some other reference, that reference is
 allowed to drift by the same order of magnitude as the gyroscope
 drift around the Z axis.
 <format type="text/html"><h4><c><see cref="!:Android.Hardware.Sensor.TYPE_GYROSCOPE_UNCALIBRATED" /></c>:</h4></format>
 All values are in radians/second and measure the rate of rotation
 around the X, Y and Z axis. An estimation of the drift on each axis is
 reported as well.
 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <center>
                <img src="../../../images/axis_globe.png" alt="World coordinate-system diagram." border="0" />
              </center>
            </format>
          </para>
          <para tool="javadoc-to-mdoc"> values[3], originally optional, will always be present from SDK Level 18 onwards.
 values[4] is a new value that has been added in SDK Level 18.
 </para>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
 values[1]: Pitch, rotation around x-axis (-180 to 180), with positive
 values when the z-axis moves <format type="text/html"><b>toward</b></format> the y-axis.
 </para>
          <para tool="javadoc-to-mdoc">
 values[2]: Roll, rotation around the y-axis (-90 to 90)
 increasing as the device moves clockwise.
 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Note:</b>
            </format> This definition is different from <format type="text/html"><b>yaw, pitch and roll</b></format>
 used in aviation where the X axis is along the long side of the plane
 (tail to nose).
 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Note:</b>
            </format> This sensor type exists for legacy reasons, please use
 <c><see cref="!:Android.Hardware.Sensor.TYPE_ROTATION_VECTOR" /></c> and
 <c><see cref="M:Android.Hardware.SensorManager.GetRotationMatrix(System.Single[],System.Single[],System.Single[],System.Single[])" /></c> in conjunction with
 <c><see cref="M:Android.Hardware.SensorManager.RemapCoordinateSystem(System.Single[],Android.Hardware.Axis,Android.Hardware.Axis,Android.Hardware.Axis)" /></c> and
 <c><see cref="M:Android.Hardware.SensorManager.GetOrientation(System.Single[],System.Single[])" /></c> to
 compute these values instead.
 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Important note:</b>
            </format> For historical reasons the roll angle is positive
 in the clockwise direction (mathematically speaking, it should be
 positive in the counter-clockwise direction).
 </para>
          <para tool="javadoc-to-mdoc">
 When relative ambient air humidity and ambient temperature are
 measured, the dew point and absolute humidity can be calculated.
 </para>
          <para tool="javadoc-to-mdoc">
 The dew point is the temperature to which a given parcel of air must be
 cooled, at constant barometric pressure, for water vapor to condense
 into water.
 </para>
          <para tool="javadoc-to-mdoc">for example:</para>
          <para tool="javadoc-to-mdoc">
 The absolute humidity is the mass of water vapor in a particular volume
 of dry air. The unit is g/m<format type="text/html"><sup>3</sup></format>.
 </para>
          <para tool="javadoc-to-mdoc">for example:</para>
          <para tool="javadoc-to-mdoc">
 The values array is shown below:
 <list type="bullet"><item><term> values[0] = x_uncalib </term></item><item><term> values[1] = y_uncalib </term></item><item><term> values[2] = z_uncalib </term></item><item><term> values[3] = x_bias </term></item><item><term> values[4] = y_bias </term></item><item><term> values[5] = z_bias </term></item></list></para>
          <para tool="javadoc-to-mdoc">
 x_uncalib, y_uncalib, z_uncalib are the measured magnetic field in X, Y, Z axes.
 Soft iron and temperature calibrations are applied. But the hard iron
 calibration is not applied. The values are in micro-Tesla (uT).
 </para>
          <para tool="javadoc-to-mdoc">
 x_bias, y_bias, z_bias give the iron bias estimated in X, Y, Z axes.
 Each field is a component of the estimated hard iron calibration.
 The values are in micro-Tesla (uT).
 </para>
          <para tool="javadoc-to-mdoc"> Hard iron - These distortions arise due to the magnetized iron, steel or permanenet
 magnets on the device.
 Soft iron - These distortions arise due to the interaction with the earth's magentic
 field.
 </para>
          <para tool="javadoc-to-mdoc">
 In the ideal case, a phone rotated and returning to the same real-world
 orientation will report the same game rotation vector
 (without using the earth's geomagnetic field). However, the orientation
 may drift somewhat over time. See <c><see cref="!:Android.Hardware.Sensor.TYPE_ROTATION_VECTOR" /></c>
 for a detailed description of the values. This sensor will not have
 the estimated heading accuracy value.
 </para>
          <para tool="javadoc-to-mdoc">
 No gyro-drift compensation is performed. Factory calibration and temperature
 compensation is still applied to the rate of rotation (angular speeds).
 </para>
          <para tool="javadoc-to-mdoc">
 The coordinate system is the same as is used for the
 <c><see cref="!:Android.Hardware.Sensor.TYPE_ACCELEROMETER" /></c>
 Rotation is positive in the counter-clockwise direction (right-hand rule).
 That is, an observer looking from some positive location on the x, y or z axis
 at a device positioned on the origin would report positive rotation if the device
 appeared to be rotating counter clockwise.
 The range would at least be 17.45 rad/s (ie: ~1000 deg/s).
 <list type="bullet"><item><term> values[0] : angular speed (w/o drift compensation) around the X axis in rad/s </term></item><item><term> values[1] : angular speed (w/o drift compensation) around the Y axis in rad/s </term></item><item><term> values[2] : angular speed (w/o drift compensation) around the Z axis in rad/s </term></item><item><term> values[3] : estimated drift around X axis in rad/s </term></item><item><term> values[4] : estimated drift around Y axis in rad/s </term></item><item><term> values[5] : estimated drift around Z axis in rad/s </term></item></list></para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Pro Tip:</b>
            </format> Always use the length of the values array while performing operations
 on it. In earlier versions, this used to be always 3 which has changed now. </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/hardware/SensorEvent.html#values" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 3" />
        <altmember cref="T:Android.Hardware.GeomagneticField" />
      </Docs>
    </Member>
  </Members>
</Type>
