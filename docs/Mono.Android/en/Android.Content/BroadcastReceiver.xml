<Type Name="BroadcastReceiver" FullName="Android.Content.BroadcastReceiver">
  <TypeSignature Language="C#" Value="public abstract class BroadcastReceiver : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit BroadcastReceiver extends Java.Lang.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("android/content/BroadcastReceiver", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="1">
    <summary>Base class for code that will receive intents sent by sendBroadcast().</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">Base class for code that will receive intents sent by sendBroadcast().

 </para>
      <para tool="javadoc-to-mdoc">If you don't need to send broadcasts across applications, consider using
 this class with <c><see cref="!:NoType:android/support/v4/content/LocalBroadcastManager;Href=../../../reference/android/support/v4/content/LocalBroadcastManager.html" /></c> instead
 of the more general facilities described below.  This will give you a much
 more efficient implementation (no cross-process communication needed) and allow
 you to avoid thinking about any security issues related to other applications
 being able to receive or send your broadcasts.

 </para>
      <para tool="javadoc-to-mdoc">You can either dynamically register an instance of this class with
 <c><see cref="M:Android.Content.Context.RegisterReceiver(Android.Content.BroadcastReceiver, Android.Content.IntentFilter)" /></c>
 or statically publish an implementation through the
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestReceiver" /></c>
 tag in your <c>AndroidManifest.xml</c>.
 
 </para>
      <para tool="javadoc-to-mdoc">
        <i>
          <i>Note:</i>
        </i>
    If registering a receiver in your
 <c><see cref="M:Android.App.Activity.OnResume" /></c>
 implementation, you should unregister it in 
 <c><see cref="M:Android.App.Activity.OnPause" /></c>.
 (You won't receive intents when paused, 
 and this will cut down on unnecessary system overhead). Do not unregister in 
 <c><see cref="M:Android.App.Activity.OnSaveInstanceState(Android.OS.Bundle)" /></c>,
 because this won't be called if the user moves back in the history
 stack.
 
 </para>
      <para tool="javadoc-to-mdoc">There are two major classes of broadcasts that can be received:<list type="bullet"><item><term><format type="text/html"><b>Normal broadcasts</b></format> (sent with <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c>) are completely asynchronous.  All receivers of the
 broadcast are run in an undefined order, often at the same time.  This is
 more efficient, but means that receivers cannot use the result or abort
 APIs included here.
 </term></item><item><term><format type="text/html"><b>Ordered broadcasts</b></format> (sent with <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>) are delivered to one receiver at a time.
 As each receiver executes in turn, it can propagate a result to the next
 receiver, or it can completely abort the broadcast so that it won't be passed
 to other receivers.  The order receivers run in can be controlled with the
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestIntentFilter_priority" /></c> attribute of the matching intent-filter; receivers with
 the same priority will be run in an arbitrary order.
 </term></item></list></para>
      <para tool="javadoc-to-mdoc">Even in the case of normal broadcasts, the system may in some
 situations revert to delivering the broadcast one receiver at a time.  In
 particular, for receivers that may require the creation of a process, only
 one will be run at a time to avoid overloading the system with new processes.
 In this situation, however, the non-ordered semantics hold: these receivers still
 cannot return results or abort their broadcast.</para>
      <para tool="javadoc-to-mdoc">Note that, although the Intent class is used for sending and receiving
 these broadcasts, the Intent broadcast mechanism here is completely separate
 from Intents that are used to start Activities with
 <c><see cref="M:Android.Content.Context.StartActivity(Android.Content.Intent)" /></c>.
 There is no way for a BroadcastReceiver
 to see or capture Intents used with startActivity(); likewise, when
 you broadcast an Intent, you will never find or start an Activity.
 These two operations are semantically very different: starting an
 Activity with an Intent is a foreground operation that modifies what the
 user is currently interacting with; broadcasting an Intent is a background
 operation that the user is not normally aware of.
 
 </para>
      <para tool="javadoc-to-mdoc">The BroadcastReceiver class (when launched as a component through
 a manifest's <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestReceiver" /></c>
 tag) is an important part of an
 <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/fundamentals.html#lcycles">application's overall lifecycle</a></format>.</para>
      <para tool="javadoc-to-mdoc">Topics covered here:
 <list type="number"><item><term></term></item><item><term></term></item><item><term></term></item></list><format type="text/html"><h3>Developer Guides</h3></format></para>
      <para tool="javadoc-to-mdoc">For information about how to use this class to receive and resolve intents, read the
 <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/intents/intents-filters.html">Intents and Intent Filters</a></format>
 developer guide.</para>
      <format type="text/html">
        <h3>Security</h3>
      </format>
      <para tool="javadoc-to-mdoc">Receivers used with the <c><see cref="T:Android.Content.Context" /></c> APIs are by their nature a
 cross-application facility, so you must consider how other applications
 may be able to abuse your use of them.  Some things to consider are:

 <list type="bullet"><item><term>The Intent namespace is global.  Make sure that Intent action names and
 other strings are written in a namespace you own, or else you may inadvertently
 conflict with other applications.
 </term></item><item><term>When you use <c><see cref="M:Android.Content.Context.RegisterReceiver(Android.Content.BroadcastReceiver, Android.Content.IntentFilter)" /></c>,
 <i>any</i> application may send broadcasts to that registered receiver.  You can
 control who can send broadcasts to it through permissions described below.
 </term></item><item><term>When you publish a receiver in your application's manifest and specify
 intent-filters for it, any other application can send broadcasts to it regardless
 of the filters you specify.  To prevent others from sending to it, make it
 unavailable to them with <c>android:exported="false"</c>.
 </term></item><item><term>When you use <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c> or related methods,
 normally any other application can receive these broadcasts.  You can control who
 can receive such broadcasts through permissions described below.  Alternatively,
 starting with <c><see cref="!:NoType:android/os/Build$VERSION_CODES;Href=../../../reference/android/os/Build.VERSION_CODES.html#ICE_CREAM_SANDWICH" /></c>, you
 can also safely restrict the broadcast to a single application with
 <c><see cref="M:Android.Content.Intent.SetPackage(System.String)" /></c></term></item></list></para>
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc">None of these issues exist when using
 <c><see cref="!:NoType:android/support/v4/content/LocalBroadcastManager;Href=../../../reference/android/support/v4/content/LocalBroadcastManager.html" /></c>, since intents
 broadcast it never go outside of the current process.

 </para>
      <para tool="javadoc-to-mdoc">Access permissions can be enforced by either the sender or receiver
 of a broadcast.

 </para>
      <para tool="javadoc-to-mdoc">To enforce a permission when sending, you supply a non-null
 <format type="text/html"><var>permission</var></format> argument to
 <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent, System.String)" /></c> or
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String, System.String, System.String, System.String, System.String, System.String)" /></c>.
 Only receivers who have been granted this permission
 (by requesting it with the
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestUsesPermission" /></c>
 tag in their <c>AndroidManifest.xml</c>) will be able to receive
 the broadcast.

 </para>
      <para tool="javadoc-to-mdoc">To enforce a permission when receiving, you supply a non-null
 <format type="text/html"><var>permission</var></format> when registering your receiver -- either when calling
 <c><see cref="M:Android.Content.Context.RegisterReceiver(Android.Content.BroadcastReceiver, Android.Content.IntentFilter, Android.Content.IntentFilter, Android.Content.IntentFilter)" /></c>
 or in the static
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestReceiver" /></c>
 tag in your <c>AndroidManifest.xml</c>.  Only broadcasters who have
 been granted this permission (by requesting it with the
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestUsesPermission" /></c>
 tag in their <c>AndroidManifest.xml</c>) will be able to send an
 Intent to the receiver.

 </para>
      <para tool="javadoc-to-mdoc">See the <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/security/security.html">Security and Permissions</a></format>
 document for more information on permissions and security in general.

 <format type="text/html"><h3>Receiver Lifecycle</h3></format></para>
      <para tool="javadoc-to-mdoc">A BroadcastReceiver object is only valid for the duration of the call
 to <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c>.  Once your code returns from this function,
 the system considers the object to be finished and no longer active.
 
 </para>
      <para tool="javadoc-to-mdoc">This has important repercussions to what you can do in an
 <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c> implementation: anything that requires asynchronous
 operation is not available, because you will need to return from the
 function to handle the asynchronous operation, but at that point the
 BroadcastReceiver is no longer active and thus the system is free to kill
 its process before the asynchronous operation completes.
 
 </para>
      <para tool="javadoc-to-mdoc">In particular, you may <format type="text/html"><i>not</i></format> show a dialog or bind to a service from
 within a BroadcastReceiver.  For the former, you should instead use the
 <c><see cref="T:Android.App.NotificationManager" /></c> API.  For the latter, you can
 use <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c> to
 send a command to the service.

 <format type="text/html"><h3>Process Lifecycle</h3></format></para>
      <para tool="javadoc-to-mdoc">A process that is currently executing a BroadcastReceiver (that is,
 currently running the code in its <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c> method) is
 considered to be a foreground process and will be kept running by the
 system except under cases of extreme memory pressure.
 
 </para>
      <para tool="javadoc-to-mdoc">Once you return from onReceive(), the BroadcastReceiver is no longer
 active, and its hosting process is only as important as any other application
 components that are running in it.  This is especially important because if
 that process was only hosting the BroadcastReceiver (a common case for
 applications that the user has never or not recently interacted with), then
 upon returning from onReceive() the system will consider its process
 to be empty and aggressively kill it so that resources are available for other
 more important processes.
 
 </para>
      <para tool="javadoc-to-mdoc">This means that for longer-running operations you will often use
 a <c><see cref="T:Android.App.Service" /></c> in conjunction with a BroadcastReceiver to keep
 the containing process active for the entire time of your operation.
</para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BroadcastReceiver ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <remarks>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#BroadcastReceiver()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected BroadcastReceiver (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject``1(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AbortBroadcast">
      <MemberSignature Language="C#" Value="public bool AbortBroadcast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AbortBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getAbortBroadcast", "()Z", "GetGetAbortBroadcastHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the flag indicating whether or not this receiver should
 abort the current broadcast.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the flag indicating whether or not this receiver should
 abort the current broadcast.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#getAbortBroadcast()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ClearAbortBroadcast">
      <MemberSignature Language="C#" Value="public void ClearAbortBroadcast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearAbortBroadcast() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("clearAbortBroadcast", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the flag indicating that this receiver should abort the current
 broadcast.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Clears the flag indicating that this receiver should abort the current
 broadcast.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#clearAbortBroadcast()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="DebugUnregister">
      <MemberSignature Language="C#" Value="public bool DebugUnregister { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DebugUnregister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getDebugUnregister", "()Z", "GetGetDebugUnregisterHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setDebugUnregister", "(Z)V", "GetSetDebugUnregister_ZHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return the last value given to <c><see cref="P:Android.Content.BroadcastReceiver.DebugUnregister" /></c>.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#getDebugUnregister()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Return the last value given to <c><see cref="P:Android.Content.BroadcastReceiver.DebugUnregister" /></c>.
</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister(boolean)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Control inclusion of debugging help for mismatched
 calls to <c><see cref="M:Android.Content.Context.RegisterReceiver(Android.Content.BroadcastReceiver, Android.Content.IntentFilter)" /></c>.
 If called with true, before given to registerReceiver(), then the
 callstack of the following <c><see cref="M:Android.Content.Context.UnregisterReceiver(Android.Content.BroadcastReceiver)" /></c> call is retained, to be printed if a later
 incorrect unregister call is made.  Note that doing this requires retaining
 information about the BroadcastReceiver for the lifetime of the app,
 resulting in a leak -- this should only be used for debugging.
</para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="GetResultExtras">
      <MemberSignature Language="C#" Value="public Android.OS.Bundle GetResultExtras (bool makeMap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Android.OS.Bundle GetResultExtras(bool makeMap) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getResultExtras", "(Z)Landroid/os/Bundle;", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.OS.Bundle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="makeMap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="makeMap">If true then a new empty Map will be made for you if the
                current Map is null; if false you should be prepared to
                receive a null Map.</param>
        <summary>Retrieve the current result extra data, as set by the previous receiver.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Retrieve the current result extra data, as set by the previous receiver.
 Any changes you make to the returned Map will be propagated to the next
 receiver.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#getResultExtras(boolean)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="GoAsync">
      <MemberSignature Language="C#" Value="public Android.Content.BroadcastReceiver.PendingResult GoAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Android.Content.BroadcastReceiver/PendingResult GoAsync() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("goAsync", "()Landroid/content/BroadcastReceiver$PendingResult;", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Content.BroadcastReceiver+PendingResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This can be called by an application in <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c> to allow
 it to keep the broadcast active after returning from that function.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">This can be called by an application in <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c> to allow
 it to keep the broadcast active after returning from that function.
 This does <i>not</i> change the expectation of being relatively
 responsive to the broadcast (finishing it within 10s), but does allow
 the implementation to move work related to it over to another thread
 to avoid glitching the main UI thread due to disk IO.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#goAsync()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 11" />
      </Docs>
    </Member>
    <Member MemberName="InvokeAbortBroadcast">
      <MemberSignature Language="C#" Value="public void InvokeAbortBroadcast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAbortBroadcast() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("abortBroadcast", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the flag indicating that this receiver should abort the
 current broadcast; only works with broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Sets the flag indicating that this receiver should abort the
 current broadcast; only works with broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.  This will prevent
 any other broadcast receivers from receiving the broadcast. It will still
 call <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c> of the BroadcastReceiver that the caller of 
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c> passed in.
 
 </para>
          <para tool="javadoc-to-mdoc">
            <i>This method does not work with non-ordered broadcasts such
 as those sent with <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c></i>
          </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#abortBroadcast()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsInitialStickyBroadcast">
      <MemberSignature Language="C#" Value="public bool IsInitialStickyBroadcast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialStickyBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isInitialStickyBroadcast", "()Z", "GetIsInitialStickyBroadcastHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns true if the receiver is currently processing the initial
 value of a sticky broadcast -- that is, the value that was last
 broadcast and is currently held in the sticky cache, so this is
 not directly the result of a broadcast right now.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns true if the receiver is currently processing the initial
 value of a sticky broadcast -- that is, the value that was last
 broadcast and is currently held in the sticky cache, so this is
 not directly the result of a broadcast right now.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#isInitialStickyBroadcast()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
      </Docs>
    </Member>
    <Member MemberName="IsOrderedBroadcast">
      <MemberSignature Language="C#" Value="public bool IsOrderedBroadcast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOrderedBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isOrderedBroadcast", "()Z", "GetIsOrderedBroadcastHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns true if the receiver is currently processing an ordered
 broadcast.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns true if the receiver is currently processing an ordered
 broadcast.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#isOrderedBroadcast()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
      </Docs>
    </Member>
    <Member MemberName="OnReceive">
      <MemberSignature Language="C#" Value="public abstract void OnReceive (Android.Content.Context context, Android.Content.Intent intent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnReceive(class Android.Content.Context context, class Android.Content.Intent intent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onReceive", "(Landroid/content/Context;Landroid/content/Intent;)V", "GetOnReceive_Landroid_content_Context_Landroid_content_Intent_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="Android.Content.Context" />
        <Parameter Name="intent" Type="Android.Content.Intent" />
      </Parameters>
      <Docs>
        <param name="context">The Context in which the receiver is running.</param>
        <param name="intent">The Intent being received.
</param>
        <summary>This method is called when the BroadcastReceiver is receiving an Intent
 broadcast.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This method is called when the BroadcastReceiver is receiving an Intent
 broadcast.  During this time you can use the other methods on
 BroadcastReceiver to view/modify the current result values.  This method
 is always called within the main thread of its process, unless you
 explicitly asked for it to be scheduled on a different thread using
 <c><see cref="M:Android.Content.Context.RegisterReceiver(Android.Content.BroadcastReceiver, Android.Content.IntentFilter, Android.Content.IntentFilter, Android.Content.IntentFilter)" /></c>. When it runs on the main
 thread you should
 never perform long-running operations in it (there is a timeout of
 10 seconds that the system allows before considering the receiver to
 be blocked and a candidate to be killed). You cannot launch a popup dialog
 in your implementation of onReceive().

 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>If this BroadcastReceiver was launched through a &lt;receiver&gt; tag,
 then the object is no longer alive after returning from this
 function.</b>
            </format>  This means you should not perform any operations that
 return a result to you asynchronously -- in particular, for interacting
 with services, you should use
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c> instead of
 <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c>.  If you wish
 to interact with a service that is already running, you can use
 <c><see cref="M:Android.Content.BroadcastReceiver.PeekService(Android.Content.Context, Android.Content.Intent)" /></c>.
 
 </para>
          <para tool="javadoc-to-mdoc">The Intent filters used in <c><see cref="M:Android.Content.Context.RegisterReceiver(Android.Content.BroadcastReceiver, Android.Content.IntentFilter)" /></c>
 and in application manifests are <i>not</i> guaranteed to be exclusive. They
 are hints to the operating system about how to find suitable recipients. It is
 possible for senders to force delivery to specific recipients, bypassing filter
 resolution.  For this reason, <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c>
 implementations should respond only to known actions, ignoring any unexpected
 Intents that they may receive.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="PeekService">
      <MemberSignature Language="C#" Value="public virtual Android.OS.IBinder PeekService (Android.Content.Context myContext, Android.Content.Intent service);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Android.OS.IBinder PeekService(class Android.Content.Context myContext, class Android.Content.Intent service) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("peekService", "(Landroid/content/Context;Landroid/content/Intent;)Landroid/os/IBinder;", "GetPeekService_Landroid_content_Context_Landroid_content_Intent_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.OS.IBinder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="myContext" Type="Android.Content.Context" />
        <Parameter Name="service" Type="Android.Content.Intent" />
      </Parameters>
      <Docs>
        <param name="myContext">The Context that had been passed to <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c></param>
        <param name="service">The Intent indicating the service you wish to use.  See <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c> for more information.
</param>
        <summary>Provide a binder to an already-running service.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Provide a binder to an already-running service.  This method is synchronous
 and will not start the target service if it is not present, so it is safe
 to call from <c><see cref="M:Android.Content.BroadcastReceiver.OnReceive(Android.Content.Context, Android.Content.Intent)" /></c>.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#peekService(android.content.Context, android.content.Intent)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 3" />
      </Docs>
    </Member>
    <Member MemberName="ResultCode">
      <MemberSignature Language="C#" Value="public Android.App.Result ResultCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Android.App.Result ResultCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getResultCode", "()I", "GetGetResultCodeHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setResultCode", "(I)V", "GetSetResultCode_IHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.App.Result</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieve the current result code, as set by the previous receiver.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#getResultCode()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Retrieve the current result code, as set by the previous receiver.</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setResultCode(int)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Change the current result code of this broadcast; only works with
 broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.  Often uses the
 Activity <c><see cref="!:Android.App.Activity.RESULT_CANCELED" /></c> and
 <c><see cref="!:Android.App.Activity.RESULT_OK" /></c> constants, though the
 actual meaning of this value is ultimately up to the broadcaster.
 
 </para>
          <para tool="javadoc-to-mdoc">This method does not work with non-ordered broadcasts such
 as those sent with <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c></para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Android.Content.BroadcastReceiver.SetResult(Android.App.Result, System.String, System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ResultData">
      <MemberSignature Language="C#" Value="public string ResultData { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResultData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getResultData", "()Ljava/lang/String;", "GetGetResultDataHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setResultData", "(Ljava/lang/String;)V", "GetSetResultData_Ljava_lang_String_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retrieve the current result data, as set by the previous receiver.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#getResultData()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Retrieve the current result data, as set by the previous receiver.
 Often this is null.</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setResultData(java.lang.String)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Change the current result data of this broadcast; only works with
 broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.  This is an arbitrary
 string whose interpretation is up to the broadcaster.
 
 </para>
          <para tool="javadoc-to-mdoc">
            <i>This method does not work with non-ordered broadcasts such
 as those sent with <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c></i>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Android.Content.BroadcastReceiver.SetResult(Android.App.Result, System.String, System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetOrderedHint">
      <MemberSignature Language="C#" Value="public void SetOrderedHint (bool isOrdered);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetOrderedHint(bool isOrdered) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("setOrderedHint", "(Z)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isOrdered" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isOrdered">To be added.</param>
        <summary>For internal use, sets the hint about whether this BroadcastReceiver is
 running in ordered mode.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">For internal use, sets the hint about whether this BroadcastReceiver is
 running in ordered mode.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setOrderedHint(boolean)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="SetResult">
      <MemberSignature Language="C#" Value="public void SetResult (Android.App.Result code, string data, Android.OS.Bundle extras);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResult(valuetype Android.App.Result code, string data, class Android.OS.Bundle extras) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("setResult", "(ILjava/lang/String;Landroid/os/Bundle;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="Android.App.Result">
          <Attributes>
            <Attribute>
              <AttributeName>Android.Runtime.GeneratedEnum</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="data" Type="System.String" />
        <Parameter Name="extras" Type="Android.OS.Bundle" />
      </Parameters>
      <Docs>
        <param name="code">The new result code.  Often uses the
 Activity <c><see cref="!:Android.App.Activity.RESULT_CANCELED" /></c> and
 <c><see cref="!:Android.App.Activity.RESULT_OK" /></c> constants, though the
 actual meaning of this value is ultimately up to the broadcaster.</param>
        <param name="data">The new result data.  This is an arbitrary
 string whose interpretation is up to the broadcaster; may be null.</param>
        <param name="extras">The new extra data map.  This is a Bundle
 holding arbitrary data, whose interpretation is up to the
 broadcaster.  Can be set to null.  This completely
 replaces the current map (if any).
</param>
        <summary>Change all of the result data returned from this broadcasts; only works
 with broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Change all of the result data returned from this broadcasts; only works
 with broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.  All current result data is replaced
 by the value given to this method.
 
 </para>
          <para tool="javadoc-to-mdoc">
            <i>This method does not work with non-ordered broadcasts such
 as those sent with <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c></i>
          </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setResult(int, java.lang.String, android.os.Bundle)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="SetResultExtras">
      <MemberSignature Language="C#" Value="public void SetResultExtras (Android.OS.Bundle extras);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResultExtras(class Android.OS.Bundle extras) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("setResultExtras", "(Landroid/os/Bundle;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extras" Type="Android.OS.Bundle" />
      </Parameters>
      <Docs>
        <param name="extras">The new extra data map; may be null.</param>
        <summary>Change the current result extras of this broadcast; only works with
 broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Change the current result extras of this broadcast; only works with
 broadcasts sent through
 <c><see cref="M:Android.Content.Context.SendOrderedBroadcast(Android.Content.Intent, System.String)" /></c>.  This is a Bundle
 holding arbitrary data, whose interpretation is up to the
 broadcaster.  Can be set to null.  Calling this method completely
 replaces the current map (if any).
 
 </para>
          <para tool="javadoc-to-mdoc">
            <i>This method does not work with non-ordered broadcasts such
 as those sent with <c><see cref="M:Android.Content.Context.SendBroadcast(Android.Content.Intent)" /></c></i>
          </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setResultExtras(android.os.Bundle)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Android.Content.BroadcastReceiver.SetResult(Android.App.Result, System.String, System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonVirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>