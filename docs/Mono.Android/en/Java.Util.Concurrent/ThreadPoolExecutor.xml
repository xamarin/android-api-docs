<Type Name="ThreadPoolExecutor" FullName="Java.Util.Concurrent.ThreadPoolExecutor">
  <TypeSignature Language="C#" Value="public class ThreadPoolExecutor : Java.Util.Concurrent.AbstractExecutorService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ThreadPoolExecutor extends Java.Util.Concurrent.AbstractExecutorService" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Util.Concurrent.AbstractExecutorService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("java/util/concurrent/ThreadPoolExecutor", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="1">
    <summary>An <c><see cref="T:Java.Util.Concurrent.IExecutorService" /></c> that executes each submitted task using
 one of possibly several pooled threads, normally configured
 using <c><see cref="T:Java.Util.Concurrent.Executors" /></c> factory methods.</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">An <c><see cref="T:Java.Util.Concurrent.IExecutorService" /></c> that executes each submitted task using
 one of possibly several pooled threads, normally configured
 using <c><see cref="T:Java.Util.Concurrent.Executors" /></c> factory methods.

 </para>
      <para tool="javadoc-to-mdoc">Thread pools address two different problems: they usually
 provide improved performance when executing large numbers of
 asynchronous tasks, due to reduced per-task invocation overhead,
 and they provide a means of bounding and managing the resources,
 including threads, consumed when executing a collection of tasks.
 Each <c>ThreadPoolExecutor</c> also maintains some basic
 statistics, such as the number of completed tasks.

 </para>
      <para tool="javadoc-to-mdoc">To be useful across a wide range of contexts, this class
 provides many adjustable parameters and extensibility
 hooks. However, programmers are urged to use the more convenient
 <c><see cref="T:Java.Util.Concurrent.Executors" /></c> factory methods <c><see cref="M:Java.Util.Concurrent.Executors.NewCachedThreadPool" /></c> (unbounded thread pool, with
 automatic thread reclamation), <c><see cref="M:Java.Util.Concurrent.Executors.NewFixedThreadPool(System.Int32)" /></c>
 (fixed size thread pool) and <c><see cref="M:Java.Util.Concurrent.Executors.NewSingleThreadExecutor" /></c> (single background thread), that
 preconfigure settings for the most common usage
 scenarios. Otherwise, use the following guide when manually
 configuring and tuning this class:

 <format type="text/html"><dl><dt>Core and maximum pool sizes</dt><dd>A <c>ThreadPoolExecutor</c> will automatically adjust the
 pool size (see <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.PoolSize" /></c>)
 according to the bounds set by
 corePoolSize (see <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c>) and
 maximumPoolSize (see <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.MaximumPoolSize" /></c>).

 When a new task is submitted in method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Execute(Java.Lang.IRunnable)" /></c>,
 and fewer than corePoolSize threads are running, a new thread is
 created to handle the request, even if other worker threads are
 idle.  If there are more than corePoolSize but less than
 maximumPoolSize threads running, a new thread will be created only
 if the queue is full.  By setting corePoolSize and maximumPoolSize
 the same, you create a fixed-size thread pool. By setting
 maximumPoolSize to an essentially unbounded value such as <c>Integer.MAX_VALUE</c>, you allow the pool to accommodate an arbitrary
 number of concurrent tasks. Most typically, core and maximum pool
 sizes are set only upon construction, but they may also be changed
 dynamically using <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c> and <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.MaximumPoolSize" /></c>. </dd><dt>On-demand construction</dt><dd>By default, even core threads are initially created and
 started only when new tasks arrive, but this can be overridden
 dynamically using method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.PrestartCoreThread" /></c> or <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.PrestartAllCoreThreads" /></c>.  You probably want to prestart threads if
 you construct the pool with a non-empty queue. </dd><dt>Creating new threads</dt><dd>New threads are created using a <c><see cref="T:Java.Util.Concurrent.IThreadFactory" /></c>.  If not
 otherwise specified, a <c><see cref="M:Java.Util.Concurrent.Executors.DefaultThreadFactory" /></c> is
 used, that creates threads to all be in the same <c><see cref="T:Java.Lang.ThreadGroup" /></c> and with the same <c>NORM_PRIORITY</c> priority and
 non-daemon status. By supplying a different ThreadFactory, you can
 alter the thread's name, thread group, priority, daemon status,
 etc. If a <c>ThreadFactory</c> fails to create a thread when asked
 by returning null from <c>newThread</c>, the executor will
 continue, but might not be able to execute any tasks.</dd><dt>Keep-alive times</dt><dd>If the pool currently has more than corePoolSize threads,
 excess threads will be terminated if they have been idle for more
 than the keepAliveTime (see <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.GetKeepAliveTime(Java.Util.Concurrent.TimeUnit)" /></c>).
 This provides a means of reducing resource consumption when the
 pool is not being actively used. If the pool becomes more active
 later, new threads will be constructed. This parameter can also be
 changed dynamically using method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.SetKeepAliveTime(System.Int64, Java.Util.Concurrent.TimeUnit)" /></c>.  Using a value of <c>Long.MAX_VALUE</c><c><see cref="P:Java.Util.Concurrent.TimeUnit.Nanoseconds" /></c> effectively disables idle threads from ever
 terminating prior to shut down. By default, the keep-alive policy
 applies only when there are more than corePoolSize threads. But
 method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.AllowCoreThreadTimeOut(System.Boolean)" /></c> can be used to
 apply this time-out policy to core threads as well, so long as the
 keepAliveTime value is non-zero. </dd><dt>Queuing</dt><dd>Any <c><see cref="T:Java.Util.Concurrent.IBlockingQueue" /></c> may be used to transfer and hold
 submitted tasks.  The use of this queue interacts with pool sizing:

 <list type="bullet"><item><term> If fewer than corePoolSize threads are running, the Executor
 always prefers adding a new thread
 rather than queuing.</term></item><item><term> If corePoolSize or more threads are running, the Executor
 always prefers queuing a request rather than adding a new
 thread.</term></item><item><term> If a request cannot be queued, a new thread is created unless
 this would exceed maximumPoolSize, in which case, the task will be
 rejected.</term></item></list>

 There are three general strategies for queuing:
 <list type="number"><item><term><i> Direct handoffs.</i> A good default choice for a work
 queue is a <c><see cref="T:Java.Util.Concurrent.SynchronousQueue" /></c> that hands off tasks to threads
 without otherwise holding them. Here, an attempt to queue a task
 will fail if no threads are immediately available to run it, so a
 new thread will be constructed. This policy avoids lockups when
 handling sets of requests that might have internal dependencies.
 Direct handoffs generally require unbounded maximumPoolSizes to
 avoid rejection of new submitted tasks. This in turn admits the
 possibility of unbounded thread growth when commands continue to
 arrive on average faster than they can be processed.  </term></item><item><term><i> Unbounded queues.</i> Using an unbounded queue (for
 example a <c><see cref="T:Java.Util.Concurrent.LinkedBlockingQueue" /></c> without a predefined
 capacity) will cause new tasks to wait in the queue when all
 corePoolSize threads are busy. Thus, no more than corePoolSize
 threads will ever be created. (And the value of the maximumPoolSize
 therefore doesn't have any effect.)  This may be appropriate when
 each task is completely independent of others, so tasks cannot
 affect each others execution; for example, in a web page server.
 While this style of queuing can be useful in smoothing out
 transient bursts of requests, it admits the possibility of
 unbounded work queue growth when commands continue to arrive on
 average faster than they can be processed.  </term></item><item><term><i>Bounded queues.</i> A bounded queue (for example, an
 <c><see cref="T:Java.Util.Concurrent.ArrayBlockingQueue" /></c>) helps prevent resource exhaustion when
 used with finite maximumPoolSizes, but can be more difficult to
 tune and control.  Queue sizes and maximum pool sizes may be traded
 off for each other: Using large queues and small pools minimizes
 CPU usage, OS resources, and context-switching overhead, but can
 lead to artificially low throughput.  If tasks frequently block (for
 example if they are I/O bound), a system may be able to schedule
 time for more threads than you otherwise allow. Use of small queues
 generally requires larger pool sizes, which keeps CPUs busier but
 may encounter unacceptable scheduling overhead, which also
 decreases throughput.  </term></item></list></dd><dt>Rejected tasks</dt><dd>New tasks submitted in method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Execute(Java.Lang.IRunnable)" /></c> will be
 <i>rejected</i> when the Executor has been shut down, and also when
 the Executor uses finite bounds for both maximum threads and work queue
 capacity, and is saturated.  In either case, the <c>execute</c> method
 invokes the <c><see cref="M:Java.Util.Concurrent.IRejectedExecutionHandler.RejectedExecution(Java.Lang.IRunnable, Java.Util.Concurrent.ThreadPoolExecutor)" /></c>
 method of its <c><see cref="T:Java.Util.Concurrent.IRejectedExecutionHandler" /></c>.  Four predefined handler
 policies are provided:

 <list type="number"><item><term> In the default <c><see cref="!:NoType:java/util/concurrent/ThreadPoolExecutor$AbortPolicy;Href=../../../../reference/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" /></c>, the
 handler throws a runtime <c><see cref="T:Java.Util.Concurrent.RejectedExecutionException" /></c> upon
 rejection. </term></item><item><term> In <c><see cref="!:NoType:java/util/concurrent/ThreadPoolExecutor$CallerRunsPolicy;Href=../../../../reference/java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" /></c>, the thread
 that invokes <c>execute</c> itself runs the task. This provides a
 simple feedback control mechanism that will slow down the rate that
 new tasks are submitted. </term></item><item><term> In <c><see cref="!:NoType:java/util/concurrent/ThreadPoolExecutor$DiscardPolicy;Href=../../../../reference/java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" /></c>, a task that
 cannot be executed is simply dropped.  </term></item><item><term>In <c><see cref="!:NoType:java/util/concurrent/ThreadPoolExecutor$DiscardOldestPolicy;Href=../../../../reference/java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" /></c>, if the
 executor is not shut down, the task at the head of the work queue
 is dropped, and then execution is retried (which can fail again,
 causing this to be repeated.) </term></item></list>

 It is possible to define and use other kinds of <c><see cref="T:Java.Util.Concurrent.IRejectedExecutionHandler" /></c> classes. Doing so requires some care
 especially when policies are designed to work only under particular
 capacity or queuing policies. </dd><dt>Hook methods</dt><dd>This class provides <c>protected</c> overridable
 <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.BeforeExecute(Java.Lang.Thread, Java.Lang.IRunnable)" /></c> and
 <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.AfterExecute(Java.Lang.IRunnable, Java.Lang.Throwable)" /></c> methods that are called
 before and after execution of each task.  These can be used to
 manipulate the execution environment; for example, reinitializing
 ThreadLocals, gathering statistics, or adding log entries.
 Additionally, method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Terminated" /></c> can be overridden to perform
 any special processing that needs to be done once the Executor has
 fully terminated.

 If hook or callback methods throw exceptions, internal worker
 threads may in turn fail and abruptly terminate.</dd><dt>Queue maintenance</dt><dd>Method <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.Queue" /></c> allows access to the work queue
 for purposes of monitoring and debugging.  Use of this method for
 any other purpose is strongly discouraged.  Two supplied methods,
 <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Remove(Java.Lang.IRunnable)" /></c> and <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Purge" /></c> are available to
 assist in storage reclamation when large numbers of queued tasks
 become cancelled.</dd><dt>Finalization</dt><dd>A pool that is no longer referenced in a program <i>AND</i>
 has no remaining threads will be <c>shutdown</c> automatically. If
 you would like to ensure that unreferenced pools are reclaimed even
 if users forget to call <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Shutdown" /></c>, then you must arrange
 that unused threads eventually die, by setting appropriate
 keep-alive times, using a lower bound of zero core threads and/or
 setting <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.AllowCoreThreadTimeOut(System.Boolean)" /></c>.  </dd></dl></format></para>
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <b>Extension example</b>
        </format>. Most extensions of this class
 override one or more of the protected hook methods. For example,
 here is a subclass that adds a simple pause/resume feature:

  <example><code lang="java">class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); 

   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch (InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }

   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }

   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }}</code></example></para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ThreadPoolExecutor (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject``1(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, Java.Util.Concurrent.TimeUnit unit, Java.Util.Concurrent.IBlockingQueue workQueue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 corePoolSize, int32 maximumPoolSize, int64 keepAliveTime, class Java.Util.Concurrent.TimeUnit unit, class Java.Util.Concurrent.IBlockingQueue workQueue) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="corePoolSize" Type="System.Int32" />
        <Parameter Name="maximumPoolSize" Type="System.Int32" />
        <Parameter Name="keepAliveTime" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
        <Parameter Name="workQueue" Type="Java.Util.Concurrent.IBlockingQueue" />
      </Parameters>
      <Docs>
        <param name="corePoolSize">To be added.</param>
        <param name="maximumPoolSize">To be added.</param>
        <param name="keepAliveTime">To be added.</param>
        <param name="unit">To be added.</param>
        <param name="workQueue">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, Java.Util.Concurrent.TimeUnit unit, Java.Util.Concurrent.IBlockingQueue workQueue, Java.Util.Concurrent.IRejectedExecutionHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 corePoolSize, int32 maximumPoolSize, int64 keepAliveTime, class Java.Util.Concurrent.TimeUnit unit, class Java.Util.Concurrent.IBlockingQueue workQueue, class Java.Util.Concurrent.IRejectedExecutionHandler handler) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue;Ljava/util/concurrent/RejectedExecutionHandler;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="corePoolSize" Type="System.Int32" />
        <Parameter Name="maximumPoolSize" Type="System.Int32" />
        <Parameter Name="keepAliveTime" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
        <Parameter Name="workQueue" Type="Java.Util.Concurrent.IBlockingQueue" />
        <Parameter Name="handler" Type="Java.Util.Concurrent.IRejectedExecutionHandler" />
      </Parameters>
      <Docs>
        <param name="corePoolSize">To be added.</param>
        <param name="maximumPoolSize">To be added.</param>
        <param name="keepAliveTime">To be added.</param>
        <param name="unit">To be added.</param>
        <param name="workQueue">To be added.</param>
        <param name="handler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, Java.Util.Concurrent.TimeUnit unit, Java.Util.Concurrent.IBlockingQueue workQueue, Java.Util.Concurrent.IThreadFactory threadFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 corePoolSize, int32 maximumPoolSize, int64 keepAliveTime, class Java.Util.Concurrent.TimeUnit unit, class Java.Util.Concurrent.IBlockingQueue workQueue, class Java.Util.Concurrent.IThreadFactory threadFactory) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue;Ljava/util/concurrent/ThreadFactory;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="corePoolSize" Type="System.Int32" />
        <Parameter Name="maximumPoolSize" Type="System.Int32" />
        <Parameter Name="keepAliveTime" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
        <Parameter Name="workQueue" Type="Java.Util.Concurrent.IBlockingQueue" />
        <Parameter Name="threadFactory" Type="Java.Util.Concurrent.IThreadFactory" />
      </Parameters>
      <Docs>
        <param name="corePoolSize">To be added.</param>
        <param name="maximumPoolSize">To be added.</param>
        <param name="keepAliveTime">To be added.</param>
        <param name="unit">To be added.</param>
        <param name="workQueue">To be added.</param>
        <param name="threadFactory">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, Java.Util.Concurrent.TimeUnit unit, Java.Util.Concurrent.IBlockingQueue workQueue, Java.Util.Concurrent.IThreadFactory threadFactory, Java.Util.Concurrent.IRejectedExecutionHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 corePoolSize, int32 maximumPoolSize, int64 keepAliveTime, class Java.Util.Concurrent.TimeUnit unit, class Java.Util.Concurrent.IBlockingQueue workQueue, class Java.Util.Concurrent.IThreadFactory threadFactory, class Java.Util.Concurrent.IRejectedExecutionHandler handler) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(IIJLjava/util/concurrent/TimeUnit;Ljava/util/concurrent/BlockingQueue;Ljava/util/concurrent/ThreadFactory;Ljava/util/concurrent/RejectedExecutionHandler;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="corePoolSize" Type="System.Int32" />
        <Parameter Name="maximumPoolSize" Type="System.Int32" />
        <Parameter Name="keepAliveTime" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
        <Parameter Name="workQueue" Type="Java.Util.Concurrent.IBlockingQueue" />
        <Parameter Name="threadFactory" Type="Java.Util.Concurrent.IThreadFactory" />
        <Parameter Name="handler" Type="Java.Util.Concurrent.IRejectedExecutionHandler" />
      </Parameters>
      <Docs>
        <param name="corePoolSize">To be added.</param>
        <param name="maximumPoolSize">To be added.</param>
        <param name="keepAliveTime">To be added.</param>
        <param name="unit">To be added.</param>
        <param name="workQueue">To be added.</param>
        <param name="threadFactory">To be added.</param>
        <param name="handler">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveCount">
      <MemberSignature Language="C#" Value="public virtual int ActiveCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ActiveCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getActiveCount", "()I", "GetGetActiveCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the approximate number of threads that are actively
 executing tasks.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the approximate number of threads that are actively
 executing tasks.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getActiveCount()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="AfterExecute">
      <MemberSignature Language="C#" Value="protected virtual void AfterExecute (Java.Lang.IRunnable r, Java.Lang.Throwable t);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AfterExecute(class Java.Lang.IRunnable r, class Java.Lang.Throwable t) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("afterExecute", "(Ljava/lang/Runnable;Ljava/lang/Throwable;)V", "GetAfterExecute_Ljava_lang_Runnable_Ljava_lang_Throwable_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="Java.Lang.IRunnable" />
        <Parameter Name="t" Type="Java.Lang.Throwable" />
      </Parameters>
      <Docs>
        <param name="r">the runnable that has completed</param>
        <param name="t">the exception that caused termination, or null if
 execution completed normally
</param>
        <summary>Method invoked upon completion of execution of the given Runnable.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Method invoked upon completion of execution of the given Runnable.
 This method is invoked by the thread that executed the task. If
 non-null, the Throwable is the uncaught <c>RuntimeException</c>
 or <c>Error</c> that caused execution to terminate abruptly.

 </para>
          <para tool="javadoc-to-mdoc">This implementation does nothing, but may be customized in
 subclasses. Note: To properly nest multiple overridings, subclasses
 should generally invoke <c>super.afterExecute</c> at the
 beginning of this method.

 </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <b>Note:</b>
            </format> When actions are enclosed in tasks (such as
 <c><see cref="T:Java.Util.Concurrent.FutureTask" /></c>) either explicitly or via methods such as
 <c>submit</c>, these task objects catch and maintain
 computational exceptions, and so they do not cause abrupt
 termination, and the internal exceptions are <i>not</i>
 passed to this method. If you would like to trap both kinds of
 failures in this method, you can further probe for such cases,
 as in this sample subclass that prints either the direct cause
 or the underlying exception if a task has been aborted:

  <example><code lang="java">class ExtendedExecutor extends ThreadPoolExecutor {
   // ...
   protected void afterExecute(Runnable r, Throwable t) {
     super.afterExecute(r, t);
     if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) {
       try {
         Object result = ((Future&lt;?&gt;) r).get();
        catch (CancellationException ce) {
           t = ce;
       } catch (ExecutionException ee) {
           t = ee.getCause();
       } catch (InterruptedException ie) {
           Thread.currentThread().interrupt(); // ignore/reset
       }
     }
     if (t != null)
       System.out.println(t);
   }
 }}</code></example></para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="AllowCoreThreadTimeOut">
      <MemberSignature Language="C#" Value="public virtual void AllowCoreThreadTimeOut (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AllowCoreThreadTimeOut(bool value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("allowCoreThreadTimeOut", "(Z)V", "GetAllowCoreThreadTimeOut_ZHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p0" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <c>true</c> if should time out, else <c>false</c></param>
        <summary>Sets the policy governing whether core threads may time out and
 terminate if no tasks arrive within the keep-alive time, being
 replaced if needed when new tasks arrive.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Sets the policy governing whether core threads may time out and
 terminate if no tasks arrive within the keep-alive time, being
 replaced if needed when new tasks arrive. When false, core
 threads are never terminated due to lack of incoming
 tasks. When true, the same keep-alive policy applying to
 non-core threads applies also to core threads. To avoid
 continual thread replacement, the keep-alive time must be
 greater than zero when setting <c>true</c>. This method
 should in general be called before the pool is actively used.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#allowCoreThreadTimeOut(boolean)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 9" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if value is <c>true</c>
         and the current keep-alive time is not greater than zero</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsCoreThreadTimeOut">
      <MemberSignature Language="C#" Value="public virtual bool AllowsCoreThreadTimeOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AllowsCoreThreadTimeOut() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("allowsCoreThreadTimeOut", "()Z", "GetAllowsCoreThreadTimeOutHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns true if this pool allows core threads to time out and
 terminate if no tasks arrive within the keepAlive time, being
 replaced if needed when new tasks arrive.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns true if this pool allows core threads to time out and
 terminate if no tasks arrive within the keepAlive time, being
 replaced if needed when new tasks arrive. When true, the same
 keep-alive policy applying to non-core threads applies also to
 core threads. When false (the default), core threads are never
 terminated due to lack of incoming tasks.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#allowsCoreThreadTimeOut()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 9" />
      </Docs>
    </Member>
    <Member MemberName="AwaitTermination">
      <MemberSignature Language="C#" Value="public override bool AwaitTermination (long timeout, Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool AwaitTermination(int64 timeout, class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("awaitTermination", "(JLjava/util/concurrent/TimeUnit;)Z", "GetAwaitTermination_JLjava_util_concurrent_TimeUnit_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="timeout">To be added.</param>
        <param name="unit">To be added.</param>
        <summary></summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#awaitTermination(long, java.util.concurrent.TimeUnit)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException" />
      </Docs>
    </Member>
    <Member MemberName="BeforeExecute">
      <MemberSignature Language="C#" Value="protected virtual void BeforeExecute (Java.Lang.Thread t, Java.Lang.IRunnable r);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void BeforeExecute(class Java.Lang.Thread t, class Java.Lang.IRunnable r) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("beforeExecute", "(Ljava/lang/Thread;Ljava/lang/Runnable;)V", "GetBeforeExecute_Ljava_lang_Thread_Ljava_lang_Runnable_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="Java.Lang.Thread" />
        <Parameter Name="r" Type="Java.Lang.IRunnable" />
      </Parameters>
      <Docs>
        <param name="t">the thread that will run task <c>r</c></param>
        <param name="r">the task that will be executed
</param>
        <summary>Method invoked prior to executing the given Runnable in the
 given thread.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Method invoked prior to executing the given Runnable in the
 given thread.  This method is invoked by thread <c>t</c> that
 will execute task <c>r</c>, and may be used to re-initialize
 ThreadLocals, or to perform logging.

 </para>
          <para tool="javadoc-to-mdoc">This implementation does nothing, but may be customized in
 subclasses. Note: To properly nest multiple overridings, subclasses
 should generally invoke <c>super.beforeExecute</c> at the end of
 this method.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="CompletedTaskCount">
      <MemberSignature Language="C#" Value="public virtual long CompletedTaskCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CompletedTaskCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getCompletedTaskCount", "()J", "GetGetCompletedTaskCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the approximate total number of tasks that have
 completed execution.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the approximate total number of tasks that have
 completed execution. Because the states of tasks and threads
 may change dynamically during computation, the returned value
 is only an approximation, but one that does not ever decrease
 across successive calls.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getCompletedTaskCount()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="CorePoolSize">
      <MemberSignature Language="C#" Value="public virtual int CorePoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CorePoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getCorePoolSize", "()I", "GetGetCorePoolSizeHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setCorePoolSize", "(I)V", "GetSetCorePoolSize_IHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the core number of threads.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Returns the core number of threads.</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Sets the core number of threads.  This overrides any value set
 in the constructor.  If the new value is smaller than the
 current value, excess existing threads will be terminated when
 they next become idle.  If larger, new threads will, if needed,
 be started to execute any queued tasks.</para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>corePoolSize </c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>corePoolSize </c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>corePoolSize </c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>corePoolSize </c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>corePoolSize </c></exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>corePoolSize </c></exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public override void Execute (Java.Lang.IRunnable command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Execute(class Java.Lang.IRunnable command) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("execute", "(Ljava/lang/Runnable;)V", "GetExecute_Ljava_lang_Runnable_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="Java.Lang.IRunnable" />
      </Parameters>
      <Docs>
        <param name="command">the task to execute</param>
        <summary>Executes the given task sometime in the future.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Executes the given task sometime in the future.  The task
 may execute in a new thread or in an existing pooled thread.

 If the task cannot be submitted for execution, either because this
 executor has been shutdown or because its capacity has been reached,
 the task is handled by the current <c>RejectedExecutionHandler</c>.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Util.Concurrent.RejectedExecutionException">at discretion of
         <c>RejectedExecutionHandler</c>, if the task
         cannot be accepted for execution</exception>
        <exception cref="T:Java.Lang.NullPointerException">if <c>command</c> is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="GetKeepAliveTime">
      <MemberSignature Language="C#" Value="public virtual long GetKeepAliveTime (Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetKeepAliveTime(class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getKeepAliveTime", "(Ljava/util/concurrent/TimeUnit;)J", "GetGetKeepAliveTime_Ljava_util_concurrent_TimeUnit_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="unit">the desired time unit of the result</param>
        <summary>Returns the thread keep-alive time, which is the amount of time
 that threads in excess of the core pool size may remain
 idle before being terminated.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the thread keep-alive time, which is the amount of time
 that threads in excess of the core pool size may remain
 idle before being terminated.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Java.Util.Concurrent.ThreadPoolExecutor.SetKeepAliveTime(System.Int64, Java.Util.Concurrent.TimeUnit)" />
      </Docs>
    </Member>
    <Member MemberName="IsShutdown">
      <MemberSignature Language="C#" Value="public override bool IsShutdown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isShutdown", "()Z", "GetIsShutdownHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary></summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#isShutdown()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminated">
      <MemberSignature Language="C#" Value="public override bool IsTerminated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isTerminated", "()Z", "GetIsTerminatedHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary></summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#isTerminated()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public virtual bool IsTerminating { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isTerminating", "()Z", "GetIsTerminatingHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns true if this executor is in the process of terminating
 after <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Shutdown" /></c> or <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.ShutdownNow" /></c> but has not
 completely terminated.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns true if this executor is in the process of terminating
 after <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Shutdown" /></c> or <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.ShutdownNow" /></c> but has not
 completely terminated.  This method may be useful for
 debugging. A return of <c>true</c> reported a sufficient
 period after shutdown may indicate that submitted tasks have
 ignored or suppressed interruption, causing this executor not
 to properly terminate.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#isTerminating()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="LargestPoolSize">
      <MemberSignature Language="C#" Value="public virtual int LargestPoolSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LargestPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getLargestPoolSize", "()I", "GetGetLargestPoolSizeHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the largest number of threads that have ever
 simultaneously been in the pool.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the largest number of threads that have ever
 simultaneously been in the pool.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getLargestPoolSize()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="MaximumPoolSize">
      <MemberSignature Language="C#" Value="public virtual int MaximumPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getMaximumPoolSize", "()I", "GetGetMaximumPoolSizeHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setMaximumPoolSize", "(I)V", "GetSetMaximumPoolSize_IHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the maximum allowed number of threads.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Returns the maximum allowed number of threads.</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Sets the maximum allowed number of threads. This overrides any
 value set in the constructor. If the new value is smaller than
 the current value, excess existing threads will be
 terminated when they next become idle.</para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if the new maximum is
         less than or equal to zero, or
         less than the <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the new maximum is
         less than or equal to zero, or
         less than the <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the new maximum is
         less than or equal to zero, or
         less than the <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the new maximum is
         less than or equal to zero, or
         less than the <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c></exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the new maximum is
         less than or equal to zero, or
         less than the <c><see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></c></exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.MaximumPoolSize" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if the new maximum is
         less than or equal to zero, or
         less than the <see cref="P:Java.Util.Concurrent.ThreadPoolExecutor.CorePoolSize" /></exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.MaximumPoolSize" />
      </Docs>
    </Member>
    <Member MemberName="PoolSize">
      <MemberSignature Language="C#" Value="public virtual int PoolSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getPoolSize", "()I", "GetGetPoolSizeHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the current number of threads in the pool.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the current number of threads in the pool.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="PrestartAllCoreThreads">
      <MemberSignature Language="C#" Value="public virtual int PrestartAllCoreThreads ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 PrestartAllCoreThreads() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("prestartAllCoreThreads", "()I", "GetPrestartAllCoreThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts all core threads, causing them to idly wait for work.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Starts all core threads, causing them to idly wait for work. This
 overrides the default policy of starting core threads only when
 new tasks are executed.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="PrestartCoreThread">
      <MemberSignature Language="C#" Value="public virtual bool PrestartCoreThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PrestartCoreThread() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("prestartCoreThread", "()Z", "GetPrestartCoreThreadHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts a core thread, causing it to idly wait for work.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Starts a core thread, causing it to idly wait for work. This
 overrides the default policy of starting core threads only when
 new tasks are executed. This method will return <c>false</c>
 if all core threads have already been started.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public virtual void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Purge() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("purge", "()V", "GetPurgeHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tries to remove from the work queue all <c><see cref="T:Java.Util.Concurrent.IFuture" /></c>
 tasks that have been cancelled.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Tries to remove from the work queue all <c><see cref="T:Java.Util.Concurrent.IFuture" /></c>
 tasks that have been cancelled. This method can be useful as a
 storage reclamation operation, that has no other impact on
 functionality. Cancelled tasks are never executed, but may
 accumulate in work queues until worker threads can actively
 remove them. Invoking this method instead tries to remove them now.
 However, this method may fail to remove tasks in
 the presence of interference by other threads.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#purge()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Queue">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.IBlockingQueue Queue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Util.Concurrent.IBlockingQueue Queue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueue", "()Ljava/util/concurrent/BlockingQueue;", "GetGetQueueHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.IBlockingQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the task queue used by this executor.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the task queue used by this executor. Access to the
 task queue is intended primarily for debugging and monitoring.
 This queue may be in active use.  Retrieving the task queue
 does not prevent queued tasks from executing.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getQueue()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="RejectedExecutionHandler">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.IRejectedExecutionHandler RejectedExecutionHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Util.Concurrent.IRejectedExecutionHandler RejectedExecutionHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getRejectedExecutionHandler", "()Ljava/util/concurrent/RejectedExecutionHandler;", "GetGetRejectedExecutionHandlerHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setRejectedExecutionHandler", "(Ljava/util/concurrent/RejectedExecutionHandler;)V", "GetSetRejectedExecutionHandler_Ljava_util_concurrent_RejectedExecutionHandler_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.IRejectedExecutionHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the current handler for unexecutable tasks.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Returns the current handler for unexecutable tasks.</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Sets a new handler for unexecutable tasks.</para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.NullPointerException">if handler is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if handler is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if handler is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if handler is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if handler is null</exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.RejectedExecutionHandler" />
        <exception cref="T:Java.Lang.NullPointerException">if handler is null</exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.RejectedExecutionHandler" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual bool Remove (Java.Lang.IRunnable task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(class Java.Lang.IRunnable task) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("remove", "(Ljava/lang/Runnable;)Z", "GetRemove_Ljava_lang_Runnable_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="Java.Lang.IRunnable" />
      </Parameters>
      <Docs>
        <param name="task">the task to remove</param>
        <summary>Removes this task from the executor's internal queue if it is
 present, thus causing it not to be run if it has not already
 started.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Removes this task from the executor's internal queue if it is
 present, thus causing it not to be run if it has not already
 started.

 </para>
          <para tool="javadoc-to-mdoc">This method may be useful as one part of a cancellation
 scheme.  It may fail to remove tasks that have been converted
 into other forms before being placed on the internal queue. For
 example, a task entered using <c>submit</c> might be
 converted into a form that maintains <c>Future</c> status.
 However, in such cases, method <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.Purge" /></c> may be used to
 remove those Futures that have been cancelled.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="SetKeepAliveTime">
      <MemberSignature Language="C#" Value="public virtual void SetKeepAliveTime (long time, Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetKeepAliveTime(int64 time, class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("setKeepAliveTime", "(JLjava/util/concurrent/TimeUnit;)V", "GetSetKeepAliveTime_JLjava_util_concurrent_TimeUnit_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="time" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="time">the time to wait.  A time value of zero will cause
        excess threads to terminate immediately after executing tasks.</param>
        <param name="unit">the time unit of the <c>time</c> argument</param>
        <summary>Sets the time limit for which threads may remain idle before
 being terminated.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Sets the time limit for which threads may remain idle before
 being terminated.  If there are more than the core number of
 threads currently in the pool, after waiting this amount of
 time without processing a task, excess threads will be
 terminated.  This overrides any value set in the constructor.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>time</c> less than zero or
         if <c>time</c> is zero and <c>allowsCoreThreadTimeOut</c></exception>
        <altmember cref="M:Java.Util.Concurrent.ThreadPoolExecutor.GetKeepAliveTime(Java.Util.Concurrent.TimeUnit)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public override void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Shutdown() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("shutdown", "()V", "GetShutdownHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initiates an orderly shutdown in which previously submitted
 tasks are executed, but no new tasks will be accepted.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Initiates an orderly shutdown in which previously submitted
 tasks are executed, but no new tasks will be accepted.
 Invocation has no additional effect if already shut down.

 </para>
          <para tool="javadoc-to-mdoc">This method does not wait for previously submitted tasks to
 complete execution.  Use <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.AwaitTermination(System.Int64, Java.Util.Concurrent.TimeUnit)" /></c>
 to do that.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#shutdown()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownNow">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;Java.Lang.IRunnable&gt; ShutdownNow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class Java.Lang.IRunnable&gt; ShutdownNow() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("shutdownNow", "()Ljava/util/List;", "GetShutdownNowHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Java.Lang.IRunnable&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Attempts to stop all actively executing tasks, halts the
 processing of waiting tasks, and returns a list of the tasks
 that were awaiting execution.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Attempts to stop all actively executing tasks, halts the
 processing of waiting tasks, and returns a list of the tasks
 that were awaiting execution. These tasks are drained (removed)
 from the task queue upon return from this method.

 </para>
          <para tool="javadoc-to-mdoc">This method does not wait for actively executing tasks to
 terminate.  Use <c><see cref="M:Java.Util.Concurrent.ThreadPoolExecutor.AwaitTermination(System.Int64, Java.Util.Concurrent.TimeUnit)" /></c> to
 do that.

 </para>
          <para tool="javadoc-to-mdoc">There are no guarantees beyond best-effort attempts to stop
 processing actively executing tasks.  This implementation
 cancels tasks via <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>, so any task that
 fails to respond to interrupts may never terminate.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#shutdownNow()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="TaskCount">
      <MemberSignature Language="C#" Value="public virtual long TaskCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 TaskCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getTaskCount", "()J", "GetGetTaskCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the approximate total number of tasks that have ever been
 scheduled for execution.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Returns the approximate total number of tasks that have ever been
 scheduled for execution. Because the states of tasks and
 threads may change dynamically during computation, the returned
 value is only an approximation.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getTaskCount()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Terminated">
      <MemberSignature Language="C#" Value="protected virtual void Terminated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Terminated() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("terminated", "()V", "GetTerminatedHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Method invoked when the Executor has terminated.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Method invoked when the Executor has terminated.  Default
 implementation does nothing. Note: To properly nest multiple
 overridings, subclasses should generally invoke
 <c>super.terminated</c> within this method.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#terminated()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ThreadFactory">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.IThreadFactory ThreadFactory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Util.Concurrent.IThreadFactory ThreadFactory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getThreadFactory", "()Ljava/util/concurrent/ThreadFactory;", "GetGetThreadFactoryHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: Android.Runtime.Register("setThreadFactory", "(Ljava/util/concurrent/ThreadFactory;)V", "GetSetThreadFactory_Ljava_util_concurrent_ThreadFactory_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.IThreadFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the thread factory used to create new threads.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc: Get method documentation">
            <format type="text/html">
              <b>Get method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()" target="_blank">[Android Documentation]</a>
              <br />
            </format>Returns the thread factory used to create new threads.</para>
          <para tool="javadoc-to-mdoc: Set method documentation">
            <format type="text/html">
              <b>Set method documentation</b>
              <a href="http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)" target="_blank">[Android Documentation]</a>
              <br />
            </format>Sets the thread factory used to create new threads.</para>
        </remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.NullPointerException">if threadFactory is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if threadFactory is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if threadFactory is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if threadFactory is null</exception>
        <exception cref="T:Java.Lang.NullPointerException">if threadFactory is null</exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.ThreadFactory" />
        <exception cref="T:Java.Lang.NullPointerException">if threadFactory is null</exception>
        <altmember cref="P:Java.Util.Concurrent.ThreadPoolExecutor.ThreadFactory" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonvirtualVoidMethod" tool="ReplaceLinkValue" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>