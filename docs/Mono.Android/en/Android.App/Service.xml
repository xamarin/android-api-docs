<Type Name="Service" FullName="Android.App.Service">
  <TypeSignature Language="C#" Value="public abstract class Service : Android.Content.ContextWrapper, Android.Content.IComponentCallbacks2, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Service extends Android.Content.ContextWrapper implements class Android.Content.IComponentCallbacks, class Android.Content.IComponentCallbacks2, class Android.Runtime.IJavaObject, class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Android.Content.ContextWrapper</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Android.Content.IComponentCallbacks2</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("android/app/Service", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="1">
    <summary>A Service is an application component representing either an application's desire
 to perform a longer-running operation while not interacting with the user
 or to supply functionality for other applications to use.</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">A Service is an application component representing either an application's desire
 to perform a longer-running operation while not interacting with the user
 or to supply functionality for other applications to use.  Each service
 class must have a corresponding
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestService" /></c>
 declaration in its package's <c>AndroidManifest.xml</c>.  Services
 can be started with
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c> and
 <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c>.
 
 </para>
      <para tool="javadoc-to-mdoc">Note that services, like other application objects, run in the main
 thread of their hosting process.  This means that, if your service is going
 to do any CPU intensive (such as MP3 playback) or blocking (such as
 networking) operations, it should spawn its own thread in which to do that
 work.  More information on this can be found in
 <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/fundamentals/processes-and-threads.html">Processes and
 Threads</a></format>.  The <c><see cref="!:NoType:android/app/IntentService;Href=../../../reference/android/app/IntentService.html" /></c> class is available
 as a standard implementation of Service that has its own thread where it
 schedules its work to be done.</para>
      <para tool="javadoc-to-mdoc">Topics covered here:
 <list type="number"><item><term></term></item><item><term></term></item><item><term></term></item><item><term></term></item><item><term></term></item><item><term></term></item></list><format type="text/html"><h3>Developer Guides</h3></format></para>
      <para tool="javadoc-to-mdoc">For a detailed discussion about how to create services, read the
 <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/fundamentals/services.html">Services</a></format> developer guide.</para>
      <format type="text/html">
        <h3>What is a Service?</h3>
      </format>
      <para tool="javadoc-to-mdoc">Most confusion about the Service class actually revolves around what
 it is <i>not</i>:</para>
      <list type="bullet">
        <item>
          <term> A Service is <format type="text/html"><b>not</b></format> a separate process.  The Service object itself
 does not imply it is running in its own process; unless otherwise specified,
 it runs in the same process as the application it is part of.
 </term>
        </item>
        <item>
          <term> A Service is <format type="text/html"><b>not</b></format> a thread.  It is not a means itself to do work off
 of the main thread (to avoid Application Not Responding errors).
 </term>
        </item>
      </list>
      <para tool="javadoc-to-mdoc">Thus a Service itself is actually very simple, providing two main features:<list type="bullet"><item><term>A facility for the application to tell the system <i>about</i>
 something it wants to be doing in the background (even when the user is not
 directly interacting with the application).  This corresponds to calls to
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c>, which
 ask the system to schedule work for the service, to be run until the service
 or someone else explicitly stop it.
 </term></item><item><term>A facility for an application to expose some of its functionality to
 other applications.  This corresponds to calls to
 <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c>, which
 allows a long-standing connection to be made to the service in order to
 interact with it.
 </term></item></list></para>
      <para tool="javadoc-to-mdoc">When a Service component is actually created, for either of these reasons,
 all that the system actually does is instantiate the component
 and call its <c><see cref="M:Android.App.Service.OnCreate" /></c> and any other appropriate callbacks on the
 main thread.  It is up to the Service to implement these with the appropriate
 behavior, such as creating a secondary thread in which it does its work.</para>
      <para tool="javadoc-to-mdoc">Note that because Service itself is so simple, you can make your
 interaction with it as simple or complicated as you want: from treating it
 as a local Java object that you make direct method calls on (as illustrated
 by ), to providing
 a full remoteable interface using AIDL.<format type="text/html"><h3>Service Lifecycle</h3></format></para>
      <para tool="javadoc-to-mdoc">There are two reasons that a service can be run by the system.  If someone
 calls <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c> then the system will
 retrieve the service (creating it and calling its <c><see cref="M:Android.App.Service.OnCreate" /></c> method
 if needed) and then call its <c><see cref="M:Android.App.Service.OnStartCommand(Android.Content.Intent, Android.App.StartCommandFlags, Android.App.StartCommandFlags)" /></c> method with the
 arguments supplied by the client.  The service will at this point continue
 running until <c><see cref="M:Android.Content.Context.StopService(Android.Content.Intent)" /></c> or
 <c><see cref="M:Android.App.Service.StopSelf" /></c> is called.  Note that multiple calls to
 Context.startService() do not nest (though they do result in multiple corresponding
 calls to onStartCommand()), so no matter how many times it is started a service
 will be stopped once Context.stopService() or stopSelf() is called; however,
 services can use their <c><see cref="M:Android.App.Service.StopSelf(System.Int32)" /></c> method to ensure the service is
 not stopped until started intents have been processed.
 
 </para>
      <para tool="javadoc-to-mdoc">For started services, there are two additional major modes of operation
 they can decide to run in, depending on the value they return from
 onStartCommand(): <c><see cref="!:Android.App.Service.START_STICKY" /></c> is used for services that are
 explicitly started and stopped as needed, while <c><see cref="!:Android.App.Service.START_NOT_STICKY" /></c>
 or <c><see cref="!:Android.App.Service.START_REDELIVER_INTENT" /></c> are used for services that should only
 remain running while processing any commands sent to them.  See the linked
 documentation for more detail on the semantics.
 
 </para>
      <para tool="javadoc-to-mdoc">Clients can also use <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c> to
 obtain a persistent connection to a service.  This likewise creates the
 service if it is not already running (calling <c><see cref="M:Android.App.Service.OnCreate" /></c> while
 doing so), but does not call onStartCommand().  The client will receive the
 <c><see cref="T:Android.OS.BinderConsts" /></c> object that the service returns from its
 <c><see cref="M:Android.App.Service.OnBind(Android.Content.Intent)" /></c> method, allowing the client to then make calls back
 to the service.  The service will remain running as long as the connection
 is established (whether or not the client retains a reference on the
 service's IBinder).  Usually the IBinder returned is for a complex
 interface that has been <format type="text/html"><a href="http://developer.android.com/reference/../guide/components/aidl.html">written
 in aidl</a></format>.
 
 </para>
      <para tool="javadoc-to-mdoc">A service can be both started and have connections bound to it.  In such
 a case, the system will keep the service running as long as either it is
 started <i>or</i> there are one or more connections to it with the
 <c><see cref="!:Android.Content.Context.BIND_AUTO_CREATE" /></c>
 flag.  Once neither
 of these situations hold, the service's <c><see cref="M:Android.App.Service.OnDestroy" /></c> method is called
 and the service is effectively terminated.  All cleanup (stopping threads,
 unregistering receivers) should be complete upon returning from onDestroy().
 
 <format type="text/html"><h3>Permissions</h3></format></para>
      <para tool="javadoc-to-mdoc">Global access to a service can be enforced when it is declared in its
 manifest's <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestService" /></c>
 tag.  By doing so, other applications will need to declare a corresponding
 <c><see cref="!:NoType:android/R$styleable;Href=../../../reference/android/R.styleable.html#AndroidManifestUsesPermission" /></c>
 element in their own manifest to be able to start, stop, or bind to
 the service.

 </para>
      <para tool="javadoc-to-mdoc">As of <c><see cref="!:NoType:android/os/Build$VERSION_CODES;Href=../../../reference/android/os/Build.VERSION_CODES.html#GINGERBREAD" /></c>, when using
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c>, you can
 also set <c><see cref="!:Android.Content.Intent.FLAG_GRANT_READ_URI_PERMISSION" /></c> and/or <c><see cref="!:Android.Content.Intent.FLAG_GRANT_WRITE_URI_PERMISSION" /></c> on the Intent.  This will grant the
 Service temporary access to the specific URIs in the Intent.  Access will
 remain until the Service has called <c><see cref="M:Android.App.Service.StopSelf(System.Int32)" /></c> for that start
 command or a later one, or until the Service has been completely stopped.
 This works for granting access to the other apps that have not requested
 the permission protecting the Service, or even when the Service is not
 exported at all.

 </para>
      <para tool="javadoc-to-mdoc">In addition, a service can protect individual IPC calls into it with
 permissions, by calling the
 <c><see cref="M:Android.Content.ContextWrapper.CheckCallingPermission(System.String)" /></c>
 method before executing the implementation of that call.
 
 </para>
      <para tool="javadoc-to-mdoc">See the <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/security/security.html">Security and Permissions</a></format>
 document for more information on permissions and security in general.
 
 <format type="text/html"><h3>Process Lifecycle</h3></format></para>
      <para tool="javadoc-to-mdoc">The Android system will attempt to keep the process hosting a service
 around as long as the service has been started or has clients bound to it.
 When running low on memory and needing to kill existing processes, the
 priority of a process hosting the service will be the higher of the
 following possibilities:

 <list type="bullet"><item><term>If the service is currently executing code in its
 <c><see cref="M:Android.App.Service.OnCreate" /></c>, <c><see cref="M:Android.App.Service.OnStartCommand(Android.Content.Intent, Android.App.StartCommandFlags, Android.App.StartCommandFlags)" /></c>,
 or <c><see cref="M:Android.App.Service.OnDestroy" /></c> methods, then the hosting process will
 be a foreground process to ensure this code can execute without
 being killed.
 </term></item><item><term>If the service has been started, then its hosting process is considered
 to be less important than any processes that are currently visible to the
 user on-screen, but more important than any process not visible.  Because
 only a few processes are generally visible to the user, this means that
 the service should not be killed except in low memory conditions.  However, since
 the user is not directly aware of a background service, in that state it <i>is</i>
 considered a valid candidate to kill, and you should be prepared for this to
 happen.  In particular, long-running services will be increasingly likely to
 kill and are guaranteed to be killed (and restarted if appropriate) if they
 remain started long enough.
 </term></item><item><term>If there are clients bound to the service, then the service's hosting
 process is never less important than the most important client.  That is,
 if one of its clients is visible to the user, then the service itself is
 considered to be visible.  The way a client's importance impacts the service's
 importance can be adjusted through <c><see cref="!:Android.Content.Context.BIND_ABOVE_CLIENT" /></c>,
 <c><see cref="!:Android.Content.Context.BIND_ALLOW_OOM_MANAGEMENT" /></c>, <c><see cref="!:Android.Content.Context.BIND_WAIVE_PRIORITY" /></c>,
 <c><see cref="!:Android.Content.Context.BIND_IMPORTANT" /></c>, and <c><see cref="!:Android.Content.Context.BIND_ADJUST_WITH_ACTIVITY" /></c>.
 </term></item><item><term>A started service can use the <c><see cref="M:Android.App.Service.StartForeground(System.Int32, Android.App.Notification)" /></c>
 API to put the service in a foreground state, where the system considers
 it to be something the user is actively aware of and thus not a candidate
 for killing when low on memory.  (It is still theoretically possible for
 the service to be killed under extreme memory pressure from the current
 foreground application, but in practice this should not be a concern.)
 </term></item></list></para>
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc" />
      <para tool="javadoc-to-mdoc">Note this means that most of the time your service is running, it may
 be killed by the system if it is under heavy memory pressure.  If this
 happens, the system will later try to restart the service.  An important
 consequence of this is that if you implement <c><see cref="M:Android.App.Service.OnStartCommand(Android.Content.Intent, Android.App.StartCommandFlags, Android.App.StartCommandFlags)" /></c>
 to schedule work to be done asynchronously or in another thread, then you
 may want to use <c><see cref="!:Android.App.Service.START_FLAG_REDELIVERY" /></c> to have the system
 re-deliver an Intent for you so that it does not get lost if your service
 is killed while processing it.
 
 </para>
      <para tool="javadoc-to-mdoc">Other application components running in the same process as the service
 (such as an <c><see cref="T:Android.App.Activity" /></c>) can, of course, increase the
 importance of the overall
 process beyond just the importance of the service itself.
 
 <format type="text/html"><h3>Local Service Sample</h3></format></para>
      <para tool="javadoc-to-mdoc">One of the most common uses of a Service is as a secondary component
 running alongside other parts of an application, in the same process as
 the rest of the components.  All components of an .apk run in the same
 process unless explicitly stated otherwise, so this is a typical situation.
 
 </para>
      <para tool="javadoc-to-mdoc">When used in this way, by assuming the
 components are in the same process, you can greatly simplify the interaction
 between them: clients of the service can simply cast the IBinder they
 receive from it to a concrete class published by the service.
 
 </para>
      <para tool="javadoc-to-mdoc">An example of this use of a Service is shown here.  First is the Service
 itself, publishing a custom class when bound:
 
 <example><code lang="java">public class LocalService extends Service {
    private NotificationManager mNM;

    // Unique Identification Number for the Notification.
    // We use it on Notification start, and to cancel it.
    private int NOTIFICATION = R.string.local_service_started;

    /**
     * Class for clients to access.  Because we know this service always
     * runs in the same process as its clients, we don't need to deal with
     * IPC.
     */
    public class LocalBinder extends Binder {
        LocalService getService() {
            return LocalService.this;
        }
    }

    @Override
    public void onCreate() {
        mNM = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);

        // Display a notification about us starting.  We put an icon in the status bar.
        showNotification();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i("LocalService", "Received start id " + startId + ": " + intent);
        // We want this service to continue running until it is explicitly
        // stopped, so return sticky.
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        // Cancel the persistent notification.
        mNM.cancel(NOTIFICATION);

        // Tell the user we stopped.
        Toast.makeText(this, R.string.local_service_stopped, Toast.LENGTH_SHORT).show();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    // This is the object that receives interactions from clients.  See
    // RemoteService for a more complete example.
    private final IBinder mBinder = new LocalBinder();

    /**
     * Show a notification while this service is running.
     */
    private void showNotification() {
        // In this sample, we'll use the same text for the ticker and the expanded notification
        CharSequence text = getText(R.string.local_service_started);

        // Set the icon, scrolling text and timestamp
        Notification notification = new Notification(R.drawable.stat_sample, text,
                System.currentTimeMillis());

        // The PendingIntent to launch our activity if the user selects this notification
        PendingIntent contentIntent = PendingIntent.getActivity(this, 0,
                new Intent(this, LocalServiceActivities.Controller.class), 0);

        // Set the info for the views that show in the notification panel.
        notification.setLatestEventInfo(this, getText(R.string.local_service_label),
                       text, contentIntent);

        // Send the notification.
        mNM.notify(NOTIFICATION, notification);
    }
}</code></example></para>
      <para tool="javadoc-to-mdoc">With that done, one can now write client code that directly accesses the
 running service, such as:
 
 <example><code lang="java">private LocalService mBoundService;

private ServiceConnection mConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className, IBinder service) {
        // This is called when the connection with the service has been
        // established, giving us the service object we can use to
        // interact with the service.  Because we have bound to a explicit
        // service that we know is running in our own process, we can
        // cast its IBinder to a concrete class and directly access it.
        mBoundService = ((LocalService.LocalBinder)service).getService();

        // Tell the user about this for our demo.
        Toast.makeText(Binding.this, R.string.local_service_connected,
                Toast.LENGTH_SHORT).show();
    }

    public void onServiceDisconnected(ComponentName className) {
        // This is called when the connection with the service has been
        // unexpectedly disconnected -- that is, its process crashed.
        // Because it is running in our same process, we should never
        // see this happen.
        mBoundService = null;
        Toast.makeText(Binding.this, R.string.local_service_disconnected,
                Toast.LENGTH_SHORT).show();
    }
};

void doBindService() {
    // Establish a connection with the service.  We use an explicit
    // class name because we want a specific service implementation that
    // we know will be running in our own process (and thus won't be
    // supporting component replacement by other applications).
    bindService(new Intent(Binding.this, 
            LocalService.class), mConnection, Context.BIND_AUTO_CREATE);
    mIsBound = true;
}

void doUnbindService() {
    if (mIsBound) {
        // Detach our existing connection.
        unbindService(mConnection);
        mIsBound = false;
    }
}

@Override
protected void onDestroy() {
    super.onDestroy();
    doUnbindService();
}</code></example><format type="text/html"><h3>Remote Messenger Service Sample</h3></format></para>
      <para tool="javadoc-to-mdoc">If you need to be able to write a Service that can perform complicated
 communication with clients in remote processes (beyond simply the use of
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c> to send
 commands to it), then you can use the <c><see cref="T:Android.OS.Messenger" /></c> class
 instead of writing full AIDL files.
 
 </para>
      <para tool="javadoc-to-mdoc">An example of a Service that uses Messenger as its client interface
 is shown here.  First is the Service itself, publishing a Messenger to
 an internal Handler when bound:
 
 <example><code lang="java">public class MessengerService extends Service {
    /** For showing and hiding our notification. */
    NotificationManager mNM;
    /** Keeps track of all current registered clients. */
    ArrayList&lt;Messenger&gt; mClients = new ArrayList&lt;Messenger&gt;();
    /** Holds last value set by a client. */
    int mValue = 0;

    /**
     * Command to the service to register a client, receiving callbacks
     * from the service.  The Message's replyTo field must be a Messenger of
     * the client where callbacks should be sent.
     */
    static final int MSG_REGISTER_CLIENT = 1;

    /**
     * Command to the service to unregister a client, ot stop receiving callbacks
     * from the service.  The Message's replyTo field must be a Messenger of
     * the client as previously given with MSG_REGISTER_CLIENT.
     */
    static final int MSG_UNREGISTER_CLIENT = 2;

    /**
     * Command to service to set a new value.  This can be sent to the
     * service to supply a new value, and will be sent by the service to
     * any registered clients with the new value.
     */
    static final int MSG_SET_VALUE = 3;

    /**
     * Handler of incoming messages from clients.
     */
    class IncomingHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_REGISTER_CLIENT:
                    mClients.add(msg.replyTo);
                    break;
                case MSG_UNREGISTER_CLIENT:
                    mClients.remove(msg.replyTo);
                    break;
                case MSG_SET_VALUE:
                    mValue = msg.arg1;
                    for (int i=mClients.size()-1; i&gt;=0; i--) {
                        try {
                            mClients.get(i).send(Message.obtain(null,
                                    MSG_SET_VALUE, mValue, 0));
                        } catch (RemoteException e) {
                            // The client is dead.  Remove it from the list;
                            // we are going through the list from back to front
                            // so this is safe to do inside the loop.
                            mClients.remove(i);
                        }
                    }
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

    /**
     * Target we publish for clients to send messages to IncomingHandler.
     */
    final Messenger mMessenger = new Messenger(new IncomingHandler());

    @Override
    public void onCreate() {
        mNM = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);

        // Display a notification about us starting.
        showNotification();
    }

    @Override
    public void onDestroy() {
        // Cancel the persistent notification.
        mNM.cancel(R.string.remote_service_started);

        // Tell the user we stopped.
        Toast.makeText(this, R.string.remote_service_stopped, Toast.LENGTH_SHORT).show();
    }

    /**
     * When binding to the service, we return an interface to our messenger
     * for sending messages to the service.
     */
    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();
    }

    /**
     * Show a notification while this service is running.
     */
    private void showNotification() {
        // In this sample, we'll use the same text for the ticker and the expanded notification
        CharSequence text = getText(R.string.remote_service_started);

        // Set the icon, scrolling text and timestamp
        Notification notification = new Notification(R.drawable.stat_sample, text,
                System.currentTimeMillis());

        // The PendingIntent to launch our activity if the user selects this notification
        PendingIntent contentIntent = PendingIntent.getActivity(this, 0,
                new Intent(this, Controller.class), 0);

        // Set the info for the views that show in the notification panel.
        notification.setLatestEventInfo(this, getText(R.string.remote_service_label),
                       text, contentIntent);

        // Send the notification.
        // We use a string id because it is a unique number.  We use it later to cancel.
        mNM.notify(R.string.remote_service_started, notification);
    }
}</code></example></para>
      <para tool="javadoc-to-mdoc">If we want to make this service run in a remote process (instead of the
 standard one for its .apk), we can use <c>android:process</c> in its
 manifest tag to specify one:
 
 <example><code lang="xml">&lt;service android:name=".app.MessengerService"
        android:process=":remote" /&gt;</code></example></para>
      <para tool="javadoc-to-mdoc">Note that the name "remote" chosen here is arbitrary, and you can use
 other names if you want additional processes.  The ':' prefix appends the
 name to your package's standard process name.
 
 </para>
      <para tool="javadoc-to-mdoc">With that done, clients can now bind to the service and send messages
 to it.  Note that this allows clients to register with it to receive
 messages back as well:
 
 <example><code lang="java">/** Messenger for communicating with service. */
Messenger mService = null;
/** Flag indicating whether we have called bind on the service. */
boolean mIsBound;
/** Some text view we are using to show state information. */
TextView mCallbackText;

/**
 * Handler of incoming messages from service.
 */
class IncomingHandler extends Handler {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MessengerService.MSG_SET_VALUE:
                mCallbackText.setText("Received from service: " + msg.arg1);
                break;
            default:
                super.handleMessage(msg);
        }
    }
}

/**
 * Target we publish for clients to send messages to IncomingHandler.
 */
final Messenger mMessenger = new Messenger(new IncomingHandler());

/**
 * Class for interacting with the main interface of the service.
 */
private ServiceConnection mConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className,
            IBinder service) {
        // This is called when the connection with the service has been
        // established, giving us the service object we can use to
        // interact with the service.  We are communicating with our
        // service through an IDL interface, so get a client-side
        // representation of that from the raw service object.
        mService = new Messenger(service);
        mCallbackText.setText("Attached.");

        // We want to monitor the service for as long as we are
        // connected to it.
        try {
            Message msg = Message.obtain(null,
                    MessengerService.MSG_REGISTER_CLIENT);
            msg.replyTo = mMessenger;
            mService.send(msg);

            // Give it some value as an example.
            msg = Message.obtain(null,
                    MessengerService.MSG_SET_VALUE, this.hashCode(), 0);
            mService.send(msg);
        } catch (RemoteException e) {
            // In this case the service has crashed before we could even
            // do anything with it; we can count on soon being
            // disconnected (and then reconnected if it can be restarted)
            // so there is no need to do anything here.
        }

        // As part of the sample, tell the user what happened.
        Toast.makeText(Binding.this, R.string.remote_service_connected,
                Toast.LENGTH_SHORT).show();
    }

    public void onServiceDisconnected(ComponentName className) {
        // This is called when the connection with the service has been
        // unexpectedly disconnected -- that is, its process crashed.
        mService = null;
        mCallbackText.setText("Disconnected.");

        // As part of the sample, tell the user what happened.
        Toast.makeText(Binding.this, R.string.remote_service_disconnected,
                Toast.LENGTH_SHORT).show();
    }
};

void doBindService() {
    // Establish a connection with the service.  We use an explicit
    // class name because there is no reason to be able to let other
    // applications replace our component.
    bindService(new Intent(Binding.this, 
            MessengerService.class), mConnection, Context.BIND_AUTO_CREATE);
    mIsBound = true;
    mCallbackText.setText("Binding.");
}

void doUnbindService() {
    if (mIsBound) {
        // If we have received the service, and hence registered with
        // it, then now is the time to unregister.
        if (mService != null) {
            try {
                Message msg = Message.obtain(null,
                        MessengerService.MSG_UNREGISTER_CLIENT);
                msg.replyTo = mMessenger;
                mService.send(msg);
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service
                // has crashed.
            }
        }

        // Detach our existing connection.
        unbindService(mConnection);
        mIsBound = false;
        mCallbackText.setText("Unbinding.");
    }
}</code></example></para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/android/app/Service.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Service ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
        </summary>
        <remarks>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#Service()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Service (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject``1(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Android.App.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Android.App.Application Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getApplication", "()Landroid/app/Application;", "GetGetApplicationHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.App.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Return the application that owns this service.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Return the application that owns this service. </para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#getApplication()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Dump">
      <MemberSignature Language="C#" Value="protected virtual void Dump (Java.IO.FileDescriptor fd, Java.IO.PrintWriter writer, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dump(class Java.IO.FileDescriptor fd, class Java.IO.PrintWriter writer, string[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("dump", "(Ljava/io/FileDescriptor;Ljava/io/PrintWriter;[Ljava/lang/String;)V", "GetDump_Ljava_io_FileDescriptor_Ljava_io_PrintWriter_arrayLjava_lang_String_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fd" Type="Java.IO.FileDescriptor" />
        <Parameter Name="writer" Type="Java.IO.PrintWriter" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fd">The raw file descriptor that the dump is being sent to.</param>
        <param name="writer">The PrintWriter to which you should dump your state.  This will be
 closed for you after you return.</param>
        <param name="args">additional arguments to the dump request.
</param>
        <summary>Print the Service's state into the given stream.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Print the Service's state into the given stream.  This gets invoked if
 you run "adb shell dumpsys activity service &lt;yourservicename&gt;"
 (note that for this command to work, the service must be running, and
 you must specify a fully-qualified service name).
 This is distinct from "dumpsys &lt;servicename&gt;", which only works for
 named system services and which invokes the <c><see cref="!:Android.OS.BinderConsts.dump(java.io.FileDescriptor, java.lang.String[])" /></c> method
 on the <c><see cref="T:Android.OS.BinderConsts" /></c> interface registered with ServiceManager.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#dump(java.io.FileDescriptor, java.io.PrintWriter, java.lang.String[])" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnBind">
      <MemberSignature Language="C#" Value="public abstract Android.OS.IBinder OnBind (Android.Content.Intent intent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Android.OS.IBinder OnBind(class Android.Content.Intent intent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onBind", "(Landroid/content/Intent;)Landroid/os/IBinder;", "GetOnBind_Landroid_content_Intent_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.OS.IBinder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intent" Type="Android.Content.Intent" />
      </Parameters>
      <Docs>
        <param name="intent">The Intent that was used to bind to this service,
 as given to <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c>.  Note that any extras that were included with
 the Intent at that point will <i>not</i> be seen here.</param>
        <summary>Return the communication channel to the service.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Return the communication channel to the service.  May return null if 
 clients can not bind to the service.  The returned
 <c><see cref="T:Android.OS.BinderConsts" /></c> is usually for a complex interface
 that has been <format type="text/html"><a href="http://developer.android.com/reference/../guide/components/aidl.html">described using
 aidl</a></format>.
 
 </para>
          <para tool="javadoc-to-mdoc">
            <i>Note that unlike other application components, calls on to the
 IBinder interface returned here may not happen on the main thread
 of the process</i>.  More information about the main thread can be found in
 <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/fundamentals/processes-and-threads.html">Processes and
 Threads</a></format>.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onBind(android.content.Intent)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnConfigurationChanged">
      <MemberSignature Language="C#" Value="public virtual void OnConfigurationChanged (Android.Content.Res.Configuration newConfig);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnConfigurationChanged(class Android.Content.Res.Configuration newConfig) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onConfigurationChanged", "(Landroid/content/res/Configuration;)V", "GetOnConfigurationChanged_Landroid_content_res_Configuration_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newConfig" Type="Android.Content.Res.Configuration" />
      </Parameters>
      <Docs>
        <param name="newConfig">The new device configuration.
</param>
        <summary>Called by the system when the device configuration changes while your
 component is running.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called by the system when the device configuration changes while your
 component is running.  Note that, unlike activities, other components
 are never restarted when a configuration changes: they must always deal
 with the results of the change, such as by re-retrieving resources.

 </para>
          <para tool="javadoc-to-mdoc">At the time that this function has been called, your Resources
 object will have been updated to return resource values matching the
 new configuration.

 </para>
          <para tool="javadoc-to-mdoc">For more information, read <format type="text/html"><a href="http://developer.android.com/reference/../guide/topics/resources/runtime-changes.html">Handling Runtime Changes</a></format>.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onConfigurationChanged(android.content.res.Configuration)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnCreate">
      <MemberSignature Language="C#" Value="public virtual void OnCreate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnCreate() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onCreate", "()V", "GetOnCreateHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by the system when the service is first created.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called by the system when the service is first created.  Do not call this method directly.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onCreate()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnDestroy">
      <MemberSignature Language="C#" Value="public virtual void OnDestroy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDestroy() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onDestroy", "()V", "GetOnDestroyHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by the system to notify a Service that it is no longer used and is being removed.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called by the system to notify a Service that it is no longer used and is being removed.  The
 service should clean up any resources it holds (threads, registered
 receivers, etc) at this point.  Upon return, there will be no more calls
 in to this Service object and it is effectively dead.  Do not call this method directly.
</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onDestroy()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnLowMemory">
      <MemberSignature Language="C#" Value="public virtual void OnLowMemory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnLowMemory() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onLowMemory", "()V", "GetOnLowMemoryHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>This is called when the overall system is running low on memory, and
 actively running processes should trim their memory usage.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This is called when the overall system is running low on memory, and
 actively running processes should trim their memory usage.  While
 the exact point at which this will be called is not defined, generally
 it will happen when all background process have been killed.
 That is, before reaching the point of killing processes hosting
 service and foreground UI that we would like to avoid killing.

 </para>
          <para tool="javadoc-to-mdoc">You should implement this method to release
 any caches or other unnecessary resources you may be holding on to.
 The system will perform a garbage collection for you after returning from this method.
 </para>
          <para tool="javadoc-to-mdoc">Preferably, you should implement <c><see cref="!:Android.Content.ComponentCallbacks2.onTrimMemory(int)" /></c> from
 <c><see cref="T:Android.Content.ComponentCallbacks2" /></c> to incrementally unload your resources based on various
 levels of memory demands.  That API is available for API level 14 and higher, so you should
 only use this <c><see cref="M:Android.Content.IComponentCallbacks.OnLowMemory" /></c> method as a fallback for older versions, which can be
 treated the same as <c><see cref="!:Android.Content.ComponentCallbacks2.onTrimMemory(int)" /></c> with the <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryComplete" /></c> level.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onLowMemory()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnRebind">
      <MemberSignature Language="C#" Value="public virtual void OnRebind (Android.Content.Intent intent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnRebind(class Android.Content.Intent intent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onRebind", "(Landroid/content/Intent;)V", "GetOnRebind_Landroid_content_Intent_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intent" Type="Android.Content.Intent" />
      </Parameters>
      <Docs>
        <param name="intent">The Intent that was used to bind to this service,
 as given to <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c>.  Note that any extras that were included with
 the Intent at that point will <i>not</i> be seen here.
</param>
        <summary>Called when new clients have connected to the service, after it had
 previously been notified that all had disconnected in its
 <c><see cref="M:Android.App.Service.OnUnbind(Android.Content.Intent)" /></c>.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called when new clients have connected to the service, after it had
 previously been notified that all had disconnected in its
 <c><see cref="M:Android.App.Service.OnUnbind(Android.Content.Intent)" /></c>.  This will only be called if the implementation
 of <c><see cref="M:Android.App.Service.OnUnbind(Android.Content.Intent)" /></c> was overridden to return true.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onRebind(android.content.Intent)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="public virtual void OnStart (Android.Content.Intent intent, int startId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnStart(class Android.Content.Intent intent, int32 startId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onStart", "(Landroid/content/Intent;I)V", "GetOnStart_Landroid_content_Intent_IHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intent" Type="Android.Content.Intent" />
        <Parameter Name="startId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="intent">To be added.</param>
        <param name="startId">To be added.</param>
        <summary>
        </summary>
        <remarks>
          <para tool="javadoc-to-mdoc" />
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onStart(android.content.Intent, int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="OnStartCommand">
      <MemberSignature Language="C#" Value="public virtual Android.App.StartCommandResult OnStartCommand (Android.Content.Intent intent, Android.App.StartCommandFlags flags, int startId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype Android.App.StartCommandResult OnStartCommand(class Android.Content.Intent intent, valuetype Android.App.StartCommandFlags flags, int32 startId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onStartCommand", "(Landroid/content/Intent;II)I", "GetOnStartCommand_Landroid_content_Intent_IIHandler")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.App.StartCommandResult</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName>Android.Runtime.GeneratedEnum</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intent" Type="Android.Content.Intent" />
        <Parameter Name="flags" Type="Android.App.StartCommandFlags">
          <Attributes>
            <Attribute>
              <AttributeName>Android.Runtime.GeneratedEnum</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="startId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="intent">The Intent supplied to <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c>, 
 as given.  This may be null if the service is being restarted after
 its process has gone away, and it had previously returned anything
 except <c><see cref="!:Android.App.Service.START_STICKY_COMPATIBILITY" /></c>.</param>
        <param name="flags">Additional data about this start request.  Currently either
 0, <c><see cref="!:Android.App.Service.START_FLAG_REDELIVERY" /></c>, or <c><see cref="!:Android.App.Service.START_FLAG_RETRY" /></c>.</param>
        <param name="startId">A unique integer representing this specific request to 
 start.  Use with <c><see cref="M:Android.App.Service.StopSelfResult(System.Int32)" /></c>.</param>
        <summary>Called by the system every time a client explicitly starts the service by calling 
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c>, providing the arguments it supplied and a 
 unique integer token representing the start request.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Called by the system every time a client explicitly starts the service by calling 
 <c><see cref="M:Android.Content.Context.StartService(Android.Content.Intent)" /></c>, providing the arguments it supplied and a 
 unique integer token representing the start request.  Do not call this method directly.
 
 </para>
          <para tool="javadoc-to-mdoc">For backwards compatibility, the default implementation calls
 <c><see cref="M:Android.App.Service.OnStart(Android.Content.Intent, System.Int32)" /></c> and returns either <c><see cref="!:Android.App.Service.START_STICKY" /></c>
 or <c><see cref="!:Android.App.Service.START_STICKY_COMPATIBILITY" /></c>.
 
 </para>
          <para tool="javadoc-to-mdoc">If you need your application to run on platform versions prior to API
 level 5, you can use the following model to handle the older <c><see cref="M:Android.App.Service.OnStart(Android.Content.Intent, System.Int32)" /></c>
 callback in that case.  The <c>handleCommand</c> method is implemented by
 you as appropriate:
 
 <example><code lang="java">// This is the old onStart method that will be called on the pre-2.0
// platform.  On 2.0 or later we override onStartCommand() so this
// method will not be called.
@Override
public void onStart(Intent intent, int startId) {
    handleCommand(intent);
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    handleCommand(intent);
    // We want this service to continue running until it is explicitly
    // stopped, so return sticky.
    return START_STICKY;
}</code></example></para>
          <para tool="javadoc-to-mdoc">Note that the system calls this on your
 service's main thread.  A service's main thread is the same
 thread where UI operations take place for Activities running in the
 same process.  You should always avoid stalling the main
 thread's event loop.  When doing long-running operations,
 network calls, or heavy disk I/O, you should kick off a new
 thread, or use <c><see cref="T:Android.OS.AsyncTask`3" /></c>.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onStartCommand(android.content.Intent, int, int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
        <altmember cref="M:Android.App.Service.StopSelfResult(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnTaskRemoved">
      <MemberSignature Language="C#" Value="public virtual void OnTaskRemoved (Android.Content.Intent rootIntent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnTaskRemoved(class Android.Content.Intent rootIntent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onTaskRemoved", "(Landroid/content/Intent;)V", "GetOnTaskRemoved_Landroid_content_Intent_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootIntent" Type="Android.Content.Intent" />
      </Parameters>
      <Docs>
        <param name="rootIntent">The original root Intent that was used to launch
 the task that is being removed.
</param>
        <summary>This is called if the service is currently running and the user has
 removed a task that comes from the service's application.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This is called if the service is currently running and the user has
 removed a task that comes from the service's application.  If you have
 set <c><see cref="F:Android.Content.PM.ServiceInfo.FlagStopWithTask" /></c>
 then you will not receive this callback; instead, the service will simply
 be stopped.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onTaskRemoved(android.content.Intent)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 14" />
      </Docs>
    </Member>
    <Member MemberName="OnTrimMemory">
      <MemberSignature Language="C#" Value="public virtual void OnTrimMemory (Android.Content.TrimMemory level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnTrimMemory(valuetype Android.Content.TrimMemory level) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onTrimMemory", "(I)V", "GetOnTrimMemory_IHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="Android.Content.TrimMemory" />
      </Parameters>
      <Docs>
        <param name="level">The context of the trim, giving a hint of the amount of
 trimming the application may like to perform.  May be
 <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryComplete" /></c>, <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryModerate" /></c>,
 <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryBackground" /></c>, <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryUiHidden" /></c>,
 <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryRunningCritical" /></c>, <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryRunningLow" /></c>,
 or <c><see cref="F:Android.Content.ComponentCallbacks2.TrimMemoryRunningModerate" /></c>.
</param>
        <summary>Called when the operating system has determined that it is a good
 time for a process to trim unneeded memory from its process.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called when the operating system has determined that it is a good
 time for a process to trim unneeded memory from its process.  This will
 happen for example when it goes in the background and there is not enough
 memory to keep as many background processes running as desired.  You
 should never compare to exact values of the level, since new intermediate
 values may be added -- you will typically want to compare if the value
 is greater or equal to a level you are interested in.

 </para>
          <para tool="javadoc-to-mdoc">To retrieve the processes current trim level at any point, you can
 use <c><see cref="M:Android.App.ActivityManager.GetMyMemoryState(.RunningAppProcessInfo)" /></c>.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onTrimMemory(int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 14" />
      </Docs>
    </Member>
    <Member MemberName="OnUnbind">
      <MemberSignature Language="C#" Value="public virtual bool OnUnbind (Android.Content.Intent intent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool OnUnbind(class Android.Content.Intent intent) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onUnbind", "(Landroid/content/Intent;)Z", "GetOnUnbind_Landroid_content_Intent_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intent" Type="Android.Content.Intent" />
      </Parameters>
      <Docs>
        <param name="intent">The Intent that was used to bind to this service,
 as given to <c><see cref="M:Android.Content.Context.BindService(Android.Content.Intent, Android.Content.IServiceConnection, Android.Content.IServiceConnection)" /></c>.  Note that any extras that were included with
 the Intent at that point will <i>not</i> be seen here.</param>
        <summary>Called when all clients have disconnected from a particular interface
 published by the service.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Called when all clients have disconnected from a particular interface
 published by the service.  The default implementation does nothing and
 returns false.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#onUnbind(android.content.Intent)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="SetForeground">
      <MemberSignature Language="C#" Value="public void SetForeground (bool isForeground);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetForeground(bool isForeground) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("setForeground", "(Z)V", "")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isForeground" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isForeground">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartForeground">
      <MemberSignature Language="C#" Value="public void StartForeground (int id, Android.App.Notification notification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartForeground(int32 id, class Android.App.Notification notification) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("startForeground", "(ILandroid/app/Notification;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Int32" />
        <Parameter Name="notification" Type="Android.App.Notification" />
      </Parameters>
      <Docs>
        <param name="id">The identifier for this notification as per
 <c><see cref="M:Android.App.NotificationManager.Notify(System.Int32, Android.App.Notification)" /></c>; must not be 0.</param>
        <param name="notification">The Notification to be displayed.</param>
        <summary>Make this service run in the foreground, supplying the ongoing
 notification to be shown to the user while in this state.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Make this service run in the foreground, supplying the ongoing
 notification to be shown to the user while in this state.
 By default services are background, meaning that if the system needs to
 kill them to reclaim more memory (such as to display a large page in a
 web browser), they can be killed without too much harm.  You can set this
 flag if killing your service would be disruptive to the user, such as
 if your service is performing background music playback, so the user
 would notice if their music stopped playing.
 
 </para>
          <para tool="javadoc-to-mdoc">If you need your application to run on platform versions prior to API
 level 5, you can use the following model to call the the older setForeground()
 or this modern method as appropriate:
 
 <example><code lang="java">private static final Class&lt;?&gt;[] mSetForegroundSignature = new Class[] {
    boolean.class};
private static final Class&lt;?&gt;[] mStartForegroundSignature = new Class[] {
    int.class, Notification.class};
private static final Class&lt;?&gt;[] mStopForegroundSignature = new Class[] {
    boolean.class};

private NotificationManager mNM;
private Method mSetForeground;
private Method mStartForeground;
private Method mStopForeground;
private Object[] mSetForegroundArgs = new Object[1];
private Object[] mStartForegroundArgs = new Object[2];
private Object[] mStopForegroundArgs = new Object[1];

void invokeMethod(Method method, Object[] args) {
    try {
        method.invoke(this, args);
    } catch (InvocationTargetException e) {
        // Should not happen.
        Log.w("ApiDemos", "Unable to invoke method", e);
    } catch (IllegalAccessException e) {
        // Should not happen.
        Log.w("ApiDemos", "Unable to invoke method", e);
    }
}

/**
 * This is a wrapper around the new startForeground method, using the older
 * APIs if it is not available.
 */
void startForegroundCompat(int id, Notification notification) {
    // If we have the new startForeground API, then use it.
    if (mStartForeground != null) {
        mStartForegroundArgs[0] = Integer.valueOf(id);
        mStartForegroundArgs[1] = notification;
        invokeMethod(mStartForeground, mStartForegroundArgs);
        return;
    }

    // Fall back on the old API.
    mSetForegroundArgs[0] = Boolean.TRUE;
    invokeMethod(mSetForeground, mSetForegroundArgs);
    mNM.notify(id, notification);
}

/**
 * This is a wrapper around the new stopForeground method, using the older
 * APIs if it is not available.
 */
void stopForegroundCompat(int id) {
    // If we have the new stopForeground API, then use it.
    if (mStopForeground != null) {
        mStopForegroundArgs[0] = Boolean.TRUE;
        invokeMethod(mStopForeground, mStopForegroundArgs);
        return;
    }

    // Fall back on the old API.  Note to cancel BEFORE changing the
    // foreground state, since we could be killed at that point.
    mNM.cancel(id);
    mSetForegroundArgs[0] = Boolean.FALSE;
    invokeMethod(mSetForeground, mSetForegroundArgs);
}

@Override
public void onCreate() {
    mNM = (NotificationManager)getSystemService(NOTIFICATION_SERVICE);
    try {
        mStartForeground = getClass().getMethod("startForeground",
                mStartForegroundSignature);
        mStopForeground = getClass().getMethod("stopForeground",
                mStopForegroundSignature);
        return;
    } catch (NoSuchMethodException e) {
        // Running on an older platform.
        mStartForeground = mStopForeground = null;
    }
    try {
        mSetForeground = getClass().getMethod("setForeground",
                mSetForegroundSignature);
    } catch (NoSuchMethodException e) {
        throw new IllegalStateException(
                "OS doesn't have Service.startForeground OR Service.setForeground!");
    }
}

@Override
public void onDestroy() {
    // Make sure our notification is gone.
    stopForegroundCompat(R.string.foreground_service_started);
}</code></example></para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
        <altmember cref="M:Android.App.Service.StopForeground(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="StopForeground">
      <MemberSignature Language="C#" Value="public void StopForeground (bool removeNotification);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopForeground(bool removeNotification) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("stopForeground", "(Z)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="removeNotification" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="removeNotification">If true, the notification previously provided
 to <c><see cref="M:Android.App.Service.StartForeground(System.Int32, Android.App.Notification)" /></c> will be removed.  Otherwise it will remain
 until a later call removes it (or the service is destroyed).</param>
        <summary>Remove this service from foreground state, allowing it to be killed if
 more memory is needed.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Remove this service from foreground state, allowing it to be killed if
 more memory is needed.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#stopForeground(boolean)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 5" />
        <altmember cref="M:Android.App.Service.StartForeground(System.Int32, Android.App.Notification)" />
      </Docs>
    </Member>
    <Member MemberName="StopSelf">
      <MemberSignature Language="C#" Value="public void StopSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopSelf() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("stopSelf", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary tool="true">Old version of <see cref="M:Android.App.Service.StopSelfResult(System.Int32)" /> that doesn't return a result.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Stop the service, if it was previously started.  This is the same as
 calling <c><see cref="M:Android.Content.Context.StopService(Android.Content.Intent)" /></c> for this particular service.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#stopSelf()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Android.App.Service.StopSelfResult(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StopSelf">
      <MemberSignature Language="C#" Value="public void StopSelf (int startId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopSelf(int32 startId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("stopSelf", "(I)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startId">To be added.</param>
        <summary>Old version of <c><see cref="M:Android.App.Service.StopSelfResult(System.Int32)" /></c> that doesn't return a result.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Old version of <c><see cref="M:Android.App.Service.StopSelfResult(System.Int32)" /></c> that doesn't return a result.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#stopSelf(int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Android.App.Service.StopSelfResult(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="StopSelfResult">
      <MemberSignature Language="C#" Value="public bool StopSelfResult (int startId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StopSelfResult(int32 startId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("stopSelfResult", "(I)Z", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startId">The most recent start identifier received in <c><see cref="M:Android.App.Service.OnStart(Android.Content.Intent, System.Int32)" /></c>.</param>
        <summary>Stop the service if the most recent time it was started was 
 <format type="text/html"><var>startId</var></format>.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para tool="javadoc-to-mdoc">Stop the service if the most recent time it was started was 
 <format type="text/html"><var>startId</var></format>.  This is the same as calling <c><see cref="M:Android.Content.Context.StopService(Android.Content.Intent)" /></c> for this particular service but allows you to 
 safely avoid stopping if there is a start request from a client that you 
 haven't yet seen in <c><see cref="M:Android.App.Service.OnStart(Android.Content.Intent, System.Int32)" /></c>. 
 
 </para>
          <para tool="javadoc-to-mdoc">
            <i>Be careful about ordering of your calls to this function.</i>.
 If you call this function with the most-recently received ID before
 you have called it for previously received IDs, the service will be
 immediately stopped anyway.  If you may end up processing IDs out
 of order (such as by dispatching them on separate threads), then you
 are responsible for stopping them in the same order you received them.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Service.html#stopSelfResult(int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 1" />
        <altmember cref="M:Android.App.Service.StopSelf" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonvirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>